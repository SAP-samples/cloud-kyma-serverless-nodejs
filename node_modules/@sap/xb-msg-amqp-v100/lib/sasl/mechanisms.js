'use strict';

const { EC, ErrMsg, ErrOptSet } = require('../errors');
const { PROTOCOL, TYPE, build, Frame, Mechanisms, Init, Challenge, Response, Outcome } = require('./frames');

const constants = require('../serialize/constants');
const OK = constants.VALUE.SASL.OUTCOME.OK;
const AUTH = constants.VALUE.SASL.OUTCOME.AUTH;
const SYS = constants.VALUE.SASL.OUTCOME.SYS;
const SYS_PERM = constants.VALUE.SASL.OUTCOME.SYS_PERM;
const SYS_TEMP = constants.VALUE.SASL.OUTCOME.SYS_TEMP;

const SUPPORTED_MECHANISMS = ['ANONYMOUS', 'PLAIN', 'EXTERNAL'];

/**
 * @private
 */
class SaslClient {

    /**
     * @param {ClientOptions|Object} options
     */
    constructor(options) {

        /**
         * @type {string}
         * @private
         */
        this._hostname = options.amqp.peerHostName;

        /**
         * @type {SaslClientConfig}
         * @private
         */
        this._credentials = options.sasl;

        /**
         * @type {Array<SaslMechanism>}
         * @private
         */
        this._available = acceptMechanism(options.sasl.mechanism);

        /**
         * @type {?SaslMechanism}
         * @private
         */
        this._mechanism = null;

    }

    /**
     * @param {!Frame} frame
     * @param {!ReplyWithFrame} reply
     * @param {!NotifyOfSaslDone} done
     * @param {!NotifyOfFailed} failed
     */
    process(frame, reply, done, failed) {
        switch (frame.constructor) {
            case Mechanisms: {
                this._onMechanisms(/**@type{Mechanisms}*/(frame), reply, failed);
                return;
            }
            case Challenge: {
                this._onChallenge(/**@type{Challenge}*/(frame), reply, failed);
                return;
            }
            case Outcome: {
                this._onOutcome(/**@type{Outcome}*/(frame), done, failed);
                return;
            }
        }
        throw ErrMsg(EC.SASL_FRAME_UNEXPECTED, frame.constructor.name);
    }

    /**
     * @param {!Mechanisms} frame
     * @param {!ReplyWithFrame} reply
     * @param {!NotifyOfFailed} failed
     */
    _onMechanisms(frame, reply, failed) {
        if (this._mechanism) {
            throw ErrMsg(EC.SASL_FRAME_UNEXPECTED, 'Mechanisms');
        }

        const expected = this._available;
        const provided = frame.serverMechanisms;
        for (const m of expected) {
            if (provided.includes(m)) {
                this._mechanism = m;
                break;
            }
        }
        if (!this._mechanism) {
            failed(ErrMsg(EC.SASL_MECHANISM_MISMATCH, ErrOptSet(expected), ErrOptSet(provided)));
            return;
        }

        reply(new Init(this._mechanism, serializeData(this._mechanism, this._credentials), this._hostname ? this._hostname : null));
    }

    /**
     * @param {!Challenge} frame
     * @param {!ReplyWithFrame} reply
     * @param {!NotifyOfFailed} failed
     */
    _onChallenge(frame, reply, failed) {
        if (!this._mechanism) {
            throw ErrMsg(EC.SASL_FRAME_TOO_EARLY, frame.constructor.name);
        }
        if (frame.data !== null && frame.data.length !== 0) {
            throw ErrMsg(EC.SASL_CHALLENGE_UNEXPECTED, this._mechanism);
        }

        reply(new Response(serializeData(this._mechanism, this._credentials)));
    }

    /**
     * @param {!Outcome} frame
     * @param {!NotifyOfSaslDone} done
     * @param {!NotifyOfFailed} failed
     */
    _onOutcome(frame, done, failed) {
        if (!this._mechanism) {
            throw ErrMsg(EC.SASL_FRAME_TOO_EARLY, frame.constructor.name);
        }

        switch (frame.code) {
            case OK:
                done(this._mechanism);
                return;
            case AUTH:
                failed(ErrMsg(EC.SASL_OUTCOME_AUTH, this._mechanism));
                return;
            case SYS:
                failed(ErrMsg(EC.SASL_OUTCOME_SYS, this._mechanism));
                return;
            case SYS_PERM:
                failed(ErrMsg(EC.SASL_OUTCOME_SYS_PERM, this._mechanism));
                return;
            case SYS_TEMP:
                failed(ErrMsg(EC.SASL_OUTCOME_SYS_TEMP, this._mechanism));
                return;
            default:
                throw ErrMsg(EC.SASL_OUTCOME_UNEXPECTED, this._mechanism, frame.code);
        }
    }

}

/**
 * @private
 */
class SaslServer {

    /**
     * @param {ServerOptions|Object} options
     */
    constructor(options) {

        /**
         * @type {Array<SaslMechanism>}
         * @private
         */
        this._available = acceptMechanism(options.sasl.mechanism);

        /**
         * @type {?SaslMechanism}
         * @private
         */
        this._mechanism = null;

        /**
         * @type {boolean}
         * @private
         */
        this._completed = false;

    }

    /**
     * @return {!Frame}
     */
    mechanisms() {
        return new Mechanisms(this._available);
    }

    /**
     * @param {!Frame} frame
     * @param {!SaslAuthenticate} authenticate
     * @param {!ReplyWithFrame} reply
     * @param {!NotifyOfFailed} failed
     */
    process(frame, authenticate, reply, failed) {
        switch (frame.constructor) {
            case Init:
                this._onInit(/**@type{Init}*/(frame), authenticate, reply, failed);
                break;
            case Response:
                this._onResponse(/**@type{Response}*/(frame), authenticate, reply, failed);
                break;
            default:
                throw ErrMsg(EC.SASL_FRAME_UNEXPECTED, frame.constructor.name);
        }
    }

    /**
     * @param {Init} frame
     * @param {!SaslAuthenticate} authenticate
     * @param {!ReplyWithFrame} reply
     * @param {!NotifyOfFailed} failed
     * @private
     */
    _onInit(frame, authenticate, reply, failed) {
        if (this._mechanism) {
            throw ErrMsg(EC.SASL_FRAME_UNEXPECTED, 'Init');
        }

        if (this._available.includes(frame.mechanism)) {
            this._mechanism = frame.mechanism;
        } else {
            failed(ErrMsg(EC.SASL_MECHANISM_MISMATCH, this._mechanism, ErrOptSet(this._available)));
            return;
        }

        if (frame.data === null) {
            reply(new Challenge(Buffer.allocUnsafe(0)));
            return;
        }

        authenticate(this._mechanism, deserializeData(this._mechanism, frame.data),
            (error = null, outcome = 0) => this._onAuthenticate(error, outcome, reply, failed)
        );
    }

    /**
     * @param {!Response} frame
     * @param {!SaslAuthenticate} authenticate
     * @param {!ReplyWithFrame} reply
     * @param {!NotifyOfFailed} failed
     * @private
     */
    _onResponse(frame, authenticate, reply, failed) {
        if (!this._mechanism) {
            throw ErrMsg(EC.SASL_FRAME_TOO_EARLY, frame.constructor.name);
        }

        authenticate(this._mechanism, deserializeData(this._mechanism, frame.data),
            (error = null, outcome = 0) => this._onAuthenticate(error, outcome, reply, failed)
        );
    }

    /**
     * @param {Error} error
     * @param {SaslOutcome} outcome
     * @param {!ReplyWithFrame} reply
     * @param {!NotifyOfFailed} failed
     * @private
     */
    _onAuthenticate(error, outcome, reply, failed) {
        if (this._completed) {
            throw ErrMsg(EC.SASL_INV_VALIDATE_CALLBACK);
        } else if (error) {
            failed(error);
        } else if (!Number.isInteger(outcome) || outcome < 0 || outcome > 4) {
            failed(ErrMsg(EC.SASL_OUTCOME_UNEXPECTED, outcome));
        } else {
            reply(new Outcome(outcome));
        }
        this._completed = true;
    }

}

/**
 * @param {SaslMechanismList} mechanisms
 * @return {Array<SaslMechanism>}
 * @private
 */
function acceptMechanism(mechanisms) {
    if (mechanisms) {
        const list = mechanisms.split(' ');
        for (const m of list)
            if (!SUPPORTED_MECHANISMS.includes(m))
                throw ErrMsg(EC.SASL_MECHANISM_NO_SUPPORT, m);
        return list;
    } else {
        return null;
    }
}

/**
 * @param {SaslMechanism} mechanism
 * @param {*} data
 * @return {BinaryValue}
 * @private
 */
function serializeData(mechanism, data) {
    if (data === null || typeof data !== 'object')
        return null;

    switch(mechanism) {
        case 'ANONYMOUS': {
            return (typeof data.identity === 'string') ? Buffer.from(data.identity, 'utf8') : Buffer.allocUnsafe(0);
        }
        case 'PLAIN': {
            const ival = data.identity;
            const uval = data.user;
            const pval = data.password;

            const ilen = Buffer.byteLength(ival);
            const ulen = Buffer.byteLength(uval);
            const plen = Buffer.byteLength(pval);

            const rval = Buffer.allocUnsafe(ilen + 1 + ulen + 1 + plen);
            let offset = 0;

            rval.write(ival, offset, ilen, 'utf8');
            offset += ilen;

            rval.writeUInt8(0, offset);
            offset += 1;

            rval.write(uval, offset, ulen, 'utf8');
            offset += ulen;

            rval.writeUInt8(0, offset);
            offset += 1;

            rval.write(pval, offset, plen, 'utf8');
            return rval;
        }
        case 'EXTERNAL': {
            return (typeof data.identity === 'string') ? Buffer.from(data.identity, 'utf8') : Buffer.allocUnsafe(0);
        }
        default: {
            return null;
        }
    }
}

/**
 * @param {SaslMechanism} mechanism
 * @param {BinaryValue} buffer
 * @return {SaslData}
 * @private
 */
function deserializeData(mechanism, buffer) {
    if (buffer === null)
        return /**@type{SaslData}*/({});

    switch(mechanism) {
        case 'ANONYMOUS': {
            return /**@type{SaslData}*/({identity : buffer.toString('utf8')});
        }
        case 'PLAIN': {
            const sep = [];
            // noinspection JSUnresolvedFunction
            let pos = buffer.indexOf(0);
            while(pos > -1) {
                sep.push(pos);
                // noinspection JSUnresolvedFunction
                pos = buffer.indexOf(0, pos + 1);
            }

            if (sep.length !== 2)
                throw ErrMsg(EC.SASL_INV_CREDENTIAL_DATA, mechanism);

            return /**@type{SaslData}*/({
                identity : buffer.toString('utf8',          0 , sep[0]),
                user     : buffer.toString('utf8', sep[0] + 1 , sep[1]),
                password : buffer.toString('utf8', sep[1] + 1 )
            });
        }
        case 'EXTERNAL': {
            return /**@type{SaslData}*/({identity : buffer.toString('utf8')});
        }
    }
}

module.exports = {
    Client : SaslClient,
    Server : SaslServer,
    acceptMechanism : acceptMechanism,

    /* consumer convenience */

    PROTOCOL : PROTOCOL,
    TYPE : TYPE,
    build : build,
    Frame : Frame,
    Mechanisms: Mechanisms,
    Init: Init,
    Challenge: Challenge,
    Response: Response,
    Outcome: Outcome,
};

