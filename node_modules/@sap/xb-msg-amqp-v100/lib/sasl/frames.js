'use strict';

const { EC, ErrMsg, ErrOpt } = require('../errors');
const { Frame } = require('../serialize/types');

const constants = require('../serialize/constants');
const PROTOCOL = constants.PROTOCOL;
const TYPE = /** @type {FrameType} */ (constants.FRAME.TYPE.SASL);
const LIST0 = constants.CONSTRUCT.PRIMITIVE.COMPLEX.LIST0;
const LIST8 = constants.CONSTRUCT.PRIMITIVE.COMPLEX.LIST8;
const LIST32 = constants.CONSTRUCT.PRIMITIVE.COMPLEX.LIST32;
const MECHANISMS = constants.DESCRIPTOR.SASL.MECHANISMS;
const INIT = constants.DESCRIPTOR.SASL.INIT;
const CHALLENGE = constants.DESCRIPTOR.SASL.CHALLENGE;
const RESPONSE = constants.DESCRIPTOR.SASL.RESPONSE;
const OUTCOME = constants.DESCRIPTOR.SASL.OUTCOME;


/**
 *               type: 0x01 - SASL frame
 *
 *            +0       +1       +2       +3
 *        +-----------------------------------+ -.
 *      0 |                SIZE               |  |
 *        +-----------------------------------+  |---> SaslFrame Header
 *      4 |  DOFF  |  TYPE  |   <IGNORED>*1   |  |      (8 bytes)
 *        +-----------------------------------+ -'
 *        +-----------------------------------+ -.
 *      8 |                ...                |  |
 *        .                                   .  |---> Extended Header
 *        .             <IGNORED>*2           .  |  (DOFF * 4 - 8) bytes
 *        |                ...                |  |
 *        +-----------------------------------+ -'
 *        +-----------------------------------+ -.
 * 4*DOFF |                                   |  |
 *        .                                   .  |
 *        .                                   .  |
 *        .    Sasl Mechanisms / Sasl Init    .  |
 *        .   Sasl Challenge / Sasl Response  .  |---> SaslFrame Body
 *        .           Sasl Outcome            .  |  (SIZE - DOFF * 4) bytes
 *        .                                   .  |
 *        .                                   .  |
 *        .                           ________|  |
 *        |                ...       |           |
 *        +--------------------------+          -'
 *
 *        *1 SHOULD be set to 0x0000
 *        *2 Ignored, so DOFF SHOULD be set to 0x02
 *
 */

/**
 * @private
 * @abstract
 */
class SaslFrame extends Frame {

    /**
     * @param {!Descriptor} descriptor
     */
    constructor(descriptor) {
        super(TYPE, descriptor);
    }

    /**
     * @param {!Encoder} encoder
     */
    encodeData(encoder) {
        encoder.valueComposite(this);
    }

    /**
     * @param {!Encoder} encoder
     */
    encodeMore(encoder) {
        throw ErrMsg(EC.ENCODE_SASL_DATA_TOO_BIG);
    }

    /**
     * @param {!Encoder} encoder
     */
    encodeDone(encoder) {
    }

    /**
     * @param {!Decoder} decoder
     * @return {boolean} - ready
     */
    decodeData(decoder) {
        decoder.readCompositeValue(this);
        return true;
    }

}

/**
 * @private
 * @final
 */
class Mechanisms extends SaslFrame {

    /**
     *
     */
    constructor(mechanisms = null) {
        super(MECHANISMS);

        /**
         * @type {?SymbolArray}
         */
        this.serverMechanisms = mechanisms;
    }

    /**
     * @return {!FormatCode}
     * @override
     */
    defineComp() {
        return (this.serverMechanisms === null) ? LIST0 : (this.serverMechanisms.length > 1) ? LIST32 : LIST8;
    }

    /**
     * @param {!Encoder} encoder
     * @return {!FieldCount}
     * @override
     */
    encodeComp(encoder) {
        encoder.writeSymbols(true, this.serverMechanisms);
        return 1;
    }

    /**
     * @param {!Decoder} decoder
     * @param {BlockCountCheck=} scope
     * @override
     */
    decodeComp(decoder, scope) {
        this.serverMechanisms = decoder.readSymbols(true, scope);
    }

}

/**
 * @private
 * @final
 */
class Init extends SaslFrame {

    /**
     * @param {?SymbolValue=} mechanism
     * @param {?BinaryValue=} data
     * @param {?StringValue=} hostname
     */
    constructor(mechanism = null, data = null, hostname = null){
        super(INIT);

        /**
         * @type {?SymbolValue}
         */
        this.mechanism = mechanism;

        /**
         * @type {?BinaryValue}
         */
        this.data = data;

        /**
         * @type {?StringValue}
         */
        this.hostname = hostname;
    }

    /**
     * @return {!FormatCode}
     * @override
     */
    defineComp() {
        return (this.hostname || this.data !== null) ? LIST32 : LIST8;
    }

    /**
     * @param {!Encoder} encoder
     * @return {!FieldCount}
     * @override
     */
    encodeComp(encoder) {
        encoder.writeSymbol(true, this.mechanism);
        encoder.writeBinary(false, this.data);
        encoder.writeString(false, this.hostname);
        return 3;
    }

    /**
     * @param {!Decoder} decoder
     * @param {BlockCountCheck=} scope
     * @override
     */
    decodeComp(decoder, scope) {
        this.mechanism = decoder.readSymbol(true, scope);
        this.data = decoder.readBinary(false, scope);
        this.hostname = decoder.readString(false, scope);
    }

}

/**
 * @private
 * @final
 */
class Challenge extends SaslFrame {

    /**
     * @param {BinaryValue=} data
     */
    constructor(data = null){
        super(CHALLENGE);

        /**
         * @type {?BinaryValue}
         */
        this.data = data;
    }

    /**
     * @return {!FormatCode}
     * @override
     */
    defineComp() {
        return (this.data !== null && this.data.length > 252) ? LIST32 : LIST8;
    }

    /**
     * @param {!Encoder} encoder
     * @return {!FieldCount}
     * @override
     */
    encodeComp(encoder) {
        encoder.writeBinary(true, this.data);
        return 1;
    }

    /**
     * @param {!Decoder} decoder
     * @param {BlockCountCheck=} scope
     * @override
     */
    decodeComp(decoder, scope) {
        this.data = decoder.readBinary(true, scope);
    }

}

/**
 * @private
 * @final
 */
class Response extends SaslFrame {

    /**
     * @param {BinaryValue=} data
     */
    constructor(data = null){
        super(RESPONSE);

        /**
         * @type {?BinaryValue}
         */
        this.data = data;
    }

    /**
     * @return {!FormatCode}
     * @override
     */
    defineComp() {
        return (this.data !== null && this.data.length > 252) ? LIST32 : LIST8;
    }

    /**
     * @param {!Encoder} encoder
     * @return {!FieldCount}
     * @override
     */
    encodeComp(encoder) {
        encoder.writeBinary(true, this.data);
        return 1;
    }

    /**
     * @param {!Decoder} decoder
     * @param {BlockCountCheck=} scope
     * @override
     */
    decodeComp(decoder, scope) {
        this.data = decoder.readBinary(true, scope);
    }

}

/**
 * @private
 * @final
 */
class Outcome extends SaslFrame {

    /**
     * @param {?number=} code
     * @param {BinaryValue=} data
     */
    constructor(code = null, data = null){
        super(OUTCOME);

        /**
         * @type {?number}
         */
        this.code = code;

        /**
         * @type {?BinaryValue}
         */
        this.data = data;
    }

    /**
     * @return {!FormatCode}
     * @override
     */
    defineComp() {
        return (this.data !== null && this.data.length > 250) ? LIST32 : LIST8;
    }

    /**
     * @param {!Encoder} encoder
     * @return {!FieldCount}
     * @override
     */
    encodeComp(encoder) {
        encoder.writeUByte(true, this.code);
        encoder.writeBinary(false, this.data);
        return 2;
    }

    /**
     * @param {!Decoder} decoder
     * @param {BlockCountCheck=} scope
     * @override
     */
    decodeComp(decoder, scope) {
        this.code = decoder.readUByte(true, scope);
        this.data = decoder.readBinary(false, scope);
    }

}

Outcome.CODE_OK = constants.SASL.OUTCOME.OK;
Outcome.CODE_AUTH = constants.SASL.OUTCOME.AUTH;
Outcome.CODE_SYS = constants.SASL.OUTCOME.SYS;
Outcome.CODE_SYS_PERM = constants.SASL.OUTCOME.SYS_PERM;
Outcome.CODE_SYS_TEMP = constants.SASL.OUTCOME.SYS_TEMP;

/**
 * @param {!Descriptor} desc
 * @return {*}
 * @private
 */
function buildFrame(desc) {
    switch (desc) {
        case MECHANISMS:
            return new Mechanisms();
        case INIT:
            return new Init();
        case CHALLENGE:
            return new Challenge();
        case RESPONSE:
            return new Response();
        case OUTCOME:
            return new Outcome();
        default:
            throw ErrMsg(EC.DECODE_DESC_MISMATCH, desc, ErrOpt(MECHANISMS, INIT, CHALLENGE, RESPONSE, OUTCOME));
    }
}

module.exports = {
    PROTOCOL: PROTOCOL.ID.SASL,
    TYPE : TYPE,
    build : buildFrame,
    Frame : SaslFrame,
    Mechanisms: Mechanisms,
    Init: Init,
    Challenge: Challenge,
    Response: Response,
    Outcome: Outcome
};

