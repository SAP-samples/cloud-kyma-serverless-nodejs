'use strict';

const { EC, ErrMsg } = require('../errors');

/**
 * @param {Array<string>} list
 * @param {string} qualifier
 * @return {Array<string>}
 * @private
 */
function reduceFilter(list, qualifier) {
    const result = [];
    for (const item of list) {
        const segments = item.split('.', 1);
        if (segments.length === 2 && segments[0] === qualifier) result.push(segments[1]);
    }
    return result;
}

/**
 * @param {!{}} target
 * @param {!{}} template
 * @param {!Array<string>} optional
 * @param {boolean=} maximize
 * @return {!{}}
 * @private
 */
function mergeValues(target, template, optional, maximize) {
    Object.keys(template).forEach((key) => {
        switch (typeof target[key]) {
            case 'undefined':
                if (optional.includes(key) || optional.includes('*')) {
                    return;
                }
                switch (typeof template[key]) {
                    case 'object':
                        if (template[key] === null) {
                            target[key] = null;
                        } else if (Array.isArray(template[key])) {
                            target[key] = template[key].slice();
                        } else if (Buffer.isBuffer(template[key])) {
                            target[key] = Buffer.from(template[key]);
                        } else if (template[key].constructor.name === 'Object') {
                            target[key] = mergeValues({}, template[key], reduceFilter(optional, key), maximize);
                        } else {
                            target[key] = template[key];
                        }
                        break;
                    default:
                        target[key] = template[key];
                        break;
                }
                break;
            case (typeof template[key]):
                switch(typeof template[key]) {
                    case 'object':
                        if (template[key] === null || target[key] === null) {
                            return;
                        }
                        if (template[key].constructor.name !== target[key].constructor.name) {
                            throw ErrMsg(EC.OPT_INV_TYPE, key, (typeof template[key]));
                        }
                        if (template[key].constructor.name === 'Object') {
                            mergeValues(target[key], template[key], reduceFilter(optional, key), maximize);
                        }
                        break;
                    case 'number':
                        if (maximize) {
                            target[key] = Math.max(parseInt(target[key]), template[key]);
                        }
                        break;
                }
                break;
            default:
                if (typeof template[key] !== 'undefined') {
                    throw ErrMsg(EC.OPT_INV_TYPE, key, (typeof template[key]));
                }
        }
    });
    return target;
}

/**
 * @param {*} object
 * @return {Array<*>}
 * @private
 */
function objectValues(object) {
    let result = [], field, fields = Object.getOwnPropertyNames(object);
    for (field of fields) result.push(object[field]);
    return result;
}

module.exports = {
    mergeValues : mergeValues,
    objectValues : objectValues
};

