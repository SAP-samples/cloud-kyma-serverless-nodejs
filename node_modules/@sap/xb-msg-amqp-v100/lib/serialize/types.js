'use strict';

const { EC, ErrMsg, ErrOpt } = require('../errors');

const constants = require('./constants');
const SIMPLE = constants.CONSTRUCT.PRIMITIVE.SIMPLE;
const JSYM_PRIM = constants.RUNTIME.SYMBOL.PRIMITIVE;

/*********************************************************************************************************************/
/** defined types: core layer ****************************************************************************************/
/*********************************************************************************************************************/

/**
 * @typedef {Object} StreamParameters
 * @property {boolean} decodeWrappedValues - Field and annotation values use String or Number wrapper to keep type information
 * @property {boolean} decodeUnsafeIntegers - Field and annotation values use strings for unsafe 64 bit integers
 * @property {number} istreamHighWaterFrames - The outbound stream high water mark as number of frames.
 * @property {number} istreamHighWaterBytes - The outbound stream high water mark in bytes.
 * @property {number} ostreamHighWaterFrames - The outbound stream high water mark as number of frames.
 * @property {number} ostreamHighWaterBytes - The outbound stream high water mark in bytes.
 * @property {number} ostreamChunkRecycleLimit - A number of chunks with default size to keep in recycle buffer.
 * @property {number} ostreamChunkDefaultSize - A proposal in bytes for chunks sizes in outbound stream.
 * @property {number} ostreamPayloadCopyLimit - A proposal in bytes to avoid payload copy in outbound stream
 * @property {number} socketEndCloseTimeout - A time in milliseconds to wait with final connection close
 */

/*********************************************************************************************************************/
/** defined types: type system ***************************************************************************************/
/*********************************************************************************************************************/

/**
 * @typedef {number} ProtocolIdentifier
 */

/**
 * @typedef {number} FrameType
 */

/**
 * @typedef {number} FrameSize
 */

/**
 * @typedef {UShort} ChannelHandle
 */

/**
 * @typedef {number} FormatCode
 */

/**
 * @typedef {number} FieldCount
 */

/**
 * @typedef {number|string|Number|String} Descriptor
 */

/**
 * @typedef {boolean} Bool
 */

/**
 * @typedef {number} UByte
 */

/**
 * @typedef {number} UShort
 */

/**
 * @typedef {number} UInt
 */

/**
 * @typedef {number} ULong
 */

/**
 * @typedef {Date} Timestamp
 */

/**
 * @typedef {Buffer} UUID
 */

/**
 * @typedef {Buffer} BinaryValue
 */

/**
 * @typedef {string} BinaryString
 */

/**
 * @typedef {string} StringValue
 */

/**
 * @typedef {string} SymbolValue
 */

/**
 * @typedef {Array<SymbolValue>} SymbolArray
 */

/*********************************************************************************************************************/
/** defined types: base layer ****************************************************************************************/
/*********************************************************************************************************************/

/**
 * @callback CompositeFactory
 * @param {!Descriptor} descriptor
 * @return {!Composite}
 * @private
 */

/**
 * @callback FrameBuilder
 * @param {!Descriptor} descriptor
 * @return {!Frame}
 * @private
 */

/**
 * @callback FrameHandler
 * @param {!Frame} frame
 * @private
 */

/**
 * @typedef {Object} FrameLibrary
 * @property {ProtocolIdentifier} PROTOCOL
 * @property {FrameType} TYPE
 * @property {FrameBuilder} build
 * @private
 */

/**
 * @callback NotifyOfProtocolStart
 * @param {FrameLibrary} library
 */

/**
 * @callback NotifyOfDone
 */

/**
 * @callback NotifyOfFailed
 * @param {Error} error
 */

/**
 * @callback ReplyWithFrame
 * @param {!Frame} reply
 * @private
 */

/**
 * @callback JsStyleCallback
 * @param {Error=} error
 */

/*********************************************************************************************************************/
/** implemented types: base layer ************************************************************************************/
/*********************************************************************************************************************/

/**
 * @final
 */
class Factory {

    static UByte(value) {
        return _newInt(SIMPLE.UBYTE, value, 'UByte', 0, 0xFF);
    }

    static UShort(value) {
        return _newInt(SIMPLE.USHORT, value, 'UShort', 0, 0xFFFF);
    }

    static UInt(value) {
        return _newInt(SIMPLE.UINT, value, 'UInt', 0, 0xFFFFFFFF);
    }

    static Byte(value) {
        return _newInt(SIMPLE.BYTE, value, 'Byte', -128, 127);
    }

    static Short(value) {
        return _newInt(SIMPLE.SHORT, value, 'Short', -32768, 32767);
    }

    static Int(value) {
        return _newInt(SIMPLE.INT, value, 'Int', -2147483648, 2147483647);
    }

    static Symbol(value) {
        if (typeof value !== 'string') {
            throw ErrMsg(EC.VAL_TYPE_MISMATCH, 'Symbol', typeof value);
        }
        const len = Buffer.byteLength(value, 'ascii');
        const cty = (len > 255) ? SIMPLE.SYM32 : SIMPLE.SYM8;
        return _wrapData(cty, value, String);
    }

    static String(value) {
        if (typeof value !== 'string') {
            throw ErrMsg(EC.VAL_TYPE_MISMATCH, 'String', typeof value);
        }
        const len = Buffer.byteLength(value, 'utf8');
        const cty = (len > 255) ? SIMPLE.STR32 : SIMPLE.STR8;
        return _wrapData(cty, value, String);
    }

}

/**
 * @private
 */
function _newInt(kind, value, name, min, max)  {
    if (typeof value !== 'number')
        throw ErrMsg(EC.VAL_TYPE_MISMATCH, name, typeof value);
    if (!Number.isInteger(value) || value < min || value > max)
        throw ErrMsg(EC.VAL_TYPE_INT_RANGE, name, min, max);
    return _wrapData(kind, value, Number);
}

/**
 * @private
 */
function _wrapData(kind, value, type) {
    const v = new type(value);
    v[JSYM_PRIM] = kind;
    return v;
}

/**
 * @final
 */
class Payload {

    /**
     * @param {(string|Buffer)=} first
     * @param {...Buffer} chunks
     */
    constructor(first, ...chunks) {

        /**
         * @type {Array<!Buffer>}
         */
        this.chunks = typeof first === 'string' ? chunks : Buffer.isBuffer(first) ? [first].concat(chunks) : chunks;

        /**
         * @type {?string}
         */
        this.type = typeof first === 'string' ? first : null;

        /**
         * @type {?string}
         */
        this.encoding = null;

        /**
         * @type {*}
         */
        this.data = null;

        /**
         * @type {?Object}
         */
        this.properties = null;

    }

    /**
     * @return {boolean}
     */
    valid() {
        return Array.isArray(this.chunks) && this.chunks.every(item => Buffer.isBuffer(item));
    }

    /**
     * @return {number}
     */
    size() {
        let size = 0;
        for (const chunk of this.chunks)
            size += chunk.length;
        return size;
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * @param {number} maxSize
     * @param {function(Buffer)} consume
     */
    toSlices(maxSize, consume) {
        for (const chunk of this.chunks) {
            let offset = 0;
            let length = chunk.length;
            while (length) {
                if (length > maxSize) {
                    consume(chunk.slice(offset, offset + maxSize));
                    offset += maxSize;
                    length -= maxSize;
                } else {
                    consume(chunk.slice(offset, offset + length));
                    length = 0;
                }
            }
        }
    }

    /**
     * @param {string=} encoding
     * @returns {!string}
     */
    toString(encoding) {
        switch(this.chunks.length) {
            case 0:
                return '';
            case 1:
                return this.chunks[0].toString(encoding);
            default:
                return Buffer.concat(this.chunks).toString(encoding);
        }
    }

    /**
     * @returns {!Buffer}
     */
    toBuffer() {
        switch(this.chunks.length) {
            case 0:
                return Buffer.alloc(0);
            case 1:
                return this.chunks[0];
            default:
                return Buffer.concat(this.chunks);
        }
    }

}

/**
 * @private
 * @abstract
 */
class Serializable {

    /**
     *
     */
    constructor() {

    }

    /**
     * @param {!Encoder} encoder
     * @abstract
     */
    encodeData(encoder) {
    }

    /**
     * @param {!Decoder} decoder
     * @return {boolean} - still incomplete?
     * @abstract
     */
    decodeData(decoder) {
    }

}

/**
 * @private
 * @abstract
 */
class Composite {

    /**
     * @param {!Descriptor} descriptor
     */
    constructor(descriptor) {

        /**
         * @const {!Descriptor}
         */
        this.descriptor = descriptor;

    }

    /**
     * @returns {!FormatCode}
     * @abstract
     */
    defineComp() {
    }

    /**
     * @param {!Encoder} encoder
     * @return {!FieldCount}
     * @abstract
     */
    encodeComp(encoder) {
    }

    /**
     * @param {!Decoder} decoder
     * @param {BlockCountCheck=} scope
     * @abstract
     */
    decodeComp(decoder, scope) {
    }

}

/**
 * @private
 * @abstract
 */
class Frame extends Composite {

    /**
     * @param {!FrameType} type
     * @param {!Descriptor} descriptor
     */
    constructor(type, descriptor) {

        /**
         * @param {number} descriptor
         */
        super(descriptor);

        /**
         * @const {FrameType}
         */
        this.type = type;

        /**
         * @type {ChannelHandle}
         */
        this.channel = 0;

    }

    /**
     * @param {!Encoder} encoder
     * @abstract
     */
    encodeData(encoder) {
    }

    /**
     * @param {!Encoder} encoder
     * @abstract
     */
    encodeMore(encoder) {
    }

    /**
     * @param {!Encoder} encoder
     * @abstract
     */
    encodeDone(encoder) {
    }

    /**
     * @param {!Decoder} decoder
     * @return {boolean} - ready
     * @abstract
     */
    decodeData(decoder) {
    }

}

module.exports = {
    Factory: Factory,
    Payload: Payload,
    Serializable: Serializable,
    Composite: Composite,
    Frame: Frame
};

