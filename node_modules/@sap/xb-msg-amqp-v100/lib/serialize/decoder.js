'use strict';

const { EC, ErrMsg, ErrOpt, ErrOptSet } = require('../errors');
const { readUInt64BE, readInt64BE } = require('../tools/bignum');

const constants = require('./constants');
const PROTOCOL = constants.PROTOCOL;
const MINMAX = constants.FRAME.SIZE.MINMAX;
const HEADSIZE = constants.FRAME.SIZE.HEADER;
const SIMPLE = constants.CONSTRUCT.PRIMITIVE.SIMPLE;
const COMPLEX = constants.CONSTRUCT.PRIMITIVE.COMPLEX;
const DESCRIPTOR = constants.CONSTRUCT.DESCRIPTOR;
const JSYM_DESC = constants.RUNTIME.SYMBOL.DESCRIPTOR;
const JSYM_PRIM = constants.RUNTIME.SYMBOL.PRIMITIVE;
const JSYM_PRIM_ITEM = constants.RUNTIME.SYMBOL.PRIM_ITEM;
const JSYM_DESC_ITEM = constants.RUNTIME.SYMBOL.DESC_ITEM;

/**
 * @param {*=} result
 * @return {*}
 * @private
 */
function nop(result) { return result; }

/**
 * @callback NotifyOfDataPushed
 * @private
 */

/**
 * @callback BlockCountCheck
 * @param {number} items
 * @return {boolean}
 * @private
 */

/**
 * @private
 */
class Decoder {

    /**
     * @param {!StreamParameters} options
     * @param {!FrameHandler} handler
     */
    constructor(options, handler) {

        /**
         * @const {!StreamParameters}
         * @private
         */
        this.options = options;

        /**
         * @type {number}
         */
        this.statFrameCount = 0;

        /**
         * @type {number}
         */
        this.statChunkCount = 0;

        /**
         * @type {!FrameSize}
         */
        this.maxFrameSize = MINMAX;

        /**
         * @type {number}
         */
        this.maxMessageSizeDefault = 0;

        /**
         * @type {Map<ChannelHandle, Map<LinkHandle, number>>}
         * @private
         */
        this._maxMessageSize = new Map();

        /**
         * @const {boolean}
         * @private
         */
        this._useWrappedValues = options.decodeWrappedValues;

        /**
         * @const {boolean}
         * @private
         */
        this._useUnsafeIntegers = options.decodeUnsafeIntegers;

        /**
         * @type {FrameType}
         * @private
         */
        this._frameType = -1;

        /**
         * @type {!FrameBuilder}
         * @private
         */
        this._frameBuilder = nop;

        /**
         * @type {!FrameHandler}
         * @private
         */
        this._frameHandler = handler;

        /**
         * @type {boolean}
         * @private
         */
        this._stateIdle = true;

        /**
         * @const {!FrameCache}
         */
        this.frameCache = new FrameCache();

        /**
         * @type {number}
         */
        this.bytesExpected = 0;

        /**
         * @type {number}
         */
        this.bytesConsumed = 0;

        /**
         * @type {number}
         */
        this.inputAvailable = 0;

        /**
         * @type {!Array<!Buffer>}
         * @private
         */
        this._inputQueue = [];

        /**
         * @type {number}
         * @private
         */
        this._chunkAvailable = 0;

        /**
         * @type {number}
         * @private
         */
        this._chunkConsumed = 0;

        /**
         * @type {number}
         * @private
         */
        this._chunkOffset = 0;

        /**
         * @type {Buffer}
         * @private
         */
        this._chunkReading = null;

        /**
         * @type {!Array<!Buffer>}
         * @private
         */
        this._chunkHistory = [];

        /**
         * @type {Decoder}
         * @private
         */
        this._slaveDecoder = null;

    }

    /**
     * @param {ChannelHandle} channel
     * @param {LinkHandle} link
     * @return {number}
     */
    getMaxMessageSize(channel, link) {
        const cs = this._maxMessageSize.get(channel);
        if (!cs) return this.maxMessageSizeDefault;
        const ls = cs.get(link);
        return ls !== undefined ? ls : this.maxMessageSizeDefault;
    }

    /**
     * @param {ChannelHandle} channel
     * @param {LinkHandle} link
     * @param {number} size
     */
    setMaxMessageSize(channel, link, size) {
        let cs = this._maxMessageSize.get(channel);
        if (!cs) {
            cs = new Map();
            this._maxMessageSize.set(channel, cs);
        }
        cs.set(link, size);
    }

    /**
     * @param {?Array<!Buffer>} chunks
     * @param {!Serializable} target
     */
    decode(chunks, target) {
        if (chunks === null) return;
        const slave = this._slaveDecoder ? this._slaveDecoder : new Decoder(this.options, nop);
        this._slaveDecoder = null;

        for (const c of chunks) slave.push(c);
        slave.bytesExpected = slave.inputAvailable;
        target.decodeData(slave);
        if (slave.inputAvailable) throw ErrMsg(EC.DECODE_PAYLOAD_SIZE_MISMATCH, slave.inputAvailable);

        slave._chunkHistory.length = 0;
        slave.bytesConsumed = 0;
        slave.bytesExpected = 0;
        this._slaveDecoder = slave;
    }

    /**
     * @param {!FrameHandler} handler
     * @return {!FrameHandler}
     */
    bind(handler) {
        const previous = this._frameHandler;
        this._frameHandler = handler;
        return previous;
    }

    /**
     * @param {FrameLibrary|Array<FrameLibrary>} expected
     * @param {NotifyOfProtocolStart=} done
     */
    init(expected, done = nop) {
        this._read = () => this._readProtocol(expected, done);
        this._read();
    }

    /**
     *
     */
    stop() {
        this._read = Object.getPrototypeOf(this)._read;
    }

    /**
     * @param {!Buffer} chunk
     */
    push(chunk) {
        if (chunk.length === 0) {
            return;
        } else if (this.inputAvailable === 0) {
            this.inputAvailable = chunk.length;
            this._chunkAvailable = chunk.length;
            this._chunkConsumed = 0;
            this._chunkOffset = 0;
            this._chunkReading = chunk;
        } else {
            this._inputQueue.push(chunk);
            this.inputAvailable += chunk.length;
        }
        ++this.statChunkCount;
        this._read();
    }

    /**
     * @private
     */
    _read() {
        // dynamic override by bound _readProtocol and _readFrame afterwards
    }

    /**
     * @param {FrameLibrary|Array<FrameLibrary>} expected
     * @param {!NotifyOfProtocolStart} done
     * @private
     */
    _readProtocol(expected, done) {
        if (this.inputAvailable < HEADSIZE) return;

        const name = this.readDataASCII(4);
        const id = this.readDataUInt8();
        const major = this.readDataUInt8();
        const minor = this.readDataUInt8();
        const revision = this.readDataUInt8();

        if (name !== PROTOCOL.NAME)
            throw ErrMsg(EC.DECODE_PROTOCOL_ERROR, 'name', name, PROTOCOL.NAME);
        if (major !== PROTOCOL.VERSION.MAJOR)
            throw ErrMsg(EC.DECODE_PROTOCOL_ERROR, 'major', major, PROTOCOL.VERSION.MAJOR);
        if (minor !== PROTOCOL.VERSION.MINOR)
            throw ErrMsg(EC.DECODE_PROTOCOL_ERROR, 'minor', minor, PROTOCOL.VERSION.MINOR);
        if (revision !== PROTOCOL.VERSION.REVISION)
            throw ErrMsg(EC.DECODE_PROTOCOL_ERROR, 'revision', revision, PROTOCOL.VERSION.REVISION);

        let library;
        if (Array.isArray(expected)) {
            library = expected.find((library) => {return library.PROTOCOL === id;});
            if (!library)
                throw ErrMsg(EC.DECODE_PROTOCOL_ERROR, 'id', id, ErrOptSet(expected.map(library => library.PROTOCOL)));
        } else {
            if (expected.PROTOCOL !== id)
                throw ErrMsg(EC.DECODE_PROTOCOL_ERROR, 'id', id, expected.PROTOCOL);
            library = expected;
        }

        this.bytesExpected = 0;
        this.bytesConsumed = 0;

        this._frameType = library.TYPE;
        this._frameBuilder = library.build;
        this._read = this._readFrames;

        done(library);
        if (this._stateIdle) this._read();
    }

    /**
     * @private
     */
    _readFrames() {
        this._stateIdle = false;
        let doff, channel, frame, ready;
        while (this.inputAvailable) {
            if (this.bytesExpected === 0) {
                if (this.inputAvailable < HEADSIZE) return;
                this.bytesExpected = this._readFrameSize();
            }
            if (this.inputAvailable < this.bytesExpected - 4) return;

            doff = this.readDataUInt8();
            this.skipByte(/**@type{number}*/(this._frameType));
            channel = this.readDataUInt16();
            this.skipBytes(doff * 4 - 8);

            frame = this._frameBuilder(this.bytesExpected > HEADSIZE ? this.readDescriptor(false, false) : null);
            frame.channel = channel;
            frame.decodeData(this);

            if (this.bytesExpected !== this.bytesConsumed)
                throw ErrMsg(EC.DECODE_FRAME_SIZE_MISMATCH, this.bytesExpected, this.bytesConsumed);

            this._chunkHistory.length = 0;
            this.bytesExpected = 0;
            this.bytesConsumed = 0;

            ++this.statFrameCount;

            this._frameHandler(frame);
        }
        this._stateIdle = true;
    }

    /**
     * @return {number}
     * @private
     */
    _readFrameSize() {
        const size = this.readDataUInt32();
        if (size < HEADSIZE)
            throw ErrMsg(EC.DECODE_FRAME_SIZE_TOO_SMALL, size, HEADSIZE);
        if (size > this.maxFrameSize)
            throw ErrMsg(EC.DECODE_FRAME_SIZE_TOO_BIG, size, this.maxFrameSize);
        return size;
    }

    /**
     * @param {number} length
     * @private
     */
    _reading(length) {
        if(length > this.inputAvailable)
            throw ErrMsg(EC.DECODE_BUFFER_END_REACHED);
        if(length > this._chunkAvailable)
            this._readingMore(length);
        this._chunkOffset = this._chunkConsumed;
        this._chunkConsumed += length;
        this._chunkAvailable -= length;
        this.bytesConsumed += length;
        this.inputAvailable -= length;
    }

    /**
     * @param {number} length
     * @private
     */
    _readingMore(length) {
        if (this._chunkAvailable === 0 && length <= this._inputQueue[0].length) {
            this._chunkHistory.push(this._chunkReading);
            this._chunkReading = this._inputQueue.shift();
            this._chunkAvailable = this._chunkReading.length;
        } else {
            this._readingMoreConcat(length);
        }
        this._chunkConsumed = 0;
    }

    /**
     * @param {number} length
     * @private
     */
    _readingMoreConcat(length) {
        const chunks = [];
        if (this._chunkAvailable > 0) {
            chunks.push(this._chunkReading.slice(this._chunkConsumed));
            this._chunkHistory.push(this._chunkReading.slice(0, this._chunkConsumed));
        } else {
            this._chunkHistory.push(this._chunkReading);
        }
        while (this._chunkAvailable < length) {
            const miss = length - this._chunkAvailable, next = this._inputQueue[0], nlen = next.length;
            if (miss >= nlen || (miss > 42 && nlen < 256)) {
                this._chunkAvailable += nlen;
                chunks.push(this._inputQueue.shift());
            } else {
                this._chunkAvailable += miss;
                chunks.push(next.slice(0, miss));
                this._inputQueue[0] = next.slice(miss);
            }
        }
        this._chunkReading = chunks.length > 1 ? Buffer.concat(chunks, this._chunkAvailable) : chunks[0];
    }

    /**
     * @return {!BlockCountCheck}
     * @private
     */
    _readBlockSizeCountUInt8() {
        this._reading(2);
        const end = this._chunkReading.readUInt8(this._chunkOffset) + this.bytesConsumed - 1;
        const cnt = this._chunkReading.readUInt8(this._chunkOffset + 1);
        return this._initBlockSizer(end, cnt);
    }

    /**
     * @return {!BlockCountCheck}
     * @private
     */
    _readBlockSizeCountUInt32() {
        this._reading(8);
        const end = this._chunkReading.readUInt32BE(this._chunkOffset) + this.bytesConsumed - 4;
        const cnt = this._chunkReading.readUInt32BE(this._chunkOffset + 4);
        return this._initBlockSizer(end, cnt);
    }

    _initBlockSizer(end, cnt) {
        let count = 0;
        return (items) => {
            if (this.bytesConsumed < end) {
                if (items) count += items;
                return true;
            }
            if (this.bytesConsumed > end) {
                throw ErrMsg(EC.DECODE_BLOCK_BYTES_MISMATCH, this.bytesConsumed, (this.bytesConsumed - end));
            }
            if (cnt !== count) {
                throw ErrMsg(EC.DECODE_BLOCK_COUNT_MISMATCH, this.bytesConsumed, cnt, count);
            }
            return false;
        };
    }

    initStreamMarker() {
        let ignore = this._chunkHistory.length;
        let offset = this._chunkConsumed;

        return (list) => {
            if (list) {
                const length = this._chunkHistory.length;
                for (let i = ignore; i < length; ++i) {
                    if (offset) {
                        list.push(this._chunkHistory[i].slice(offset));
                        offset = 0;
                    } else {
                        list.push(this._chunkHistory[i]);
                    }
                }
                if (this._chunkConsumed) {
                    if (offset === 0 && this._chunkConsumed === this._chunkReading.length) {
                        list.push(this._chunkReading);
                    } else {
                        list.push(this._chunkReading.slice(offset, this._chunkConsumed));
                    }
                }
            }
            ignore = this._chunkHistory.length;
            offset = this._chunkConsumed;
        };
    }

    /**
     * @param {number} count
     * @final
     */
    skipBytes(count) {
        this._reading(count);
    }

    /**
     * @param {number} expected
     * @final
     */
    skipByte(expected) {
        this._reading(1);
        const value = this._chunkReading.readUInt8(this._chunkOffset);
        if (value !== expected) {
            throw ErrMsg(EC.DECODE_VAL_NOT_EXPECTED, this.bytesConsumed, value, expected);
        }
    }

    /**
     * @return {number}
     * @final
     */
    readDataUInt8() {
        this._reading(1);
        return this._chunkReading.readUInt8(this._chunkOffset);
    }

    /**
     * @return {number}
     * @final
     */
    readDataUInt16() {
        this._reading(2);
        return this._chunkReading.readUInt16BE(this._chunkOffset);
    }

    /**
     * @return {number}
     * @final
     */
    readDataUInt32() {
        this._reading(4);
        return this._chunkReading.readUInt32BE(this._chunkOffset);
    }

    /**
     * @param {number} size
     * @return {string}
     */
    readDataASCII(size) {
        this._reading(size);
        return this._chunkReading.toString('ascii', this._chunkOffset, this._chunkOffset + size);
    }

    /**
     * @param {number} size
     * @return {string}
     */
    readDataString(size) {
        this._reading(size);
        return this._chunkReading.toString('utf8', this._chunkOffset, this._chunkOffset + size);
    }

    /**
     * @param {number} size
     * @return {!Buffer}
     * @final
     */
    readDataBlob(size) {
        this._reading(size);
        return (size === this._chunkReading.length) ? this._chunkReading : this._chunkReading.slice(this._chunkOffset, this._chunkOffset + size);
    }

    /**
     * @param {Array<!Buffer>=} chunks
     * @param {number=} length
     * @return {!Array<!Buffer>}
     * @final
     */
    readDataBlobArray(chunks, length = this.bytesExpected - this.bytesConsumed) {
        const result = chunks ? chunks : [];
        while (length > 0) {
            if(this._chunkAvailable === 0) {
                const size = Math.min(length, this._inputQueue[0].length);
                result.push(this.readDataBlob(size));
                length -= size;
            } else if (length > this._chunkAvailable) {
                const size = this._chunkAvailable;
                result.push(this.readDataBlob(size));
                length -= size;
            } else {
                result.push(this.readDataBlob(length));
                length = 0;
            }
        }
        return result;
    }

    /**
     * @param {boolean} mandatory
     * @param {?BlockCountCheck} scope
     * @param {?boolean=} previous
     * @return {?boolean}
     * @final
     */
    readBool(mandatory, scope, previous = null) {
        const c = (scope && !scope(1)) ? NULL : this.readDataUInt8();
        switch(c){
            case NULL: {
                if (mandatory) throw ErrMsg(EC.DECODE_MISS_MAND_VAL, this.bytesConsumed, 'bool');
                return previous;
            }
            case TRUE: {
                return true;
            }
            case FALSE: {
                return false;
            }
            case BOOL: {
                this._reading(1);
                const v = this._chunkReading.readUInt8(this._chunkOffset);
                switch (v) {
                    case VBOOL_TRUE:
                        return true;
                    case VBOOL_FALSE:
                        return false;
                }
                throw ErrMsg(EC.DECODE_VAL_NOT_EXPECTED, this.bytesConsumed, v, ErrOpt(VBOOL_TRUE, VBOOL_FALSE));
            }
            default: {
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, c, ErrOpt(NULL, TRUE, FALSE, BOOL));
            }
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?BlockCountCheck} scope
     * @param {?number=} previous
     * @return {?number}
     * @final
     */
    readUByte(mandatory, scope, previous = null) {
        const c = (scope && !scope(1)) ? NULL : this.readDataUInt8();
        switch(c){
            case NULL: {
                if (mandatory) throw ErrMsg(EC.DECODE_MISS_MAND_VAL, this.bytesConsumed, 'ubyte');
                return previous;
            }
            case UBYTE: {
                this._reading(1);
                return this._chunkReading.readUInt8(this._chunkOffset);
            }
            default:
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, c, ErrOpt(NULL, UBYTE));
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?BlockCountCheck} scope
     * @return {?number}
     * @final
     */
    readUShort(mandatory, scope) {
        const c = (scope && !scope(1)) ? NULL : this.readDataUInt8();
        switch(c){
            case NULL: {
                if (mandatory) throw ErrMsg(EC.DECODE_MISS_MAND_VAL, this.bytesConsumed, 'ushort');
                return null;
            }
            case USHORT: {
                this._reading(2);
                return this._chunkReading.readUInt16BE(this._chunkOffset);
            }
            default:
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, c, ErrOpt(NULL, USHORT));
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?BlockCountCheck} scope
     * @param {?number=} previous
     * @return {?number}
     * @final
     */
    readUInt(mandatory, scope, previous = null) {
        const c = (scope && !scope(1)) ? NULL : this.readDataUInt8();
        switch(c){
            case NULL:
                if (mandatory) throw ErrMsg(EC.DECODE_MISS_MAND_VAL, this.bytesConsumed, 'uint');
                return previous;
            case UINT0:
                return 0;
            case SMALLUINT:
                return this.readDataUInt8();
            case UINT:
                return this.readDataUInt32();
            default:
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, c, ErrOpt(NULL, UINT0, SMALLUINT, UINT));
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?BlockCountCheck} scope
     * @param {boolean=} unsafe64
     * @return {?number}
     * @final
     */
    readULong(mandatory, scope, unsafe64) {
        const c = (scope && !scope(1)) ? NULL : this.readDataUInt8();
        switch(c){
            case NULL: {
                if (mandatory) throw ErrMsg(EC.DECODE_MISS_MAND_VAL, this.bytesConsumed, 'ulong');
                return null;
            }
            case ULONG0: {
                return 0;
            }
            case SMALLULONG: {
                this._reading(1);
                return this._chunkReading.readUInt8(this._chunkOffset);
            }
            case ULONG: {
                this._reading(8);
                const v = readUInt64BE(this._chunkReading, this._chunkOffset);
                const i = Number(v);
                if (i <= Number.MAX_SAFE_INTEGER) {
                    return i;
                } else if (unsafe64) {
                    return v;
                }
                throw ErrMsg(EC.DECODE_UNSAFE_INT_VAL, this.bytesConsumed, 'ulong', v);
            }
            default:
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, c, ErrOpt(NULL, ULONG0, SMALLULONG, ULONG));
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?BlockCountCheck} scope
     * @return {?Timestamp}
     */
    readTimestamp(mandatory, scope) {
        const c = (scope && !scope(1)) ? NULL : this.readDataUInt8();
        switch(c){
            case NULL: {
                if (mandatory) throw ErrMsg(EC.DECODE_MISS_MAND_VAL, this.bytesConsumed, 'binary');
                return null;
            }
            case TIMESTAMP: {
                this._reading(8);
                const i = Number(readInt64BE(this._chunkReading, this._chunkOffset));
                if (i < Number.MIN_SAFE_INTEGER || Number.MAX_SAFE_INTEGER < i) {
                    throw ErrMsg(EC.DECODE_UNSAFE_INT_VAL, this.bytesConsumed, 'timestamp', i);
                }
                const v = new Date(i);
                v[JSYM_PRIM] = c;
                return v;
            }
            default: {
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, c, ErrOpt(NULL, TIMESTAMP));
            }
        }

    }

    /**
     * @param {boolean} mandatory
     * @param {?BlockCountCheck} scope
     * @param {number=} limit
     * @param {?BinaryString=} previous
     * @return {?BinaryString}
     */
    readBinaryString(mandatory, scope, limit, previous = null) {
        const value = /** @type {?Buffer} */ (this.readBinary(mandatory, scope));
        if (value === null) {
            return previous;
        }
        if (limit && value.length > limit) {
            throw ErrMsg(EC.DECODE_INV_BIN_VAL_LEN, this.bytesConsumed, value.length, limit);
        }
        return value.toString('hex');
    }

    /**
     * @param {boolean} mandatory
     * @param {?BlockCountCheck} scope
     * @return {?BinaryValue}
     * @final
     */
    readBinary(mandatory, scope) {
        const c = (scope && !scope(1)) ? NULL : this.readDataUInt8();
        switch(c){
            case NULL: {
                if (mandatory) throw ErrMsg(EC.DECODE_MISS_MAND_VAL, this.bytesConsumed, 'binary');
                return null;
            }
            case BIN8: {
                return this.readDataBlob(this.readDataUInt8());
            }
            case BIN32: {
                return this.readDataBlob(this.readDataUInt32());
            }
            default: {
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, this.bytesConsumed, c, ErrOpt(BIN8, BIN32));
            }
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?BlockCountCheck} scope
     * @return {?StringValue}
     * @final
     */
    readString(mandatory, scope) {
        const c = (scope && !scope(1)) ? NULL : this.readDataUInt8();
        switch(c){
            case NULL: {
                if (mandatory) throw ErrMsg(EC.DECODE_MISS_MAND_VAL, this.bytesConsumed, 'string');
                return null;
            }
            case STR8: {
                return this.readDataString(this.readDataUInt8());
            }
            case STR32: {
                return this.readDataString(this.readDataUInt32());
            }
            default: {
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, c, ErrOpt(STR8, STR32));
            }
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?BlockCountCheck} scope
     * @return {?SymbolValue}
     * @final
     */
    readSymbol(mandatory, scope) {
        const c = (scope && !scope(1)) ? NULL : this.readDataUInt8();
        switch(c){
            case NULL: {
                if (mandatory) throw ErrMsg(EC.DECODE_MISS_MAND_VAL, this.bytesConsumed, 'symbol');
                return null;
            }
            case SYM8: {
                return this.readDataASCII(this.readDataUInt8());
            }
            case SYM32: {
                return this.readDataASCII(this.readDataUInt32());
            }
            default: {
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, c, ErrOpt(SYM8, SYM32));
            }
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?BlockCountCheck} scope
     * @return {?SymbolArray}
     * @final
     */
    readSymbols(mandatory, scope) {
        let c = (scope && !scope(1)) ? NULL : this.readDataUInt8();     // field not in scope, handle like NULL
        let inside;
        switch(c) {
            case NULL: {
                if (mandatory) throw ErrMsg(EC.DECODE_MISS_MAND_VAL, this.bytesConsumed, 'symbols');
                return null;
            }
            case SYM8: {
                return [ this.readDataASCII(this.readDataUInt8()) ];
            }
            case SYM32: {
                return [ this.readDataASCII(this.readDataUInt32()) ];
            }
            case ARRAY8: {
                inside = this._readBlockSizeCountUInt8();
                break;
            }
            case ARRAY32: {
                inside = this._readBlockSizeCountUInt32();
                break;
            }
            default: {
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, c, ErrOpt(NULL, MAP8, MAP32));
            }
        }

        const v = [];
        v[JSYM_PRIM] = c;

        c = this.readDataUInt8();
        if (c === DESCRIPTOR) {
            v[JSYM_DESC_ITEM] = this.readDescriptorValue();
            c = this.readDataUInt8();
        }
        v[JSYM_PRIM_ITEM] = c;

        switch (c) {
            case SYM8: {
                while (inside(1)) v.push(this.readDataASCII(this.readDataUInt8()));
                return v;
            }
            case SYM32: {
                while (inside(1)) v.push(this.readDataASCII(this.readDataUInt32()));
                return v;
            }
            default: {
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, c, ErrOpt(SYM8, SYM32));
            }
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?BlockCountCheck} scope
     * @return {?Fields}
     * @final
     */
    readFields(mandatory, scope) {
        const c = (scope && !scope(1)) ? NULL : this.readDataUInt8();
        let inside;
        switch(c) {
            case NULL: {
                if (mandatory) throw ErrMsg(EC.DECODE_MISS_MAND_VAL, this.bytesConsumed, 'fields');
                return null;
            }
            case MAP8: {
                inside = this._readBlockSizeCountUInt8();
                break;
            }
            case MAP32: {
                inside = this._readBlockSizeCountUInt32();
                break;
            }
            default: {
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, this.bytesConsumed, c, ErrOpt(NULL, MAP8, MAP32));
            }
        }

        const v = new Map();
        while (inside(2)) v.set(this.readSymbol(true, null), this._valueAny(null));
        return v;
    }

    /**
     * @param {boolean} mandatory
     * @param {BlockCountCheck=} scope
     * @param {function():*} readKey
     * @param {function():*} readValue
     * @return {?Map}
     */
    readAnyMap(mandatory, scope, readKey, readValue) {
        const c = (scope && !scope(1)) ? NULL : this.readDataUInt8();
        let inside;
        switch(c) {
            case NULL: {
                if (mandatory) throw ErrMsg(EC.DECODE_MISS_MAND_VAL, this.bytesConsumed, 'fields');
                return null;
            }
            case MAP8: {
                inside = this._readBlockSizeCountUInt8();
                break;
            }
            case MAP32: {
                inside = this._readBlockSizeCountUInt32();
                break;
            }
            default: {
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, c, ErrOpt(NULL, MAP8, MAP32));
            }
        }

        const v = new Map();
        while (inside(2)) v.set(readKey(), readValue());
        return v;
    }

    /**
     * @param {boolean} mandatory
     * @param {BlockCountCheck=} scope
     * @param {function():*} readKey
     * @param {function():*} readValue
     * @return {?Object}
     */
    readObjMap(mandatory, scope, readKey, readValue) {
        const c = (scope && !scope(1)) ? NULL : this.readDataUInt8();
        let inside;
        switch(c) {
            case NULL: {
                if (mandatory) throw ErrMsg(EC.DECODE_MISS_MAND_VAL, this.bytesConsumed, 'properties');
                return null;
            }
            case MAP8: {
                inside = this._readBlockSizeCountUInt8();
                break;
            }
            case MAP32: {
                inside = this._readBlockSizeCountUInt32();
                break;
            }
            default: {
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, c, ErrOpt(NULL, MAP8, MAP32));
            }
        }

        const v = {};
        while (inside(2)) v[readKey()] = readValue();
        return v;
    }

    /**
     * @param {boolean} mandatory
     * @param {?BlockCountCheck} scope
     * @param {CompositeFactory} factory
     * @param {function} expected
     * @param {*} previous
     * @return {*}
     */
    readComposite(mandatory, scope, factory, expected, previous = null) {
        let c = (scope && !scope(1)) ? NULL : this.readDataUInt8();
        switch (c) {
            case DESCRIPTOR:
                break;
            case NULL:
                if (mandatory) throw ErrMsg(EC.DECODE_MISS_MAND_VAL, this.bytesConsumed, DESCRIPTOR);
                return previous;
            default:
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, this.bytesConsumed, c, ErrOpt(DESCRIPTOR, NULL));
        }

        const desc = this.readDescriptorValue(false, false);
        const comp = factory(desc);
        if (comp === null) throw ErrMsg(EC.DECODE_COMP_TYPE_UNKNOWN, this.bytesConsumed, desc);
        if (!(comp instanceof expected)) throw ErrMsg(EC.DECODE_COMP_TYPE_UNEXPECTED, this.bytesConsumed, comp.constructor.name, expected.name);

        return this.readCompositeValue(comp);
    }

    /**
     * @param {!Composite} comp
     * @return {!Composite}
     */
    readCompositeValue(comp) {
        const c = this.readDataUInt8();
        let inside;
        switch (c) {
            case LIST0:
                return comp;
            case LIST8:
                inside = this._readBlockSizeCountUInt8();
                break;
            case LIST32:
                inside = this._readBlockSizeCountUInt32();
                break;
            default:
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, this.bytesConsumed, c, ErrOpt(LIST0, LIST8, LIST32));
        }
        comp.decodeComp(this, inside);
        if (inside()) throw ErrMsg(EC.DECODE_COMP_BYTES_MISMATCH, comp.constructor.name);
        return comp;
    }

    /**
     * @param {!boolean} wrapped
     * @param {!boolean} unsafe64
     * @return {Descriptor}
     */
    readDescriptor(wrapped = this._useWrappedValues, unsafe64 = this._useUnsafeIntegers) {
        this.skipByte(DESCRIPTOR);
        return this.readDescriptorValue(wrapped, unsafe64);
    }

    /**
     * @param {!boolean} wrapped
     * @param {!boolean} unsafe64
     * @return {Descriptor}
     */
    readDescriptorValue(wrapped = this._useWrappedValues, unsafe64 = this._useUnsafeIntegers) {
        const c = this.readDataUInt8();
        switch(c) {
            case SMALLULONG: {
                this._reading(1);
                const v = this._chunkReading.readUInt8(this._chunkOffset);
                return wrapped ? _wrapData(c, v, Number) : v;
            }
            case ULONG: {
                this._reading(8);
                const v = readUInt64BE(this._chunkReading, this._chunkOffset);
                const i = Number(v);
                if (i <= Number.MAX_SAFE_INTEGER) {
                    return wrapped ? _wrapData(c, i, Number) : i;
                } else if (unsafe64) {
                    return wrapped ? _wrapData(c, v, String) : v;
                }
                throw ErrMsg(EC.DECODE_UNSAFE_INT_VAL, this.bytesConsumed, 'ulong', v);
            }
            case ULONG0: {
                return wrapped ? _wrapData(c, 0, Number) : 0;
            }
            case SYM8: {
                const v = this.readDataASCII(this.readDataUInt8());
                return wrapped ? _wrapData(c, v, String) : v;
            }
            case SYM32: {
                const v = this.readDataASCII(this.readDataUInt32());
                return wrapped ? _wrapData(c, v, String) : v;
            }
            case DESCRIPTOR: {
                const d = this.readDescriptorValue(wrapped, unsafe64);
                const v = this.readDescriptorValue(wrapped, unsafe64);
                if (v && typeof v === 'object') v[JSYM_DESC] = d;
                return v;
            }
            default: {
                throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, this.bytesConsumed, c, ErrOpt(ULONG, SMALLULONG, SYM8, SYM32, DESCRIPTOR));
            }
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?BlockCountCheck} scope
     * @param {?Set<FormatCode>} filter
     * @return {?*}
     */
    readValue(mandatory, scope, filter) {
        let c = (scope && !scope(1)) ? NULL : this.readDataUInt8();
        if (filter && !filter.has(c))
            throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, this.bytesConsumed, c, ErrOptSet(filter));
        if (mandatory && c === NULL)
            throw ErrMsg(EC.DECODE_MISS_MAND_VAL, this.bytesConsumed, 'value');
        return this._valueAny(c);
    }

    /**
     * @param {?FormatCode} code
     * @return {*}
     * @private
     */
    _valueAny(code) {
        const c = (code === null) ? this.readDataUInt8() : code;
        switch (c) {
            case NULL: {
                return null;
            }
            case TRUE: {
                return true;
            }
            case FALSE: {
                return false;
            }
            case BOOL: {
                this._reading(1);
                let value = this._chunkReading.readUInt8(this._chunkOffset);
                switch (value) {
                    case VBOOL_TRUE:
                        return this._useWrappedValues ? _wrapData(c, true, Boolean) : true;
                    case VBOOL_FALSE:
                        return this._useWrappedValues ? _wrapData(c, false, Boolean) : false;
                }
                throw ErrMsg(EC.DECODE_VAL_NOT_EXPECTED, this.bytesConsumed, value, ErrOpt(VBOOL_TRUE, VBOOL_FALSE));
            }
            case UINT0: case ULONG0: {
                return this._useWrappedValues ? _wrapData(c, 0, Number) : 0;
            }
            case UBYTE: case SMALLUINT: case SMALLULONG: {
                this._reading(1);
                const v = this._chunkReading.readUInt8(this._chunkOffset);
                return this._useWrappedValues ? _wrapData(c, v, Number) : v;
            }
            case USHORT: {
                this._reading(2);
                const v = this._chunkReading.readUInt16BE(this._chunkOffset);
                return this._useWrappedValues ? _wrapData(c, v, Number) : v;
            }
            case UINT: {
                this._reading(4);
                const v = this._chunkReading.readUInt32BE(this._chunkOffset);
                return this._useWrappedValues ? _wrapData(c, v, Number) : v;
            }
            case ULONG: {
                this._reading(8);
                const v = readUInt64BE(this._chunkReading, this._chunkOffset);
                const i = Number(v);
                if (i <= Number.MAX_SAFE_INTEGER) {
                    return this._useWrappedValues ? _wrapData(c, i, Number) : i;
                } else if (this._useUnsafeIntegers) {
                    return this._useWrappedValues ? _wrapData(c, v, String) : v;
                }
                throw ErrMsg(EC.DECODE_UNSAFE_INT_VAL, this.bytesConsumed, 'ulong', v);
            }
            case BYTE: case SMALLINT: case SMALLLONG: {
                this._reading(1);
                const v = this._chunkReading.readInt8(this._chunkOffset);
                return this._useWrappedValues ? _wrapData(c, v, Number) : v;
            }
            case SHORT: {
                this._reading(2);
                const v = this._chunkReading.readInt16BE(this._chunkOffset);
                return this._useWrappedValues ? _wrapData(c, v, Number) : v;
            }
            case INT: {
                this._reading(4);
                const v = this._chunkReading.readInt32BE(this._chunkOffset);
                return this._useWrappedValues ? _wrapData(c, v, Number) : v;
            }
            case LONG: {
                this._reading(8);
                const v = readInt64BE(this._chunkReading, this._chunkOffset);
                const i = Number(v);
                if (Number.MIN_SAFE_INTEGER <= i && i <= Number.MAX_SAFE_INTEGER) {
                    return this._useWrappedValues ? _wrapData(c, i, Number) : i;
                } else if (this._useUnsafeIntegers) {
                    return this._useWrappedValues ? _wrapData(c, v, String) : v;
                }
                throw ErrMsg(EC.DECODE_UNSAFE_INT_VAL, this.bytesConsumed, 'long', v);
            }
            case FLOAT: {
                this._reading(4);
                const v = this._chunkReading.readFloatBE(this._chunkOffset);
                return this._useWrappedValues ? _wrapData(c, v, Number) : v;
            }
            case DOUBLE: {
                this._reading(8);
                const v = this._chunkReading.readDoubleBE(this._chunkOffset);
                return this._useWrappedValues ? _wrapData(c, v, Number) : v;
            }
            case DEC32: {
                const v = this.readDataBlob(4);
                v[JSYM_PRIM] = c;
                return v;
            }
            case DEC64: {
                const v = this.readDataBlob(8);
                v[JSYM_PRIM] = c;
                return v;
            }
            case DEC128: {
                const v = this.readDataBlob(16);
                v[JSYM_PRIM] = c;
                return v;
            }
            case CHAR: {
                this._reading(4);
                const v = String.fromCharCode(this._chunkReading.readUInt32BE(this._chunkOffset));
                return this._useWrappedValues ? _wrapData(c, v, String) : v;
            }
            case TIMESTAMP: {
                this._reading(8);
                const i = Number(readInt64BE(this._chunkReading, this._chunkOffset));
                if (i < Number.MIN_SAFE_INTEGER || Number.MAX_SAFE_INTEGER < i) {
                    throw ErrMsg(EC.DECODE_UNSAFE_INT_VAL, this.bytesConsumed, 'timestamp', i);
                }
                const v = new Date(i);
                v[JSYM_PRIM] = c;
                return v;
            }
            case UUID: {
                const v = this.readDataBlob(16);
                v[JSYM_PRIM] = c;
                return v;
            }
            case BIN8: {
                this._reading(1);
                const v = this.readDataBlob(this._chunkReading.readUInt8(this._chunkOffset));
                v[JSYM_PRIM] = c;
                return v;
            }
            case BIN32: {
                this._reading(4);
                const v = this.readDataBlob(this._chunkReading.readUInt32BE(this._chunkOffset));
                v[JSYM_PRIM] = c;
                return v;
            }
            case STR8: {
                const v = this.readDataString(this.readDataUInt8());
                return this._useWrappedValues ? _wrapData(c, v, String) : v;
            }
            case STR32: {
                const v = this.readDataString(this.readDataUInt32());
                return this._useWrappedValues ? _wrapData(c, v, String) : v;
            }
            case SYM8: {
                const v = this.readDataASCII(this.readDataUInt8());
                return this._useWrappedValues ? _wrapData(c, v, String) : v;
            }
            case SYM32: {
                const v = this.readDataASCII(this.readDataUInt32());
                return this._useWrappedValues ? _wrapData(c, v, String) : v;
            }
            case LIST0: {
                const v = [];
                v[JSYM_PRIM] = c;
                return v;
            }
            case LIST8: case LIST32: {
                const inside = (c === LIST8) ? this._readBlockSizeCountUInt8() : this._readBlockSizeCountUInt32();
                const v = [];
                v[JSYM_PRIM] = c;
                while (inside(1)) v.push(this._valueAny(null));
                return v;
            }
            case MAP8: case MAP32: {
                const inside = (c === MAP8) ? this._readBlockSizeCountUInt8() : this._readBlockSizeCountUInt32();
                const v = new Map();
                v[JSYM_PRIM] = c;
                while (inside(2)) v.set(this._valueAny(null), this._valueAny(null));
                return v;
            }
            case ARRAY8: case ARRAY32: {
                const inside = (c === ARRAY8) ? this._readBlockSizeCountUInt8() : this._readBlockSizeCountUInt32();
                const v = [];
                v[JSYM_PRIM] = c;
                let type = this.readDataUInt8();
                if (type === DESCRIPTOR) {
                    v[JSYM_DESC_ITEM] = this.readDescriptorValue();
                    type = this.readDataUInt8();
                }
                v[JSYM_PRIM_ITEM] = type;
                while (inside(1)) v.push(this._valueAny(type));
                return v;
            }
            case DESCRIPTOR: {
                const d = this.readDescriptorValue();
                const v = this._valueAny(null);
                if (v && typeof v === 'object') v[JSYM_DESC] = d;
                return v;
            }
            default:
                throw ErrMsg(EC.DECODE_CODE_UNKNOWN, this.bytesConsumed, c);
        }
    }

}

/**
 * @private
 */
class FrameCache {

    constructor() {

        /**
         * @type {Map<!string, Frame>}
         * @private
         */
        this._data = new Map();

    }

    /**
     * @param {!ChannelHandle} channel
     * @param {?LinkHandle} handle
     * @param {!Frame} frame
     */
    push(channel, handle, frame) {
        const key = '' + channel + '-' + handle;
        this._data.set(key, frame);
    }

    /**
     * @param {!ChannelHandle} channel
     * @param {?LinkHandle} handle
     * @return {?Frame}
     */
    pop(channel, handle) {
        const key = '' + channel + '-' + handle;
        const frame = this._data.get(key);
        if (frame) {
            this._data.delete(key);
            return frame;
        }
        return null;
    }

}

/**
 * @param {number} kind
 * @param {*} value
 * @param {*} type
 * @return {*}
 * @private
 */
function _wrapData(kind, value, type) {
    const v = new type(value);
    v[JSYM_PRIM] = kind;
    return v;
}

const VBOOL_TRUE = constants.VALUE.PRIMITIVE.BOOLEAN.TRUE;
const VBOOL_FALSE = constants.VALUE.PRIMITIVE.BOOLEAN.FALSE;

const NULL = SIMPLE.NULL;
const TRUE = SIMPLE.TRUE;
const FALSE = SIMPLE.FALSE;
const UINT0 = SIMPLE.UINT0;
const ULONG0 = SIMPLE.ULONG0;
const LIST0 = COMPLEX.LIST0;

const UBYTE = SIMPLE.UBYTE;
const BYTE = SIMPLE.BYTE;
const SMALLUINT = SIMPLE.SMALLUINT;
const SMALLULONG = SIMPLE.SMALLULONG;
const SMALLINT = SIMPLE.SMALLINT;
const SMALLLONG = SIMPLE.SMALLLONG;
const BOOL = SIMPLE.BOOL;

const USHORT = SIMPLE.USHORT;
const SHORT = SIMPLE.SHORT;

const UINT = SIMPLE.UINT;
const INT = SIMPLE.INT;

const FLOAT = SIMPLE.FLOAT;
const CHAR = SIMPLE.CHAR;
const DEC32 = SIMPLE.DEC32;

const ULONG = SIMPLE.ULONG;
const LONG = SIMPLE.LONG;
const DOUBLE = SIMPLE.DOUBLE;
const TIMESTAMP = SIMPLE.TIMESTAMP;
const DEC64 = SIMPLE.DEC64;

const DEC128 = SIMPLE.DEC128;
const UUID = SIMPLE.UUID;

const BIN8 = SIMPLE.BIN8;
const STR8 = SIMPLE.STR8;
const SYM8 = SIMPLE.SYM8;

const BIN32 = SIMPLE.BIN32;
const STR32 = SIMPLE.STR32;
const SYM32 = SIMPLE.SYM32;

const LIST8 = COMPLEX.LIST8;
const MAP8 = COMPLEX.MAP8;

const LIST32 = COMPLEX.LIST32;
const MAP32 = COMPLEX.MAP32;

const ARRAY8 = COMPLEX.ARRAY8;

const ARRAY32 = COMPLEX.ARRAY32;

module.exports = {
    Decoder : Decoder
};

