'use strict';

const { EC, ErrMsg, ErrOpt } = require('../errors');
const { writeUInt64BE, writeInt64BE } = require('../tools/bignum');

const constants = require('./constants');
const PROTOCOL = constants.PROTOCOL;
const MINMAX = constants.FRAME.SIZE.MINMAX;
const HEADSIZE = constants.FRAME.SIZE.HEADER;
const SIMPLE = constants.CONSTRUCT.PRIMITIVE.SIMPLE;
const COMPLEX = constants.CONSTRUCT.PRIMITIVE.COMPLEX;
const DESCRIPTOR = constants.CONSTRUCT.DESCRIPTOR;
const BOOLS = new Set([SIMPLE.BOOL, SIMPLE.TRUE, SIMPLE.FALSE]);
const UBYTES = new Set([SIMPLE.UBYTE]);
const SHORTS = new Set([SIMPLE.USHORT]);
const UINTS = new Set([SIMPLE.UINT0, SIMPLE.SMALLUINT, SIMPLE.UINT]);
const ULONGS = new Set([SIMPLE.ULONG0, SIMPLE.SMALLULONG, SIMPLE.ULONG]);
const SYMBOLS = new Set([SIMPLE.SYM8, SIMPLE.SYM32]);
const STRINGS = new Set([SIMPLE.STR8, SIMPLE.STR32]);
const VBOOL_TRUE = constants.VALUE.PRIMITIVE.BOOLEAN.TRUE;
const VBOOL_FALSE = constants.VALUE.PRIMITIVE.BOOLEAN.FALSE;
const JSYM_DESCRIPTOR = constants.RUNTIME.SYMBOL.DESCRIPTOR;
const JSYM_PRIMITIVE = constants.RUNTIME.SYMBOL.PRIMITIVE;
const JSYM_PRIM_ITEM = constants.RUNTIME.SYMBOL.PRIM_ITEM;
const JSYM_PRIM_KEY = constants.RUNTIME.SYMBOL.PRIM_KEY;
const JSYM_PRIM_VALUE = constants.RUNTIME.SYMBOL.PRIM_VALUE;


/**
 * @callback ChunkAllocate
 * @param {number=} minSize
 * @return {!Buffer}
 */

/**
 * @callback ChunkDispatch
 * @param {!Buffer} useChunk
 * @param {?Buffer} rawChunk
 */

/**
 * @callback BlockSizer
 */

/**
 * @callback BlockCountSizer
 * @param {number} count
 */

/**
 * @callback BoolWriter
 * @param {boolean} value
 */

/**
 * @param {*=} result
 * @return {*}
 * @private
 */
function nop(result) { return result; }

/**
 * @private
 */
class Encoder {

    /**
     * @param {!StreamParameters} options
     * @param {!ChunkAllocate} allocate
     * @param {!ChunkDispatch} dispatch
     */
    constructor(options, allocate, dispatch) {

        /**
         * @type {FrameSize}
         */
        this.maxFrameSize = MINMAX;

        /**
         * @type {number}
         */
        this.statFrameCount = 0;

        /**
         * @type {number}
         */
        this.statChunkCount = 0;

        /**
         * @const {number}
         * @private
         */
        this._payloadCopyLimit = options.ostreamPayloadCopyLimit;

        /**
         * @type {?Buffer}
         * @private
         */
        this._chunkWriting = null;

        /**
         * @type {number}
         * @private
         */
        this._chunkOffset = 0;

        /**
         * @type {number}
         * @private
         */
        this._chunkProduced = 0;

        /**
         * @type {number}
         * @private
         */
        this._chunkRemaining = 0;

        /**
         * @type {?Frame}
         * @private
         */
        this._frameWriting = null;

        /**
         * @type {?Buffer}
         * @private
         */
        this._frameStartChunk = null;

        /**
         * @type {number}
         * @private
         */
        this._frameStartOffset = 0;

        /**
         * @type {number}
         * @private
         */
        this._frameProduced = 0;

        /**
         * @type {number}
         * @private
         */
        this._frameRemaining = 0;

        /**
         * @type {boolean}
         * @private
         */
        this._payloadScope = false;

        /**
         * @type {number}
         * @private
         */
        this._payloadProduced = 0;

        /**
         * @type {!ChunkAllocate}
         * @private
         */
        this._chunkAllocate = allocate;

        /**
         * @type {!ChunkDispatch}
         * @private
         */
        this._chunkDispatch = dispatch;

        /**
         * @type {!Array<{useChunk: !Buffer, rawChunk: ?Buffer}>}
         * @private
         */
        this._queueDispatch = [];

        /**
         * @type {number}
         * @private
         */
        this._flushLocks = 0;
    }

    /**
     * @param {!FrameLibrary} library
     * @final
     */
    init(library) {
        this._writeProtocol(library);
        this.push = this._writeFrame;
    }

    /**
     *
     */
    stop() {
        this.push = () => nop(false);
        this.flush = nop;
    }

    /**
     * @param {!Frame} frame
     * @return {boolean} - dirty
     */
    push(frame) {
        // dynamic override by writeFrame after protocol initialized
    }

    /**
     * @param {number} length
     */
    flush(length = 0) {
        if (this._chunkProduced) {
            ++this.statChunkCount;
            const useChunk = this._chunkRemaining ? this._chunkWriting.slice(0, this._chunkProduced) : this._chunkWriting;
            const rawChunk = this._chunkWriting;
            if (this._flushLocks > 0)
                this._queueDispatch.push({useChunk: useChunk, rawChunk: rawChunk});
            else
                this._chunkDispatch(useChunk, rawChunk);
        } else if (length === 0) {
            return;
        }
        this._chunkWriting = this._chunkAllocate(length);
        this._chunkProduced = 0;
        this._chunkRemaining = this._chunkWriting.length;
        this._chunkOffset = 0;
    }

    /**
     * @param {boolean} active
     */
    scopePayload(active) {
        this._payloadScope = active;
    }

    /**
     * @param {number} length
     * @private
     */
    _writing(length) {
        if (length > this._frameRemaining) this._splitFrame();
        if (length > this._chunkRemaining) this.flush(length);
        this._chunkOffset = this._chunkProduced;
        this._chunkProduced += length;
        this._chunkRemaining -= length;
        this._frameProduced += length;
        this._frameRemaining -= length;
        if (this._payloadScope) this._payloadProduced += length;
    }

    /**
     * @param {!FrameLibrary} library
     * @private
     */
    _writeProtocol(library) {
        this._frameRemaining = 8;
        this.writeDataASCII(PROTOCOL.NAME);
        this.writeDataUInt8(library.PROTOCOL);
        this.writeDataUInt8(PROTOCOL.VERSION.MAJOR);
        this.writeDataUInt8(PROTOCOL.VERSION.MINOR);
        this.writeDataUInt8(PROTOCOL.VERSION.REVISION);
    }

    /**
     * @param {!Frame} frame
     * @return {boolean} - dirty
     * @private
     */
    _writeFrame(frame) {
        this._payloadScope = false;
        this._payloadProduced = 0;
        this._frameWriting = frame;
        this._setupFrame(frame);
        frame.encodeData(this);
        this._closeFrame();
        frame.encodeDone(this);
        this._frameWriting = null;
        return this._chunkProduced > 0;
    }

    /**
     * @private
     */
    _splitFrame() {
        this._payloadScope = false;
        const frame = this._frameWriting;
        this._flushLock();
        this._closeFrame();
        this._setupFrame(frame);
        frame.encodeMore(this);
        this._flushUnlock();
        this._payloadScope = true;
    }

    /**
     * @private
     */
    _setupFrame(frame) {
        ++this.statFrameCount;
        this._frameProduced = 0;
        this._frameRemaining = this.maxFrameSize;
        this._writing(HEADSIZE);
        this._flushLock();
        const chunk = this._frameStartChunk = this._chunkWriting;
        const offset = this._frameStartOffset = this._chunkOffset;
        chunk.writeUInt8(2, offset + 4);
        chunk.writeUInt8(frame.type, offset + 5);
        chunk.writeUInt16BE(frame.channel, offset + 6);
    }

    /**
     * @private
     */
    _closeFrame() {
        this._frameStartChunk.writeUInt32BE(this._frameProduced, this._frameStartOffset);
        this._flushUnlock();
    }

    /**
     * @private
     */
    _flushLock() {
        ++this._flushLocks;
    }

    /**
     * @private
     */
    _flushUnlock() {
        if (this._flushLocks === 0) {
            throw ErrMsg(EC.ENCODE_BLOCK_CONTROL_ERROR, this._frameProduced, 0, 1);
        }
        if (--this._flushLocks === 0) {
            for (const item of this._queueDispatch) this._chunkDispatch(item.useChunk, item.rawChunk);
            this._queueDispatch.length = 0;
        }
    }

    /**
     * @return {!BlockSizer}
     * @private
     */
    _writeBlockSize32() {
        this._writing(4);
        const start = this._payloadScope ? this._payloadProduced : this._frameProduced;
        const chunk = this._chunkWriting;
        const offset = this._chunkOffset;

        return () => {
            const size = ( this._payloadScope ? this._payloadProduced : this._frameProduced ) - start;
            chunk.writeUInt32BE(size, offset);
        };
    }

    /**
     * @return {!BlockCountSizer}
     * @private
     */
    _writeBlockSizeCountUInt8() {
        this._writing(2);
        const start = ( this._payloadScope ? this._payloadProduced : this._frameProduced ) - 1;
        const chunk = this._chunkWriting;
        const offset = this._chunkOffset;

        return (count) => {
            const size = ( this._payloadScope ? this._payloadProduced : this._frameProduced ) - start;
            chunk.writeUInt8(size, offset);
            chunk.writeUInt8(count, offset + 1);
        };
    }

    /**
     * @return {!BlockCountSizer}
     * @private
     */
    _writeBlockSizeCountUInt32() {
        this._writing(8);
        const start = ( this._payloadScope ? this._payloadProduced : this._frameProduced ) - 4;
        const chunk = this._chunkWriting;
        const offset = this._chunkOffset;

        return (count) => {
            const size = ( this._payloadScope ? this._payloadProduced : this._frameProduced ) - start;
            chunk.writeUInt32BE(size, offset);
            chunk.writeUInt32BE(count, offset + 4);
        };
    }

    /**
     * @param {number} value
     * @final
     */
    writeDataUInt8(value) {
        this._writing(1);
        this._chunkWriting.writeUInt8(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     * @final
     */
    writeDataUInt32(value) {
        this._writing(4);
        this._chunkWriting.writeUInt32BE(value, this._chunkOffset);
    }

    /**
     * @param {string} value
     * @final
     */
    writeDataASCII(value) {
        const len = Buffer.byteLength(value, 'ascii');
        this._writing(len);
        this._chunkWriting.write(value, this._chunkOffset, len, 'ascii');
    }

    /**
     * @param {!Buffer} value - BIN8, BIN32, STR32, SYM32
     * @final
     */
    writeDataBlob(value) {
        let len = value.length, off = 0, delta = 0, val = null;
        while (len) {
            if (this._frameRemaining === 0)
                this._splitFrame();
            delta = Math.min(len, this._frameRemaining);
            if (delta > this._payloadCopyLimit) {
                this.flush();
                val = (delta === value.length) ? value : value.slice(off, off + delta);
                if (this._flushLocks)
                    this._queueDispatch.push({useChunk: val, rawChunk: null});
                else
                    this._chunkDispatch(val, null);
                this._frameProduced += delta;
                this._frameRemaining -= delta;
                if (this._payloadScope) this._payloadProduced += delta;
            } else {
                this._writing(delta);
                value.copy(this._chunkWriting, this._chunkOffset, off, off + delta);
            }
            off += delta;
            len -= delta;
        }
    }

    /**
     * @param {boolean} mandatory
     * @return {!BoolWriter}
     */
    writeBoolLate(mandatory) {
        this._writing(1);
        const chunk = this._chunkWriting;
        const offset = this._chunkOffset;

        return (value) => {
            if (value === NULL) {
                if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'bool');
                chunk.writeUInt8(NULL, offset);
            } else if (value) {
                chunk.writeUInt8(TRUE, offset);
            } else {
                chunk.writeUInt8(FALSE, offset);
            }
        };
    }

    /**
     * @param {boolean} mandatory
     * @param {?boolean} value
     * @return {FormatCode}
     */
    writeBool(mandatory, value) {
        if (value === null) {
            if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'bool');
            return this.valueNull();
        } else if (typeof value === 'object') {
            return this.valueAnyRestricted(value, BOOLS);
        } else if (value) {
            return this.valueTrue();
        } else {
            return this.valueFalse();
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?number} value
     * @return {FormatCode}
     * @final
     */
    writeUByte(mandatory, value) {
        if (value === null) {
            if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'ubyte');
            return this.valueNull();
        } else if (typeof value === 'object') {
            return this.valueAnyRestricted(value, UBYTES);
        } else {
            return this.valueUByte(value);
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?number} value
     * @return {FormatCode}
     * @final
     */
    writeUShort(mandatory, value) {
        if (value === null) {
            if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'ushort');
            return this.valueNull();
        } else if (typeof value === 'object') {
            return this.valueAnyRestricted(value, SHORTS);
        } else {
            return this.valueUShort(value);
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?number} value
     * @return {FormatCode}
     * @final
     */
    writeUInt(mandatory, value) {
        if (value === null) {
            if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'uint');
            return this.valueNull();
        } else if (typeof value === 'object') {
            return this.valueAnyRestricted(value, UINTS);
        } else if (value > 255) {
            return this.valueUInt(value);
        } else if (value === 0) {
            return this.valueUInt0();
        } else {
            return this.valueSmallUInt(value);
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?(number|string)} value
     * @return {FormatCode}
     * @final
     */
    writeULong(mandatory, value) {
        if (value === null) {
            if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'ulong');
            return this.valueNull();
        } else if (typeof value === 'object') {
            return this.valueAnyRestricted(value, ULONGS);
        } else if (value === 0) {
            return this.valueULong0();
        } else if (typeof value === 'string' || value > 255) {
            return this.valueULong(value);
        } else {
            return this.valueSmallULong(value);
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?Timestamp} value
     * @return {FormatCode}
     * @final
     */
    writeTimestamp(mandatory, value) {
        if (value === null) {
            if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'timestamp');
            return this.valueNull();
        } else {
            return this.valueTimestamp(/** @type{!Date} */ (value));
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?BinaryString} value
     * @param {number=} limit
     * @return {FormatCode}
     * @final
     */
    writeBinaryString(mandatory, value, limit) {
        if (value === null) {
            if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'binary');
            this.valueNull();
        }
        // noinspection JSCheckFunctionSignatures
        const v = Buffer.from(value, 'hex');
        if (limit && v.length > limit) {
            throw ErrMsg(EC.ENCODE_INV_BIN_VAL_LEN, this._frameProduced, v.length, limit);
        }
        return this.valueBinary(/** @type{!Buffer} */ (v));
    }

    /**
     * @param {boolean} mandatory
     * @param {?BinaryValue} value
     * @return {FormatCode}
     * @final
     */
    writeBinary(mandatory, value) {
        if (value === null) {
            if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'binary');
            return this.valueNull();
        } else {
            return this.valueBinary(/** @type{!Buffer} */ (value));
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?StringValue} value
     * @return {FormatCode}
     * @final
     */
    writeString(mandatory, value) {
        if (value === null) {
            if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'string');
            return this.valueNull();
        } else if (typeof value === 'object') {
            return this.valueAnyRestricted(value, STRINGS);
        } else {
            return this.valueString(value);
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?SymbolValue} value
     * @return {FormatCode}
     * @final
     */
    writeSymbol(mandatory, value) {
        if (value === null) {
            if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'symbol');
            return this.valueNull();
        } else if (typeof value === 'object') {
            return this.valueAnyRestricted(value, SYMBOLS);
        } else {
            return this.valueSymbol(value);
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {SymbolArray} value
     * @final
     */
    writeSymbols(mandatory, value) {
        if (value === null) {
            if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'symbols');
            this.valueNull();
        } else if (value.length === 1) {
            this.writeSymbol(true, value[0]);               // single value can be sent without array
        } else {
            let len = 0, max = 0;
            for (const sym of value) {
                const sz = sym ? Buffer.byteLength(sym, 'ascii') : 0;
                len += sz; max = Math.max(max, sz);
            }
            if (max > 255) {
                this.valueArray32(value, SYM32);
            } else {
                // noinspection JSUnresolvedVariable
                len += value.length + 2;                    // try one length byte per item + array type + array count
                if (len > 255) {
                    this.valueArray32(value, SYM8);
                } else {
                    this.valueArray8(value, SYM8);
                }
            }
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {Map<string,*>} value
     */
    writeFields(mandatory, value) {
        if (value === null) {
            if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'fields');
            this.valueNull();
        } else {
            this.writeDataUInt8(MAP32);
            const sizer = this._writeBlockSizeCountUInt32();
            for (const [key, val] of value.entries()) {
               this.writeSymbol(true, key);
               this.valueAny(val);
            }
            sizer(value.size * 2);
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {Map} value
     * @param {function(*)} encKey
     * @param {function(*)} encVal
     */
    writeAnyMap(mandatory, value, encKey, encVal) {
        if (value === null) {
            if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'fields');
            this.valueNull();
        } else {
            this.valueAnyMap(value, encKey, encVal);
        }
    }

    /**
     * @param {Map} value
     * @param {function(*)} encKey
     * @param {function(*)} encVal
     */
    valueAnyMap(value, encKey, encVal) {
        this.writeDataUInt8(MAP32);
        const sizer = this._writeBlockSizeCountUInt32();
        for (const [key, val] of value.entries()) {
            encKey(key);
            encVal(val);
        }
        sizer(value.size * 2);
    }

    /**
     * @param {?Object} value
     * @param {function(*)} encKey
     * @param {function(*)} encVal
     */
    valueObjMap(value, encKey, encVal) {
        this.writeDataUInt8(MAP32);
        const sizer = this._writeBlockSizeCountUInt32();
        const keys = Object.getOwnPropertyNames(value);
        for (const key of keys) {
            encKey(key);
            encVal(value[key]);
        }
        sizer(keys.length * 2);
    }

    /**
     * @param {boolean} mandatory
     * @param {?Composite} value
     */
    writeComposite(mandatory, value) {
        if (value === null) {
            if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'composite');
            this.valueNull();
        } else {
            this.valueComposite(/** @type {!Composite} */ (value));
        }
    }

    /**
     * @param {!Composite} value
     */
    valueComposite(value) {
        this.writeDescriptor(value.descriptor);
        const c = value.defineComp();
        switch (c) {
            case LIST0: {
                this.writeDataUInt8(LIST0);
                return;
            }
            case LIST8: {
                this.writeDataUInt8(LIST8);
                const sizer = this._writeBlockSizeCountUInt8();
                sizer(value.encodeComp(this));
                return;
            }
            case LIST32: {
                this.writeDataUInt8(LIST32);
                const sizer = this._writeBlockSizeCountUInt32();
                sizer(value.encodeComp(this));
                return;
            }
            default: {
                throw ErrMsg(EC.ENCODE_INV_COMP_TYPE, this._frameProduced, value.constructor.name, c, ErrOpt(LIST0|LIST8|LIST32));
            }
        }
    }

    /**
     * @param {boolean} mandatory
     * @param {?Set<FormatCode>} filter
     * @param {?*} value
     */
    writeValue(mandatory, filter, value) {
        if (value === null) {
            if (mandatory) throw ErrMsg(EC.ENCODE_MISS_MAND_VAL, this._frameProduced, 'value');
            this.valueNull();
        } else if (filter) {
            this.valueAnyRestricted(value, filter);
        } else {
            this.valueAny(value);
        }
    }

    /**
     * @param {?*} value
     * @param {?Set<FormatCode>} filter
     * @return {FormatCode}
     */
    valueAnyRestricted(value, filter) {
        const c = this.valueAny(value, filter);
        if (!filter.has(c)) throw ErrMsg(EC.ENCODE_VALUE_TYPE_MISMATCH, this._frameProduced, c, 'value');
        return c;
    }

    /**
     * @param {*|Object} value
     * @param {?Set<FormatCode>} preferred
     * @return {FormatCode}
     */
    valueAny(value, preferred = null) {
        switch (typeof value) {
            case 'object': {
                if (value === null) return this.valueNull();
                this.writeDescriptor(value[JSYM_DESCRIPTOR]);
                switch (value.constructor) {
                    case Boolean:
                        return this.valueBool(/**@type{boolean}*/(value.valueOf()));
                    case Date:
                        return this.valueTimestamp(value);
                    case String:
                        switch (value[JSYM_PRIMITIVE]) {
                            case SYM32:
                                return this.valueSymbol32(/**@type{string}*/(value.valueOf()));
                            case SYM8:
                                return this.valueSymbol8(/**@type{string}*/(value.valueOf()));
                            case STR32:
                                return this.valueString32(/**@type{string}*/(value.valueOf()));
                            case STR8:
                                return this.valueString8(/**@type{string}*/(value.valueOf()));
                            case ULONG:
                                return this.valueULong(/**@type{string}*/(value.valueOf()));
                            case CHAR:
                                return this.valueChar(/**@type{string}*/(value.valueOf()));
                            case undefined:
                                if (preferred) {
                                    const val = /**@type{string}*/(value.valueOf());
                                    const len = Buffer.byteLength(val);
                                    if (len > 255) {
                                        if (preferred.has(SYM32))
                                            return this.valueSymbol32(val, len);
                                        else
                                            return this.valueString32(val, len);
                                    } else {
                                        if (preferred.has(SYM8))
                                            return this.valueSymbol8(val, len);
                                        else
                                            return this.valueString8(val, len);
                                    }
                                } else {
                                    return this.valueString(/**@type{string}*/(value.valueOf()));
                                }
                        }
                        break;
                    case Number:
                        switch (value[JSYM_PRIMITIVE]) {
                            case SMALLUINT:
                                return this.valueSmallUInt(/**@type{number}*/(value.valueOf()));
                            case SMALLULONG:
                                return this.valueSmallULong(/**@type{number}*/(value.valueOf()));
                            case SMALLINT:
                                return this.valueSmallInt(/**@type{number}*/(value.valueOf()));
                            case SMALLLONG:
                                return this.valueSmallLong(/**@type{number}*/(value.valueOf()));
                            case ULONG:
                                return this.valueULong(/**@type{number}*/(value.valueOf()));
                            case UINT:
                                return this.valueUInt(/**@type{number}*/(value.valueOf()));
                            case USHORT:
                                return this.valueUShort(/**@type{number}*/(value.valueOf()));
                            case UBYTE:
                                return this.valueUByte(/**@type{number}*/(value.valueOf()));
                            case LONG:
                                return this.valueLong(/**@type{number}*/(value.valueOf()));
                            case INT:
                                return this.valueInt(/**@type{number}*/(value.valueOf()));
                            case SHORT:
                                return this.valueShort(/**@type{number}*/(value.valueOf()));
                            case BYTE:
                                return this.valueByte(/**@type{number}*/(value.valueOf()));
                            case FLOAT:
                                return this.valueFloat(/**@type{number}*/(value.valueOf()));
                            case DOUBLE:
                                return this.valueDouble(/**@type{number}*/(value.valueOf()));
                            case undefined:
                                return this.valueDouble(/**@type{number}*/(value.valueOf()));
                        }
                        break;
                    case Map:
                        switch (value[JSYM_PRIMITIVE]) {
                            case MAP32:
                                return this.valueMap32(value, value[JSYM_PRIM_KEY], value[JSYM_PRIM_VALUE]);
                            case MAP8:
                                return this.valueMap8(value, value[JSYM_PRIM_KEY], value[JSYM_PRIM_VALUE]);
                            case undefined:
                                return this.valueMap32(value, value[JSYM_PRIM_KEY], value[JSYM_PRIM_VALUE]);
                        }
                        break;
                    default:
                        if (Buffer.isBuffer(value)) switch (value[JSYM_PRIMITIVE]) {
                            case BIN32:
                                return this.valueBinary32(value);
                            case BIN8:
                                return this.valueBinary8(value);
                            case UUID:
                                return this.valueUUID(value);
                            case DEC32:
                                return this.valueDecimal32(value);
                            case DEC64:
                                return this.valueDecimal64(value);
                            case DEC128:
                                return this.valueDecimal128(value);
                            case undefined:
                                // noinspection JSUnresolvedVariable
                                if (value.length > 255)
                                    return this.valueBinary32(value);
                                else
                                    return this.valueBinary8(value);
                        } else if (Array.isArray(value)) switch (value[JSYM_PRIMITIVE]) {
                            case LIST32:
                                return this.valueList32(value, value[JSYM_PRIM_ITEM]);
                            case LIST8:
                                return this.valueList8(value, value[JSYM_PRIM_ITEM]);
                            case LIST0:
                                return this.valueList0();
                            case ARRAY32:
                                return this.valueArray32(value, value[JSYM_PRIM_ITEM]);
                            case ARRAY8:
                                return this.valueArray8(value, value[JSYM_PRIM_ITEM]);
                            case undefined:
                                return this.valueList32(value, value[JSYM_PRIM_ITEM]);
                        }
                }
                throw ErrMsg(EC.ENCODE_VALUE_TYPE_MISMATCH, this._frameProduced, value.constructor.name, value[JSYM_PRIMITIVE]);
            }
            case 'string':
                if (preferred) {
                    const len = Buffer.byteLength(value);
                    if (len > 255) {
                        if (preferred.has(SYM32))
                            return this.valueSymbol32(value, len);
                        else
                            return this.valueString32(value, len);
                    } else {
                        if (preferred.has(SYM8))
                            return this.valueSymbol8(value, len);
                        else
                            return this.valueString8(value, len);
                    }
                }
                return this.valueString(value);
            case 'boolean':
                return this.valueBool(value);
            case 'number':
                return this.valueDouble(value);
            default: {
                throw ErrMsg(EC.ENCODE_VALUE_TYPE_NO_SUPPORT, this._frameProduced, typeof value);
            }
        }
    }

    /**
     * @param {?Descriptor} value
     * @return {undefined|FormatCode}
     */
    writeDescriptor(value) {
        switch (typeof value) {
            case 'undefined':
                return undefined;
            case 'number':
                this.writeDataUInt8(DESCRIPTOR);
                return this.writeULong(true, value);
            case 'string':
                this.writeDataUInt8(DESCRIPTOR);
                return this.writeSymbol(true, value);
            case 'object': {
                if (value === null) return undefined;
                this.writeDataUInt8(DESCRIPTOR);
                this.writeDescriptor(value[JSYM_DESCRIPTOR]);
                switch (value.constructor.name) {
                    case 'Number':
                        return this.writeULong(true, /**@type{number}*/(value.valueOf()));
                    case 'String':
                        return this.writeSymbol(true, /**@type{string}*/(value.valueOf()));
                }
                throw ErrMsg(EC.ENCODE_INV_DESC_VAL, this._frameProduced, value.constructor.name);
            }
        }
        throw ErrMsg(EC.ENCODE_INV_DESC_VAL, this._frameProduced, typeof value);
    }

    /**
     * @return {FormatCode}
     * @final
     */
    valueNull() {
        this._writing(1);
        this._chunkWriting.writeUInt8(NULL, this._chunkOffset);
        return NULL;
    }

    /**
     * @return {FormatCode}
     * @final
     */
    valueTrue() {
        this._writing(1);
        this._chunkWriting.writeUInt8(TRUE, this._chunkOffset);
        return TRUE;
    }

    /**
     * @return {FormatCode}
     * @final
     */
    valueFalse() {
        this._writing(1);
        this._chunkWriting.writeUInt8(FALSE, this._chunkOffset);
        return FALSE;
    }

    /**
     * @param {boolean} value
     * @return {FormatCode}
     * @final
     */
    valueBool(value) {
        this._writing(2);
        this._chunkWriting.writeUInt8(BOOL, this._chunkOffset);
        this._chunkWriting.writeUInt8(value ? VBOOL_TRUE : VBOOL_FALSE, this._chunkOffset + 1);
        return BOOL;
    }

    /**
     * @param {boolean} value
     * @final
     */
    plainBool(value) {
        this._writing(1);
        this._chunkWriting.writeUInt8(value ? VBOOL_TRUE : VBOOL_FALSE, this._chunkOffset);
    }

    /**
     * @param {number} value
     * @return {FormatCode}
     * @final
     */
    valueUByte(value) {
        this._writing(2);
        this._chunkWriting.writeUInt8(UBYTE, this._chunkOffset);
        this._chunkWriting.writeUInt8(value, this._chunkOffset + 1);
        return UBYTE;
    }

    /**
     * @param {number} value
     * @final
     */
    plainUByte(value) {
        this._writing(1);
        this._chunkWriting.writeUInt8(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     * @return {FormatCode}
     * @final
     */
    valueUShort(value) {
        this._writing(3);
        this._chunkWriting.writeUInt8(USHORT, this._chunkOffset);
        this._chunkWriting.writeUInt16BE(value, this._chunkOffset + 1);
        return USHORT;
    }

    /**
     * @param {number} value
     * @final
     */
    plainUShort(value) {
        this._writing(2);
        this._chunkWriting.writeUInt16BE(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     * @return {FormatCode}
     * @final
     */
    valueUInt(value) {
        this._writing(5);
        this._chunkWriting.writeUInt8(UINT, this._chunkOffset);
        this._chunkWriting.writeUInt32BE(value, this._chunkOffset + 1);
        return UINT;
    }

    /**
     * @param {number} value
     * @final
     */
    plainUInt(value) {
        this._writing(4);
        this._chunkWriting.writeUInt32BE(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     * @return {FormatCode}
     * @final
     */
    valueSmallUInt(value) {
        this._writing(2);
        this._chunkWriting.writeUInt8(SMALLUINT, this._chunkOffset);
        this._chunkWriting.writeUInt8(value, this._chunkOffset + 1);
        return SMALLUINT;
    }

    /**
     * @param {number} value
     * @final
     */
    plainSmallUInt(value) {
        this._writing(1);
        this._chunkWriting.writeUInt8(value, this._chunkOffset);
    }

    /**
     * @return {FormatCode}
     * @final
     */
    valueUInt0() {
        this._writing(1);
        this._chunkWriting.writeUInt8(UINT0, this._chunkOffset);
        return UINT0;
    }

    /**
     * @param {number|string} value
     * @return {FormatCode}
     * @final
     */
    valueULong(value) {
        this._writing(9);
        this._chunkWriting.writeUInt8(ULONG, this._chunkOffset);
        writeUInt64BE(this._chunkWriting, value, this._chunkOffset + 1);
        return ULONG;
    }

    /**
     * @param {number|string} value
     * @final
     */
    plainULong(value) {
        this._writing(8);
        writeUInt64BE(this._chunkWriting, value, this._chunkOffset);
    }

    /**
     * @param {number} value
     * @return {FormatCode}
     * @final
     */
    valueSmallULong(value) {
        this._writing(2);
        this._chunkWriting.writeUInt8(SMALLULONG, this._chunkOffset);
        this._chunkWriting.writeUInt8(value, this._chunkOffset + 1);
        return SMALLULONG;
    }

    /**
     * @param {number} value
     * @final
     */
    plainSmallULong(value) {
        this._writing(1);
        this._chunkWriting.writeUInt8(value, this._chunkOffset);
    }

    /**
     * @return {FormatCode}
     * @final
     */
    valueULong0() {
        this._writing(1);
        this._chunkWriting.writeUInt8(ULONG0, this._chunkOffset);
        return ULONG0;
    }

    /**
     * @param {number} value
     * @return {FormatCode}
     * @final
     */
    valueByte(value) {
        this._writing(2);
        this._chunkWriting.writeUInt8(BYTE, this._chunkOffset);
        this._chunkWriting.writeInt8(value, this._chunkOffset + 1);
        return BYTE;
    }

    /**
     * @param {number} value
     * @final
     */
    plainByte(value) {
        this._writing(1);
        this._chunkWriting.writeInt8(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     * @return {FormatCode}
     * @final
     */
    valueShort(value) {
        this._writing(3);
        this._chunkWriting.writeUInt8(SHORT, this._chunkOffset);
        this._chunkWriting.writeInt16BE(value, this._chunkOffset + 1);
        return SHORT;
    }

    /**
     * @param {number} value
     * @final
     */
    plainShort(value) {
        this._writing(2);
        this._chunkWriting.writeInt16BE(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     * @return {FormatCode}
     * @final
     */
    valueInt(value) {
        this._writing(5);
        this._chunkWriting.writeUInt8(INT, this._chunkOffset);
        this._chunkWriting.writeInt32BE(value, this._chunkOffset + 1);
        return INT;
    }

    /**
     * @param {number} value
     * @final
     */
    plainInt(value) {
        this._writing(4);
        this._chunkWriting.writeInt32BE(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     * @return {FormatCode}
     * @final
     */
    valueSmallInt(value) {
        this._writing(2);
        this._chunkWriting.writeUInt8(SMALLINT, this._chunkOffset);
        this._chunkWriting.writeInt8(value, this._chunkOffset + 1);
        return SMALLINT;
    }

    /**
     * @param {number} value
     * @final
     */
    plainSmallInt(value) {
        this._writing(1);
        this._chunkWriting.writeInt8(value, this._chunkOffset);
    }

    /**
     * @param {number|string} value
     * @return {FormatCode}
     * @final
     */
    valueLong(value) {
        this._writing(9);
        this._chunkWriting.writeUInt8(LONG, this._chunkOffset);
        writeInt64BE(this._chunkWriting, value, this._chunkOffset + 1);
        return LONG;
    }

    /**
     * @param {number|string} value
     * @final
     */
    plainLong(value) {
        this._writing(8);
        writeInt64BE(this._chunkWriting, value, this._chunkOffset);
    }

    /**
     * @param {number} value
     * @return {FormatCode}
     * @final
     */
    valueSmallLong(value) {
        this._writing(2);
        this._chunkWriting.writeUInt8(SMALLLONG, this._chunkOffset);
        this._chunkWriting.writeInt8(value, this._chunkOffset + 1);
        return SMALLLONG;
    }

    /**
     * @param {number} value
     * @final
     */
    plainSmallLong(value) {
        this._writing(1);
        this._chunkWriting.writeInt8(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     * @return {FormatCode}
     * @final
     */
    valueFloat(value) {
        this._writing(5);
        this._chunkWriting.writeUInt8(FLOAT, this._chunkOffset);
        this._chunkWriting.writeFloatBE(value, this._chunkOffset + 1);
        return FLOAT;
    }

    /**
     * @param {number} value
     * @final
     */
    plainFloat(value) {
        this._writing(4);
        this._chunkWriting.writeFloatBE(value, this._chunkOffset);
    }

    /**
     * @param {number} value
     * @return {FormatCode}
     * @final
     */
    valueDouble(value) {
        this._writing(9);
        this._chunkWriting.writeUInt8(DOUBLE, this._chunkOffset);
        this._chunkWriting.writeDoubleBE(value, this._chunkOffset + 1);
        return DOUBLE;
    }

    /**
     * @param {number} value
     * @final
     */
    plainDouble(value) {
        this._writing(8);
        this._chunkWriting.writeDoubleBE(value, this._chunkOffset);
    }

    /**
     * @param {!Buffer} value
     * @return {FormatCode}
     */
    valueDecimal32(value) {
        this._writing(5);
        this._chunkWriting.writeUInt8(DEC32, this._chunkOffset);
        value.copy(this._chunkWriting, this._chunkOffset + 1, 0, 4);
        return DEC32;
    }

    /**
     * @param {!Buffer} value
     */
    plainDecimal32(value) {
        this._writing(4);
        value.copy(this._chunkWriting, this._chunkOffset, 0, 4);
    }

    /**
     * @param {!Buffer} value
     * @return {FormatCode}
     */
    valueDecimal64(value) {
        this._writing(9);
        this._chunkWriting.writeUInt8(DEC64, this._chunkOffset);
        value.copy(this._chunkWriting, this._chunkOffset + 1, 0, 8);
        return DEC64;
    }

    /**
     * @param {!Buffer} value
     */
    plainDecimal64(value) {
        this._writing(8);
        value.copy(this._chunkWriting, this._chunkOffset, 0, 8);
    }

    /**
     * @param {!Buffer} value
     * @return {FormatCode}
     */
    valueDecimal128(value) {
        this._writing(17);
        this._chunkWriting.writeUInt8(DEC128, this._chunkOffset);
        value.copy(this._chunkWriting, this._chunkOffset + 1, 0, 16);
        return DEC128;
    }

    /**
     * @param {!Buffer} value
     */
    plainDecimal128(value) {
        this._writing(16);
        value.copy(this._chunkWriting, this._chunkOffset, 0, 16);
    }

    /**
     * @param {!Timestamp} value
     * @return {FormatCode}
     * @final
     */
    valueTimestamp(value) {
        this._writing(9);
        this._chunkWriting.writeUInt8(TIMESTAMP, this._chunkOffset);
        writeInt64BE(this._chunkWriting, value.valueOf(), this._chunkOffset + 1);
        return TIMESTAMP;
    }

    /**
     * @param {!Timestamp} value
     * @final
     */
    plainTimestamp(value) {
        this._writing(8);
        writeInt64BE(value.valueOf(), this._chunkOffset);
    }

    /**
     * @param {!Buffer} value
     * @return {FormatCode}
     * @final
     */
    valueUUID(value) {
        this._writing(17);
        this._chunkWriting.writeUInt8(UUID, this._chunkOffset);
        value.copy(this._chunkWriting, this._chunkOffset + 1, 0, 16);
        return UUID;
    }

    /**
     * @param {!Buffer} value
     * @final
     */
    plainUUID(value) {
        this._writing(16);
        value.copy(this._chunkWriting, this._chunkOffset, 0, 16);
    }

    /**
     * @param {string} value
     * @return {FormatCode}
     * @final
     */
    valueChar(value) {
        this._writing(5);
        this._chunkWriting.writeUInt8(CHAR, this._chunkOffset);
        this._chunkWriting.writeUInt32BE(value.codePointAt(0), this._chunkOffset + 1);
        return CHAR;
    }

    /**
     * @param {string} value
     * @final
     */
    plainChar(value) {
        this._writing(4);
        this._chunkWriting.writeUInt32BE(value.codePointAt(0), this._chunkOffset);
    }

    /**
     * @param {!Array<!Buffer>} value
     */
    valueBinaryArray(value) {
        this.writeDataUInt8(BIN32);
        const sizer = this._writeBlockSize32();
        for (const b of value) if (b) this.writeDataBlob(b);
        sizer();
    }

    /**
     * @param {!BinaryValue} value
     * @return {FormatCode}
     * @final
     */
    valueBinary(value) {
        // noinspection JSUnresolvedVariable
        if (value.length > 255)
            return this.valueBinary32(value);
        else
            return this.valueBinary8(value);
    }

    /**
     * @param {!BinaryValue} value
     * @return {FormatCode}
     * @final
     */
    valueBinary32(value) {
        this._writing(5);
        this._chunkWriting.writeUInt8(BIN32, this._chunkOffset);
        // noinspection JSUnresolvedVariable
        this._chunkWriting.writeUInt32BE(value.length, this._chunkOffset + 1);
        this.writeDataBlob(value);
        return BIN32;
    }

    /**
     * @param {!BinaryValue} value
     * @final
     */
    plainBinary32(value) {
        this._writing(4);
        // noinspection JSUnresolvedVariable
        this._chunkWriting.writeUInt32BE(value.length, this._chunkOffset);
        this.writeDataBlob(value);
    }

    /**
     * @param {!BinaryValue} value
     * @return {FormatCode}
     * @final
     */
    valueBinary8(value) {
        this._writing(2);
        this._chunkWriting.writeUInt8(BIN8, this._chunkOffset);
        // noinspection JSUnresolvedVariable
        this._chunkWriting.writeUInt8(value.length, this._chunkOffset + 1);
        this.writeDataBlob(value);
        return BIN8;
    }

    /**
     * @param {!BinaryValue} value
     * @final
     */
    plainBinary8(value) {
        this._writing(1);
        // noinspection JSUnresolvedVariable
        this._chunkWriting.writeUInt8(value.length, this._chunkOffset);
        this.writeDataBlob(value);
    }

    /**
     * @param {StringValue} value
     * @return {FormatCode}
     * @final
     */
    valueString(value) {
        const len = Buffer.byteLength(value, 'utf8');
        return (len > 255) ? this.valueString32(value, len) : this.valueString8(value, len);
    }

    /**
     * @param {StringValue} value
     * @param {number=} length
     * @return {FormatCode}
     * @final
     */
    valueString32(value, length) {
        if (length === undefined) length = Buffer.byteLength(value, 'utf8');
        this.writeDataUInt8(STR32);
        this.plainString32(value, length);
        return STR32;
    }

    /**
     * @param {StringValue} value
     * @param {number=} length
     * @final
     */
    plainString32(value, length) {
        if (!value) value = '';
        if (length === undefined) length = Buffer.byteLength(value, 'utf8');
        this.writeDataUInt32(length);
        if (length > this._frameRemaining || length > this._payloadCopyLimit) {
            // noinspection JSCheckFunctionSignatures
            this.writeDataBlob(Buffer.from(value, 'utf8'));
        } else {
            this._writing(length);
            this._chunkWriting.write(value, this._chunkOffset, length, 'utf8');
        }
    }

    /**
     * @param {StringValue} value
     * @param {number=} length
     * @return {FormatCode}
     * @final
     */
    valueString8(value, length) {
        if (length === undefined) length = Buffer.byteLength(value, 'utf8');
        this._writing(2 + length);
        this._chunkWriting.writeUInt8(STR8, this._chunkOffset);
        this._chunkWriting.writeUInt8(length, this._chunkOffset + 1);
        this._chunkWriting.write(value, this._chunkOffset + 2, length, 'utf8');
        return STR8;
    }

    /**
     * @param {StringValue} value
     * @param {number=} length
     * @final
     */
    plainString8(value, length) {
        if (!value) value = '';
        if (length === undefined) length = Buffer.byteLength(value, 'utf8');
        this._writing(1 + length);
        this._chunkWriting.writeUInt8(length, this._chunkOffset);
        this._chunkWriting.write(value, this._chunkOffset + 1, length, 'utf8');
    }

    /**
     * @param {StringValue} value
     * @return {FormatCode}
     * @final
     */
    valueSymbol(value) {
        const len = Buffer.byteLength(value, 'ascii');
        return (len > 255) ? this.valueSymbol32(value, len) : this.valueSymbol8(value, len);
    }

    /**
     * @param {SymbolValue} value
     * @param {number=} length
     * @return {FormatCode}
     * @final
     */
    valueSymbol32(value, length) {
        if (length === undefined) length = Buffer.byteLength(value, 'ascii');
        this.writeDataUInt8(SYM32);
        this.plainString32(value, length);
        return SYM32;
    }

    /**
     * @param {SymbolValue} value
     * @param {number=} length
     * @final
     */
    plainSymbol32(value, length) {
        if (!value) value = '';
        if (length === undefined) length = Buffer.byteLength(value, 'ascii');
        this.writeDataUInt32(length);
        if (length > this._frameRemaining || length > this._payloadCopyLimit) {
            // noinspection JSCheckFunctionSignatures
            this.writeDataBlob(Buffer.from(value, 'ascii'));
        } else {
            this._writing(length);
            this._chunkWriting.write(value, this._chunkOffset, length, 'ascii');
        }
    }

    /**
     * @param {SymbolValue} value
     * @param {number=} length
     * @return {FormatCode}
     * @final
     */
    valueSymbol8(value, length) {
        if (length === undefined) length = Buffer.byteLength(value, 'ascii');
        this._writing(2 + length);
        this._chunkWriting.writeUInt8(SYM8, this._chunkOffset);
        this._chunkWriting.writeUInt8(length, this._chunkOffset + 1);
        this._chunkWriting.write(value, this._chunkOffset + 2, length, 'ascii');
        return SYM8;
    }

    /**
     * @param {SymbolValue} value
     * @param {number=} length
     * @final
     */
    plainSymbol8(value, length) {
        if (!value) value = '';
        if (length === undefined) length = Buffer.byteLength(value, 'ascii');
        this._writing(1 + length);
        this._chunkWriting.writeUInt8(length, this._chunkOffset);
        this._chunkWriting.write(value, this._chunkOffset + 1, length, 'ascii');
    }

    /**
     * @return {FormatCode}
     */
    valueList0() {
        this._writing(1);
        this._chunkWriting.writeUInt8(LIST0, this._chunkOffset);
        return LIST0;
    }

    /**
     * @param {Array<*>} value
     * @param {FormatCode=} eCode
     * @return {FormatCode}
     */
    valueList32(value, eCode) {
        this._writing(1);
        this._chunkWriting.writeUInt8(LIST32, this._chunkOffset);
        this.plainList32(value, eCode);
        return LIST32;
    }

    /**
     * @param {Array<*>} value
     * @param {FormatCode=} eCode
     */
    plainList32(value, eCode) {
        const enc = eCode ? TO_VALUE[eCode].bind(this) : this.valueAny.bind(this);
        const sizer = this._writeBlockSizeCountUInt32();
        for (const item of value) enc(item);
        sizer(value.length);
    }

    /**
     * @param {Array<*>} value
     * @param {FormatCode=} eCode
     * @return {FormatCode}
     */
    valueList8(value, eCode) {
        this._writing(1);
        this._chunkWriting.writeUInt8(LIST8, this._chunkOffset);
        this.plainList8(value, eCode);
        return LIST8;
    }

    /**
     * @param {Array<*>} value
     * @param {FormatCode=} eCode
     */
    plainList8(value, eCode) {
        const enc = eCode ? TO_VALUE[eCode].bind(this) : this.valueAny.bind(this);
        const sizer = this._writeBlockSizeCountUInt8();
        for (const item of value) enc(item);
        sizer(value.length);
    }

    /**
     * @param {Map<*,*>} value
     * @param {FormatCode=} kCode
     * @param {FormatCode=} vCode
     * @return {FormatCode}
     */
    valueMap32(value, kCode, vCode) {
        this._writing(1);
        this._chunkWriting.writeUInt8(MAP32, this._chunkOffset);
        this.plainMap32(value, kCode, vCode);
        return MAP32;
    }

    /**
     * @param {Map<*,*>} value
     * @param {FormatCode=} kCode
     * @param {FormatCode=} vCode
     */
    plainMap32(value, kCode, vCode) {
        const encKey = kCode ? TO_VALUE[kCode].bind(this) : this.valueAny.bind(this);
        const encVal = vCode ? TO_VALUE[vCode].bind(this) : this.valueAny.bind(this);

        const sizer = this._writeBlockSizeCountUInt32();
        for (const [key, val] of value.entries()) {
            encKey(key);
            encVal(val);
        }
        sizer(value.size * 2);
    }

    /**
     * @param {Map<*,*>} value
     * @param {FormatCode=} kCode
     * @param {FormatCode=} vCode
     * @return {FormatCode}
     */
    valueMap8(value, kCode, vCode) {
        this._writing(1);
        this._chunkWriting.writeUInt8(MAP8, this._chunkOffset);
        this.plainMap8(value, kCode, vCode);
        return MAP8;
    }

    /**
     * @param {Map<*,*>} value
     * @param {FormatCode=} kCode
     * @param {FormatCode=} vCode
     */
    plainMap8(value, kCode, vCode) {
        const encKey = kCode ? TO_VALUE[kCode].bind(this) : this.valueAny.bind(this);
        const encVal = vCode ? TO_VALUE[vCode].bind(this) : this.valueAny.bind(this);

        const sizer = this._writeBlockSizeCountUInt8();
        for (const [key, val] of value.entries()) {
            encKey(key);
            encVal(val);
        }
        sizer(value.size * 2);
    }

    /**
     * @param {Array<*>} value
     * @param {FormatCode} eCode
     * @return {FormatCode}
     */
    valueArray32(value, eCode) {
        this._writing(1);
        this._chunkWriting.writeUInt8(ARRAY32, this._chunkOffset);
        this.plainArray32(value, eCode);
        return ARRAY32;
    }

    /**
     * @param {Array<*>} value
     * @param {FormatCode} eCode
     */
    plainArray32(value, eCode) {
        const sizer = this._writeBlockSizeCountUInt32();
        this._writing(1);
        this._chunkWriting.writeUInt8(eCode, this._chunkOffset);

        const mth = TO_PLAIN[eCode];
        if (!mth) throw ErrMsg(EC.ENCODE_INV_ARRAY_ITEM_TYPE, this._frameProduced, eCode);
        const enc = mth.bind(this);
        for (const item of value) enc(item);
        sizer(value.length);
    }

    /**
     * @param {Array<*>} value
     * @param {FormatCode} eCode
     * @return {FormatCode}
     */
    valueArray8(value, eCode) {
        this._writing(1);
        this._chunkWriting.writeUInt8(ARRAY8, this._chunkOffset);
        this.plainArray8(value, eCode);
        return ARRAY8;
    }

    /**
     * @param {Array<*>} value
     * @param {FormatCode} eCode
     */
    plainArray8(value, eCode) {
        const sizer = this._writeBlockSizeCountUInt8();
        this._writing(1);
        this._chunkWriting.writeUInt8(eCode, this._chunkOffset);

        const mth = TO_PLAIN[eCode];
        if (!mth) throw ErrMsg(EC.ENCODE_INV_ARRAY_ITEM_TYPE, this._frameProduced, eCode);
        const enc = mth.bind(this);
        for (const item of value) enc(item);
        sizer(value.length);
    }

}

const TO_PLAIN = [];
const TO_VALUE = [];

// primitive type encoded             as array item                                             as value in maps or lists

const NULL       = SIMPLE.NULL;                                                                 TO_VALUE[NULL]       = Encoder.prototype.valueNull;
const TRUE       = SIMPLE.TRUE;                                                                 TO_VALUE[TRUE]       = Encoder.prototype.valueTrue;
const FALSE      = SIMPLE.FALSE;                                                                TO_VALUE[FALSE]      = Encoder.prototype.valueFalse;
const UINT0      = SIMPLE.UINT0;                                                                TO_VALUE[UINT0]      = Encoder.prototype.valueUInt0;
const ULONG0     = SIMPLE.ULONG0;                                                               TO_VALUE[ULONG0]     = Encoder.prototype.valueULong0;
const LIST0      = COMPLEX.LIST0;                                                               TO_VALUE[LIST0]      = Encoder.prototype.valueList0;

const BOOL       = SIMPLE.BOOL;       TO_PLAIN[BOOL]       = Encoder.prototype.plainBool;       TO_VALUE[BOOL]       = Encoder.prototype.valueBool;
const UBYTE      = SIMPLE.UBYTE;      TO_PLAIN[UBYTE]      = Encoder.prototype.plainUByte;      TO_VALUE[UBYTE]      = Encoder.prototype.valueUByte;
const BYTE       = SIMPLE.BYTE;       TO_PLAIN[BYTE]       = Encoder.prototype.plainByte;       TO_VALUE[BYTE]       = Encoder.prototype.valueByte;
const SMALLUINT  = SIMPLE.SMALLUINT;  TO_PLAIN[SMALLUINT]  = Encoder.prototype.plainSmallUInt;  TO_VALUE[SMALLUINT]  = Encoder.prototype.valueSmallUInt;
const SMALLULONG = SIMPLE.SMALLULONG; TO_PLAIN[SMALLULONG] = Encoder.prototype.plainSmallULong; TO_VALUE[SMALLULONG] = Encoder.prototype.valueSmallULong;
const SMALLINT   = SIMPLE.SMALLINT;   TO_PLAIN[SMALLINT]   = Encoder.prototype.plainSmallInt;   TO_VALUE[SMALLINT]   = Encoder.prototype.valueSmallInt;
const SMALLLONG  = SIMPLE.SMALLLONG;  TO_PLAIN[SMALLLONG]  = Encoder.prototype.plainSmallLong;  TO_VALUE[SMALLLONG]  = Encoder.prototype.valueSmallLong;

const USHORT     = SIMPLE.USHORT;     TO_PLAIN[USHORT]     = Encoder.prototype.plainUShort;     TO_VALUE[USHORT]     = Encoder.prototype.valueUShort;
const SHORT      = SIMPLE.SHORT;      TO_PLAIN[SHORT]      = Encoder.prototype.plainShort;      TO_VALUE[SHORT]      = Encoder.prototype.valueShort;

const UINT       = SIMPLE.UINT;       TO_PLAIN[UINT]       = Encoder.prototype.plainUInt;       TO_VALUE[UINT]       = Encoder.prototype.valueUInt;
const INT        = SIMPLE.INT;        TO_PLAIN[INT]        = Encoder.prototype.plainInt;        TO_VALUE[INT]        = Encoder.prototype.valueInt;
const FLOAT      = SIMPLE.FLOAT;      TO_PLAIN[FLOAT]      = Encoder.prototype.plainFloat;      TO_VALUE[FLOAT]      = Encoder.prototype.valueFloat;
const CHAR       = SIMPLE.CHAR;       TO_PLAIN[CHAR]       = Encoder.prototype.plainChar;       TO_VALUE[CHAR]       = Encoder.prototype.valueChar;
const DEC32      = SIMPLE.DEC32;      TO_PLAIN[DEC32]      = Encoder.prototype.plainDecimal32;  TO_VALUE[DEC32]      = Encoder.prototype.valueDecimal32;

const ULONG      = SIMPLE.ULONG;      TO_PLAIN[ULONG]      = Encoder.prototype.plainULong;      TO_VALUE[ULONG]      = Encoder.prototype.valueULong;
const LONG       = SIMPLE.LONG;       TO_PLAIN[LONG]       = Encoder.prototype.plainLong;       TO_VALUE[LONG]       = Encoder.prototype.valueLong;
const DOUBLE     = SIMPLE.DOUBLE;     TO_PLAIN[DOUBLE]     = Encoder.prototype.plainDouble;     TO_VALUE[DOUBLE]     = Encoder.prototype.valueDouble;
const TIMESTAMP  = SIMPLE.TIMESTAMP;  TO_PLAIN[TIMESTAMP]  = Encoder.prototype.plainTimestamp;  TO_VALUE[TIMESTAMP]  = Encoder.prototype.valueTimestamp;
const DEC64      = SIMPLE.DEC64;      TO_PLAIN[DEC64]      = Encoder.prototype.plainDecimal64;  TO_VALUE[DEC64]      = Encoder.prototype.valueDecimal64;

const DEC128     = SIMPLE.DEC128;     TO_PLAIN[DEC128]     = Encoder.prototype.plainDecimal128; TO_VALUE[DEC128]     = Encoder.prototype.valueDecimal128;
const UUID       = SIMPLE.UUID;       TO_PLAIN[UUID]       = Encoder.prototype.plainUUID;       TO_VALUE[UUID]       = Encoder.prototype.valueUUID;

const BIN8       = SIMPLE.BIN8;       TO_PLAIN[BIN8]       = Encoder.prototype.plainBinary8;    TO_VALUE[BIN8]       = Encoder.prototype.valueBinary8;
const STR8       = SIMPLE.STR8;       TO_PLAIN[STR8]       = Encoder.prototype.plainString8;    TO_VALUE[STR8]       = Encoder.prototype.valueString8;
const SYM8       = SIMPLE.SYM8;       TO_PLAIN[SYM8]       = Encoder.prototype.plainSymbol8;    TO_VALUE[SYM8]       = Encoder.prototype.valueSymbol8;

const BIN32      = SIMPLE.BIN32;      TO_PLAIN[BIN32]      = Encoder.prototype.plainBinary32;   TO_VALUE[BIN32]      = Encoder.prototype.valueBinary32;
const STR32      = SIMPLE.STR32;      TO_PLAIN[STR32]      = Encoder.prototype.plainString32;   TO_VALUE[STR32]      = Encoder.prototype.valueString32;
const SYM32      = SIMPLE.SYM32;      TO_PLAIN[SYM32]      = Encoder.prototype.plainSymbol32;   TO_VALUE[SYM32]      = Encoder.prototype.valueSymbol32;

const LIST8      = COMPLEX.LIST8;     TO_PLAIN[LIST8]      = Encoder.prototype.plainList8;      TO_VALUE[LIST8]      = Encoder.prototype.valueList8;
const MAP8       = COMPLEX.MAP8;      TO_PLAIN[MAP8]       = Encoder.prototype.plainMap8;       TO_VALUE[MAP8]       = Encoder.prototype.valueMap8;

const LIST32     = COMPLEX.LIST32;    TO_PLAIN[LIST32]     = Encoder.prototype.plainList32;     TO_VALUE[LIST32]     = Encoder.prototype.valueList32;
const MAP32      = COMPLEX.MAP32;     TO_PLAIN[MAP32]      = Encoder.prototype.plainMap32;      TO_VALUE[MAP32]      = Encoder.prototype.valueMap32;

const ARRAY8     = COMPLEX.ARRAY8;    TO_PLAIN[ARRAY8]     = Encoder.prototype.plainArray8;     TO_VALUE[ARRAY8]     = Encoder.prototype.valueArray8;
const ARRAY32    = COMPLEX.ARRAY32;   TO_PLAIN[ARRAY32]    = Encoder.prototype.plainArray32;    TO_VALUE[ARRAY32]    = Encoder.prototype.valueArray32;

module.exports = {
    Encoder : Encoder
};

