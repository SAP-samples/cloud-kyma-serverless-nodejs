'use strict';

const EventEmitter = require('events');
const { EC, ErrMsg } = require('./errors');
const { mergeValues } = require('./tools/options');
const tcp = require('./transport/tcp');
const ws = require('./transport/ws');
const sasl = require('./sasl/mechanisms');
const amqp = require('./performative/frames');
const { Container } = require('./model/container');
const { adjustSelfIdleTimeout, mapMessageSource, mapMessageTarget } = require('./model/types');

const constants = require('./serialize/constants');
const MIN_MAX_FRAME_SIZE = constants.FRAME.SIZE.MINMAX;
const MIN_MAX_MESSAGE_SIZE = constants.MESSAGE.SIZE.MINMAX;
const OK = constants.VALUE.SASL.OUTCOME.OK;

/**
 * @typedef {string} TransportType - The transport type: 'tls', 'net', 'wss' or 'ws'.
 */

/**
 * @typedef {Object} ServerOptions
 * @property {Object} tls
 * @property {Object} net
 * @property {Object} wss
 * @property {Object} ws
 * @property {SaslServerConfig} sasl - Authentication settings
 * @property {ProtocolSettings} amqp - Protocol settings
 * @property {StreamParameters} tune - Fine tuning
 */

/**
 * @type {ServerOptions}
 */
const SERVER_DEFAULT_OPTIONS     = /** @type {ServerOptions} */ Object.freeze({
    tls                          : Object.freeze({
        port                     : 5671,
        host                     : '0.0.0.0',
        exclusive                : true,
        allowHalfOpen            : false
    }),
    net                          : Object.freeze({
        port                     : 5672,
        host                     : '0.0.0.0',
        exclusive                : true,
        allowHalfOpen            : false
    }),
    wss                          : Object.freeze({
        port                     : 443,
        host                     : '0.0.0.0',
        backlog                  : 511,
        path                     : '/'
    }),
    ws                           : Object.freeze({
        port                     : 80,
        host                     : '0.0.0.0',
        backlog                  : 511,
        path                     : '/'
    }),
    sasl                         : Object.freeze({
        mechanism                : 'ANONYMOUS PLAIN EXTERNAL',
        mandatory                : true
    }),
    amqp                         : Object.freeze({
        containerID              : '',
        peerHostName             : '',
        maxChannelHandle         : 0xFFFF,
        maxLinkHandle            : 0x0000FFFF,
        maxFrameSize             : 0xFFFFFFFF,
        maxMessageSize           : 0x0000000001000000,         // 16 Mb
        autoDeliveryTagPrefix    : 'tag-',
        outgoingSessionWindow    : 1000,
        incomingSessionWindow    : 1000,
        minRemoteOutgoingWindow  : 1,
        maxReceiverLinkCredit    : 255,
        minReceiverLinkCredit    : 50,
        linkHighWaterMsgCount    : 16,
        mapIncomingMsgSource     : mapMessageSource,
        mapOutgoingMsgTarget     : mapMessageTarget,
        idleTimeoutMilliseconds  : 180000,
        idleTimeoutTryKeepAlive  : false,
        adjustSelfIdleTimeout    : adjustSelfIdleTimeout
    }),
    tune                         : Object.freeze({
        decodeWrappedValues      : false,
        decodeUnsafeIntegers     : false,
        istreamHighWaterFrames   : 16,
        istreamHighWaterBytes    : 16384,
        ostreamHighWaterFrames   : 16,
        ostreamHighWaterBytes    : 16384,
        ostreamChunkRecycleLimit : 16,
        ostreamChunkDefaultSize  : 4096,
        ostreamPayloadCopyLimit  : 1024,
        socketNoDelay            : false,
        socketEndCloseTimeout    : 300
    }),
});

/**
 * @type {ServerOptions}
 */
const SERVER_MINIMUM_OPTIONS     = /** @type {ServerOptions} */ Object.freeze({
    amqp                         : Object.freeze({
        maxChannelHandle         : 1,
        maxLinkHandle            : 1,
        maxFrameSize             : MIN_MAX_FRAME_SIZE,
        maxMessageSize           : MIN_MAX_MESSAGE_SIZE,
        outgoingSessionWindow    : 0,
        incomingSessionWindow    : 0,
        minRemoteOutgoingWindow  : 1,
        maxReceiverLinkCredit    : 0,
        minReceiverLinkCredit    : -1,
        linkHighWaterMsgCount    : 4,
        idleTimeoutMilliseconds  : 0
    }),
    tune                         : Object.freeze({
        istreamHighWaterFrames   : 4,
        istreamHighWaterBytes    : 4096,
        ostreamHighWaterFrames   : 4,
        ostreamHighWaterBytes    : 4096,
        ostreamChunkRecycleLimit : 0,
        ostreamChunkDefaultSize  : MIN_MAX_FRAME_SIZE,
        ostreamPayloadCopyLimit  : 256,
        socketEndCloseTimeout    : 100
    })
});

/**
 *
 */
class Server extends EventEmitter {

    /**
     * Server started listening.
     * @event Server#listening
     * @param {string} type
     * @param {number} port
     * @param {string} host
     */

    /**
     * A new connection has been opened for one client.
     * @event Server#connected
     * @param {!Connection} connection
     */

    /**
     * An error occurred.
     * @event Server#error
     * @param {!Error} error
     */

    /**
     * @param {Object=} options
     */
    constructor(options) {
        super();

        /**
         * @type {ServerOptions}
         * @private
         */
        const opt = setupServerOptions(options);

        /**
         * @type {number}
         * @private
         */
        this._statConnectionCount = 0;

        /**
         * @type {Map<Socket, Connection>}
         * @private
         */
        this._connections = new Map();

        /**
         * @type {TcpServer}
         * @private
         */
        this._instance = null;

        /**
         * create instance
         */
        let type;
        if (opt.tls) {
            this._instance = tcp.tlsServer(opt);
            type = 'tls';
        } else if (opt.net) {
            this._instance = tcp.netServer(opt);
            type = 'net';
        } else if (opt.wss) {
            this._instance = ws.tlsServer(opt);
            type = 'wss';
        } else if (opt.ws) {
            this._instance = ws.netServer(opt);
            type = 'ws';
        } else {
            throw ErrMsg(EC.SERVER_INV_CONN_DATA);
        }

        /**
         * set event handler
         */
        this._instance
            .on('clientError', (error, socket) => this._onClientError(error, socket))
            .on('listening', (type, address, port, family) => this.emit('listening', type, address, port, family))
            .on('authenticate', (type, data, request, callback) => this.emit('authenticate', type, data, request, callback))
            .on('connection', (socket) => this._onConnection(socket, type, opt))
            .on('error', (error) => this._onServerError(error))
            .on('close', (error) => this.emit('close', error))
        ;
    }

    /**
     *
     */
    listen() {
        this._instance.listen();
    }

    /**
     *
     */
    close() {
        this._instance.close();
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     *
     */
    statistics() {
        return {
            connectionCount : this._statConnectionCount
        };
    }

    /**
     * @param {Error} error
     * @private
     */
    _onServerError(error) {
        switch(error.code) {
            case 'ECONNRESET':
                return;
            case 'ECONNABORTED':
                return;
            default:
                this.emit('error', error);
        }
    }

    /**
     * @param {Error} error
     * @param {Socket} socket
     * @private
     */
    _onClientError(error, socket) {
        this.emit('error', error);
    }

    /**
     * @param {Socket} socket
     * @param {TransportType} type
     * @param {ServerOptions} options
     */
    _onConnection(socket, type, options) {
        try {
            ++this._statConnectionCount;
            const connection = new Connection(socket, type, options);
            if (this.emit('connection', connection)) {
                this._connections.set(socket, connection);
                connection.once('close', () => this._connections.delete(socket));
                return;
            }
            connection.close();
        } catch(e) {
            this.emit('error', e);
            // noinspection JSUnresolvedFunction
            socket.destroy();
        }
    }

}

/**
 *
 */
class Connection extends EventEmitter {

    /**
     * Authentication started, credentials are to be validated.
     * @event Connection#authenticate
     * @param {SaslMechanism} mechanism - The mechanism selected by the client
     * @param {SaslData} data - The mechanism-specific data (identity, user, password)
     * @param {SaslAuthenticateCallback} callback - The callback to provide validation results
     */

    /**
     * Closed before authenticated.
     * @event Connection#abort
     * @param {boolean} hadError
     */

    /**
     * Authenticated successfully.
     * @event Connection#valid
     */

    /**
     * Ready for use by protocol layer.
     * @event Connection#ready
     * @param {PeerInfo} peerInfo - Info about peer
     * @param {PeerInfo} selfInfo - Info about self
     */

    /**
     * Idle state, e.g. empty frame was received.
     * @event Connection#idle
     * @param {boolean} local - True for local socket timeout, false for incoming empty frame or WebSocket ping
     */

    /**
     * Assert condition in inbound processing.
     * If no handler is assigned the error will be raised via 'error' event again and the socket is destroyed.
     * An assigned handler shall simply log the error. Then, if the connection is not closed explicitly at this point
     * it will end after sending a close frame with the error to the peer, and 'final' will be the next event.
     * @event Connection#assert
     * @param {Error} error
     */

    /**
     * Error occurred.
     * @event Connection#error
     * @param {Error} error
     */

    /**
     * Ending without immediate close, last chance to set an individual close timer.
     * @event Connection#final
     * @param {boolean} hadAssert
     * @param {number} closeTimeout
     */

    /**
     * Closed finally.
     * @event Connection#close
     * @param {boolean} hadError - An error occurred and forced the connection to be closed.
     * @param {!TcpConnectionStatistics} statistics - Statistics for the already closed connection.
     */

    /**
     * New session endpoint opened for the very first time
     * @event Connection#session
     * @param {Session} endpoint
     */

    /**
     * New sender endpoint opened for the very first time
     * @event Connection#sender
     * @param {Sender} endpoint
     */

    /**
     * New receiver endpoint opened for the very first time
     * @event Connection#receiver
     * @param {Receiver} endpoint
     */

    /**
     * @param {!Socket} socket
     * @param {TransportType=} type
     * @param {Object=} options
     */
    constructor(socket, type = 'net', options = null) {
        super();

        /**
         * accept options
         */
        const opt = setupConnectOptions(options);

        let connection = null;
        switch(type) {
            case 'tls':
                connection = tcp.tlsAccept(socket, opt);
                break;
            case 'net':
                connection = tcp.netAccept(socket, opt);
                break;
            case 'wss':
                connection = ws.tlsAccept(socket, opt);
                break;
            case 'ws':
                connection = ws.netAccept(socket, opt);
                break;
            default:
                throw ErrMsg(EC.SERVER_INV_CONN_TYPE, type);
        }

        /**
         * @type {TcpConnection}
         * @private
         */
        this._connection = connection;

        /**
         * @type {Container}
         * @private
         */
        this._container = new Container(opt.amqp);

        /**
         * set event handler
         */
        this._connection
            .once('abort', (hadError) => this.emit('abort', hadError))
            .once('valid', () => this.emit('valid'))
            .once('ready', () => this.emit('ready', this._container.state.peerInfo, this._container.state.selfInfo))
            .once('final', (hadAssert, closeTimeout) => this.emit('final', hadAssert, closeTimeout))
            .once('close', (hadError) => this.emit('close', hadError, connection.statistics()))
            .on('idle', (local) => this.emit('idle', local))
            .on('assert', (error) => this.emit('assert', error) ? this._container.close(error) : this._connection.close(error))
            .on('error', (error) => this._onConnectionError(error))
        ;

        /**
         * set event handler
         */
        this._container
            .on('session', (endpoint) => this.emit('session', endpoint))
            .on('sender', (endpoint) => this.emit('sender', endpoint) ? undefined : endpoint.destroy())
            .on('receiver', (endpoint) => this.emit('receiver', endpoint) ? undefined : endpoint.destroy())
            .on('error', (error) => this.emit('error', error))
        ;

        /**
         * start protocol
         */
        const decoder = connection.istream.decoder;
        const encoder = connection.ostream.encoder;

        decoder.init(opt.sasl.mandatory ? sasl : [sasl, amqp], (protocol) => {
            switch(protocol) {
                case sasl: {
                    const server = new sasl.Server(opt);
                    const stream = decoder.bind((frame)=>{     // bind sasl handler, detach stream handler
                        server.process(frame,
                            (mechanism, data, callback) => {
                                if (!this.emit('authenticate', mechanism, data, callback))
                                    callback(null, OK);
                            },
                            (reply) => {
                                encoder.push(reply);

                                if (reply.constructor !== sasl.Outcome) {
                                    encoder.flush();
                                    return;
                                }
                                // noinspection JSUnresolvedVariable
                                if (reply.code !== OK) {
                                    connection.end();
                                    return;
                                }

                                decoder.bind(stream);          // free sasl handler, rebind stream handler
                                decoder.init(amqp);
                                encoder.init(amqp);
                                encoder.flush();

                                this._container.bind(connection);
                                connection.valid();
                            },
                            (error) => {
                                connection.close(error);
                            }
                        );
                    });

                    encoder.init(sasl);
                    encoder.push(server.mechanisms());
                    encoder.flush();
                    break;
                }
                case amqp: {
                    encoder.init(amqp);
                    encoder.flush();

                    this._container.bind(connection);
                    connection.valid();
                    break;
                }
                default:
                    throw ErrMsg(EC.DECODE_PROTOCOL_FAILURE);
            }
        });
    }

    /**
     * @param {Error} error
     * @private
     */
    _onConnectionError(error) {
        switch(error.code) {
            case 'ECONNRESET':
                return;
            case 'ECONNABORTED':
                return;
            default:
                this.emit('error', error);
        }
    }

    /**
     * Send an empty frame
     */
    idle() {
        this._connection.ostream.write(new amqp.Empty());
        this._connection.idle(true);
    }

    /**
     * Close following the protocol
     * @param {Error=} error
     */
    end(error = null) {
        this._container.close(error);
    }

    /**
     * Close connection immediately
     * @param {Error=} error
     */
    close(error = null) {
        this._connection.close(error);
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * Returns current connection statistics.
     * @return {!TcpConnectionStatistics}
     */
    statistics() {
        return this._connection.statistics();
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * Indicates whether or not the client was called to pause receiving any data
     * @return {boolean}
     */
    pausing() {
        return this._connection.paused();
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * <p>The connection shall pause receiving any data, as the client is sending faster than expected.</p>
     * <p>Before using this method double-check session windows and link credits.</p>
     * <p>As soon as possible call the client to resume.</p>
     * <p>The whole connection is paused. Hence, it affects all frames for all endpoints.</p>
     */
    pause() {
        this._connection.pause();
    }

    /**
     * The client shall continue to receive data, after pause was called previously.
     */
    resume() {
        this._connection.resume();
    }

}

/**
 * @param {Object=} options
 * @return {!ServerOptions}
 * @private
 */
function setupServerOptions(options) {
    const opt = setupConnectOptions(options);
    if (!opt.wss && !opt.ws && !opt.tls && !opt.net) opt.net = SERVER_DEFAULT_OPTIONS.net;
    return /**@type{ServerOptions}*/ (opt);
}

/**
 * @param {Object=} options
 * @return {!ConnectOptions}
 * @private
 */
function setupConnectOptions(options) {
    const opt = {};
    if (options) {
        if (typeof options !== 'object') {
            throw ErrMsg(EC.OPT_INV_TYPE, 'options', 'object');
        }
        if (options.constructor.name !== 'Object') {
            throw ErrMsg(EC.OPT_INV_TYPE, 'options', 'object');
        }
        mergeValues(opt, options, [], false);
        mergeValues(opt, SERVER_DEFAULT_OPTIONS, ['tls', 'net', 'ws', 'wss'], false);
        mergeValues(opt, SERVER_MINIMUM_OPTIONS, ['tls', 'net', 'ws', 'wss'], true);
    } else {
        mergeValues(opt, SERVER_DEFAULT_OPTIONS, ['tls', 'ws', 'wss'], false); // net
    }
    sasl.acceptMechanism(opt.sasl.mechanism);
    return opt;
}

module.exports = {
    Server : Server,
    Connection : Connection
};

