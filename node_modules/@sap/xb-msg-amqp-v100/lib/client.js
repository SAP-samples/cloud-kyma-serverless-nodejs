'use strict';

const EventEmitter = require('events');
const fs = require('fs');
const url = require('url');
const { EC, ErrMsg, ErrOpt, Raise } = require('./errors');
const { mergeValues } = require('./tools/options');
const { Container } = require('./model/container');
const { adjustSelfIdleTimeout, mapMessageSource, mapMessageTarget } = require('./model/types');
const sasl = require('./sasl/mechanisms');
const amqp = require('./performative/frames');
const tcp = require('./transport/tcp');
const ws = require('./transport/ws');
const oa2 = require('./transport/oa2');

const constants = require('./serialize/constants');
const MIN_MAX_FRAME_SIZE = constants.FRAME.SIZE.MINMAX;
const MIN_MAX_MESSAGE_SIZE = constants.MESSAGE.SIZE.MINMAX;

/**
 * @typedef {Object} ClientOptions
 * @property {Object} tls - The options for tls.connect(), used in favour of net, wss or ws; see also {@link https://nodejs.org/api/tls.html#tls_tls_connect_options_callback options}
 * @property {string} tls.host - The remote host, defaults to 127.0.0.1
 * @property {number} tls.port - The remote port, defaults to 5671
 * @property {Object} net - The options for net.connect(), used in favour of wss or ws; see also {@link https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener options}
 * @property {string} net.host - The remote host, defaults to 127.0.0.1
 * @property {number} net.port - The remote port, defaults to 5672
 * @property {Object} wss - The options for https.request(), used in favour of ws; method and ws header fields will be overwritten, see also {@link https://nodejs.org/api/https.html#https_https_request_options_callback options}
 * @property {string} wss.host - The remote host, defaults to 127.0.0.1
 * @property {number} wss.port - The remote port, defaults to 443
 * @property {string} wss.path - The target path, defaults to '/'
 * @property {Object} wss.headers - Further header fields, optional
 * @property {Object} ws - The options for http.request(), method and header fields will be overwritten, see also {@link https://nodejs.org/api/http.html#http_http_request_options_callback options}
 * @property {string} ws.host - The remote host, defaults to 127.0.0.1
 * @property {number} ws.port - The remote port, defaults to 80
 * @property {string} ws.path - The target path, defaults to '/'
 * @property {Object} ws.headers - Further header fields, optional
 * @property {Object} oa2 - The parameters for OAuth 2.0,
 * @property {string} oa2.endpoint - The token endpoint url
 * @property {string} oa2.request - Further parameters to use in the http(s) request, e.g. additional trusts
 * @property {string} oa2.flow - The grant type, either {@link https://tools.ietf.org/html/rfc6749#section-4.4 'client_credentials'} which is also the default or {@link https://tools.ietf.org/html/rfc6749#section-4.3 'password'}
 * @property {string} oa2.client - The OAuth client id
 * @property {string} oa2.secret - The OAuth client secret
 * @property {string} oa2.scope - The requested scope
 * @property {string} oa2.user - Resource owners user name in case of flow 'password'
 * @property {string} oa2.password - Resource owners password in case of flow 'password'
 * @property {string|Array<string>} uri - URI encoded connection data, defined parts overwrite defaults, array provides alternatives}
 * @property {SaslClientConfig} sasl - Authentication settings
 * @property {ProtocolSettings} amqp - Protocol settings
 * @property {StreamParameters} tune - Fine tuning
 */

/**
 * @type {ClientOptions}
 */
const CLIENT_DEFAULT_OPTIONS     = /** @type {ClientOptions} */ Object.freeze({
    tls                          : Object.freeze({
        host                     : '127.0.0.1',
        port                     : 5671
    }),
    net                          : Object.freeze({
        host                     : '127.0.0.1',
        port                     : 5672
    }),
    wss                          : Object.freeze({
        host                     : '127.0.0.1',
        port                     : 443,
        path                     : '/',
        headers                  : {}
    }),
    ws                           : Object.freeze({
        host                     : '127.0.0.1',
        port                     : 80,
        path                     : '/',
        headers                  : {}
    }),
    oa2                          : Object.freeze({
        request                  : {},
        endpoint                 : '',
        flow                     : 'client_credentials',       // 'client_credentials' or 'password'
        client                   : '',
        secret                   : '',
        scope                    : '',
        user                     : '',                         // only for flow 'password'
        password                 : ''                          // only for flow 'password'
    }),
    sasl                         : Object.freeze({
        mechanism                : 'PLAIN ANONYMOUS EXTERNAL', //
        identity                 : '',
        user                     : 'guest',                    // only for 'PLAIN'
        password                 : 'guest'                     // only for 'PLAIN'
    }),
    amqp                         : Object.freeze({
        containerID              : '',
        peerHostName             : '',
        maxChannelHandle         : 0xFFFF,
        maxLinkHandle            : 0x0000FFFF,
        maxFrameSize             : 0xFFFFFFFF,
        maxMessageSize           : 0x0000000001000000,         // 16 Mb
        autoDeliveryTagPrefix    : 'tag-',
        outgoingSessionWindow    : 1000,
        incomingSessionWindow    : 1000,
        minRemoteOutgoingWindow  : 1,
        maxReceiverLinkCredit    : 255,
        minReceiverLinkCredit    : 50,
        linkHighWaterMsgCount    : 16,
        mapIncomingMsgSource     : mapMessageSource,
        mapOutgoingMsgTarget     : mapMessageTarget,
        idleTimeoutMilliseconds  : 90000,
        idleTimeoutTryKeepAlive  : true,
        adjustSelfIdleTimeout    : adjustSelfIdleTimeout
    }),
    tune                         : Object.freeze({
        decodeWrappedValues      : false,
        decodeUnsafeIntegers     : false,
        istreamHighWaterFrames   : 16,
        istreamHighWaterBytes    : 16384,
        ostreamHighWaterFrames   : 16,
        ostreamHighWaterBytes    : 16384,
        ostreamChunkRecycleLimit : 16,
        ostreamChunkDefaultSize  : 4096,
        ostreamPayloadCopyLimit  : 1024,
        socketNoDelay            : false,
        socketEndCloseTimeout    : 300
    }),
    istreams                     : Object.freeze({
    }),
    ostreams                     : Object.freeze({
    })
});

/**
 * @type {ClientOptions}
 */
const CLIENT_MINIMUM_OPTIONS     = /** @type {ClientOptions} */ Object.freeze({
    amqp                         : Object.freeze({
        maxChannelHandle         : 1,
        maxLinkHandle            : 1,
        maxFrameSize             : MIN_MAX_FRAME_SIZE,
        maxMessageSize           : MIN_MAX_MESSAGE_SIZE,
        outgoingSessionWindow    : 0,
        incomingSessionWindow    : 0,
        minRemoteOutgoingWindow  : 1,
        maxReceiverLinkCredit    : 0,
        minReceiverLinkCredit    : -1,
        linkHighWaterMsgCount    : 4,
        idleTimeoutMilliseconds  : 0
    }),
    tune                         : Object.freeze({
        istreamHighWaterFrames   : 4,
        istreamHighWaterBytes    : 4096,
        ostreamHighWaterFrames   : 4,
        ostreamHighWaterBytes    : 4096,
        ostreamChunkRecycleLimit : 0,
        ostreamChunkDefaultSize  : MIN_MAX_FRAME_SIZE,
        ostreamPayloadCopyLimit  : 256,
        socketEndCloseTimeout    : 0
    })
});

/**
 * @enum {number}
 * @private
 */
const CLIENT_STATE = Object.freeze({
    CONNECTING                   : 0x01,
    CONNECTED                    : 0x02,
    DISCONNECTING                : 0x03,
    DISCONNECTED                 : 0x04
});

/**
 * A client instance representing a single connection to the broker. In terms of AMQP 1.0 it represents a container.
 */
class Client extends EventEmitter {

    /**
     * The client has been authenticated.
     * @event Client#authenticated
     * @param {string} mechanism - The mechanism used
     */

    /**
     * The client is now connected.
     * @event Client#connected
     * @param {number} destination - Used destination, can be greater than 0 if multiple URIs are defined.
     * @param {PeerInfo} peerInfo - Peer info
     */

    /**
     * The client is now reconnecting using an alternative destination.
     * @event Client#reconnecting
     * @param {number} destination - Used destination, can be greater than 0 if multiple URIs are defined.
     */

    /**
     * The client is now disconnected. No automatic reconnect will follow. Wait a short time with (re-) connect.
     * @event Client#disconnected
     * @param {boolean} hadError - An error occurred and forced the connection to be closed.
     * @param {boolean} byServer - The server has closed the connection (unexpectedly).
     * @param {!TcpConnectionStatistics} statistics - Statistics for the already closed connection.
     */

    /**
     * Idle state, e.g. empty frame was received.
     * @event Connection#idle
     * @param {boolean} local - True for local socket timeout, false for incoming empty frame or WebSocket ping
     */

    /**
     * Assert condition in inbound processing.
     * If no handler is assigned the error will be raised via 'error' event again and the socket is destroyed.
     * An assigned handler shall simply log the error. Then, if the connection is not closed explicitly at this point
     * it will end after sending a close frame with the error to the peer, and 'final' will be the next event.
     * @event Connection#assert
     * @param {Error} error
     */

    /**
     * An error occurred.
     * @event Client#error
     * @param {!Error} error - The error object that originates from internally processing or from callbacks.
     */

    /**
     * New session endpoint opened for the very first time
     * @event Connection#session
     * @param {Session} endpoint
     */

    /**
     * New sender endpoint opened for the very first time
     * @event Connection#sender
     * @param {Sender} endpoint
     */

    /**
     * New receiver endpoint opened for the very first time
     * @event Connection#receiver
     * @param {Receiver} endpoint
     */

    /**
     * Create a new client
     * @param {(ClientOptions|Object)=} options - The options to use for a client
     * @throws {!Error} - If options are invalid
     */
    constructor(options) {
        super();

        /**
         * @const {!Array<!ClientOptions>}
         * @private
         */
        this._options = setupOptions(options);

        /**
         * @type {number}
         * @private
         */
        this._optUsed = 0;

        /**
         * @type {number}
         * @private
         */
        this._state = CLIENT_STATE.DISCONNECTED;

        /**
         * @type {TcpConnection}
         * @private
         */
        this._connection = null;

        /**
         * @type {Container}
         * @private
         */
        this._container = new Container(this._options[this._optUsed].amqp);

        /**
         * set event handler
         */
        this._container
            .on('session', (endpoint) => this._onSessionOpened(endpoint))
            .on('sender', (endpoint) => this._onSenderOpened(endpoint))
            .on('receiver', (endpoint) => this._onReceiverOpened(endpoint))
            .on('error', (error) => this.emit('error', error))
        ;

        /**
         * setup unified streams
         */
        const opt = this._options[0];

        /* setup unified incoming streams */
        Object.getOwnPropertyNames(opt.istreams).forEach((id) => {
            const settings = opt.istreams[id];
            if (settings === null || typeof settings !== 'object' || settings.constructor.name !== 'Object')
                throw ErrMsg(EC.UNIFIED_ISTREAM_INV_OPT, id);
            this.receiver(id).attach(settings);
        });

        /* setup unified outgoing streams */
        Object.getOwnPropertyNames(opt.ostreams).forEach((id) => {
            const settings = opt.ostreams[id];
            if (settings === null || typeof settings !== 'object' || settings.constructor.name !== 'Object')
                throw ErrMsg(EC.UNIFIED_OSTREAM_INV_OPT, id);
            this.sender(id).attach(settings);
        });

    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * Provide a unified consumer stream instance
     * @param {!string} id - The id that was declared as part of the client options
     * @return {!Readable} A readable stream for unified stream messages
     */
    istream(id) {
        let ep = this.receiver(id);
        if (ep.active())
            return /**@type {!Readable}*/ ep.stream();
        else if (this._options[0].istreams.hasOwnProperty(id))
            return /**@type {!Readable}*/ ep.attach(this._options[0].istreams[id]);
        else
            throw ErrMsg(EC.UNIFIED_ISTREAM_INV_ID, id);
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * Provide a unified producer stream instance
     * @param {!string} id - The id that was declared as part of the client options
     * @return {!Writable} A writable stream for unified stream messages
     */
    ostream(id) {
        let ep = this.sender(id);
        if (ep.active())
            return /**@type {!Writable}*/ ep.stream();
        else if (this._options[0].istreams.hasOwnProperty(id))
            return /**@type {!Writable}*/ ep.attach(this._options[0].ostreams[id]);
        else
            throw ErrMsg(EC.UNIFIED_OSTREAM_INV_ID, id);
    }

    /**
     * Client shall connect to server
     * @param {?NotifyOfDone} done
     * @param {?NotifyOfFailed} failed
     */
    connect(done = null, failed = null) {

        /* check status */

        switch (this._state) {
            case CLIENT_STATE.CONNECTING: {
                Raise(ErrMsg(EC.CLIENT_STATE_ERROR, 'connect', 'connecting'), failed);
                return;
            }
            case CLIENT_STATE.CONNECTED: {
                Raise(ErrMsg(EC.CLIENT_STATE_ERROR, 'connect', 'connected'), failed);
                return;
            }
            case CLIENT_STATE.DISCONNECTING: {
                Raise(ErrMsg(EC.CLIENT_STATE_ERROR, 'connect', 'disconnecting'), failed);
                return;
            }
        }
        this._state = CLIENT_STATE.CONNECTING;

        /* create socket and connect */

        const options = this._options[this._optUsed];

        const init = (connection) => this._onConnectionOpened(connection, options, done, failed);
        const fail = (error) => this._onConnectionFailed(error, true, done, failed);

        if (options.tls) {
            tcp.tlsConnect(options, init, fail);
        } else if (options.net) {
            tcp.netConnect(options, init, fail);
        } else if (options.wss) {
            if(options.oa2) {
                oa2.runGrantFlow(options.oa2,
                    (headers) => ws.tlsConnect(options, headers, init, fail),
                    fail
                );
            } else {
                ws.tlsConnect(options, {}, init, fail);
            }
        } else if (options.ws) {
            if(options.oa2) {
                oa2.runGrantFlow(options.oa2,
                    (headers) => ws.netConnect(options, headers, init, fail),
                    fail
                );
            } else {
                ws.netConnect(options, {}, init, fail);
            }
        } else {
            fail(ErrMsg(EC.CLIENT_MISS_DEST));
        }

    }

    /**
     * @param {!TcpConnection} connection
     * @param {!ClientOptions} options
     * @param {?NotifyOfDone} done
     * @param {?NotifyOfFailed} failed
     * @private
     */
    _onConnectionOpened(connection, options, done, failed) {
        // noinspection JSUnresolvedFunction
        connection
            .once('valid', () => this._onConnectionValid(connection, done))
            .once('abort', (hadError) => this._onConnectionFailed(null, hadError, done, failed))
            .on('assert', (error) => this._onConnectionAssert(error))
            .on('error', (error) => this._onConnectionError(error))
        ;

        const decoder = connection.istream.decoder;
        const encoder = connection.ostream.encoder;

        if (options.sasl.mechanism) {
            const client = new sasl.Client(options);
            const stream = decoder.bind((frame) => { // bind sasl handler, detach stream handler
                client.process(frame,
                    (reply) => {
                        encoder.push(reply);
                        encoder.flush();
                    },
                    (mechanism) => {
                        decoder.bind(stream);        // free sasl handler, rebind stream handler
                        decoder.init(amqp);
                        encoder.init(amqp);
                        this.emit('authenticated', mechanism);
                        connection.valid();
                    },
                    (error) => {
                        connection.close(error);
                    }
                );
            });
            decoder.init(sasl);
            encoder.init(sasl);
            encoder.flush();
        } else {
            decoder.init(amqp);
            encoder.init(amqp);
            connection.valid();
        }
    }

    /**
     * @param {!TcpConnection} connection
     * @param {?NotifyOfDone} done
     * @private
     */
    _onConnectionValid(connection, done) {
        this._container.bind(connection);          // will subscribe 'close' as first handler
        // noinspection JSUnresolvedFunction
        connection
            .removeAllListeners('abort')           // will release the connect failed callback
            .once('close', (hadError) => this._onConnectionClosed(connection, hadError))
            .once('ready', () => this._onConnectionReady(done))
            .on('idle', (local) => this.emit('idle', local))
        ;

        if (this._state !== CLIENT_STATE.CONNECTING) {
            connection.close();
            return;
        }

        this._connection = connection;
        this._container.open();
    }

    /**
     * @param {?NotifyOfDone} done
     * @private
     */
    _onConnectionReady(done) {
        this._state = CLIENT_STATE.CONNECTED;
        if (typeof done === 'function') done();
        this.emit('connected', this._optUsed, this._container.state.peerInfo);
    }

    /**
     * @param {!Error} error
     * @private
     */
    _onConnectionAssert(error) {
        if (this.emit('assert', error))
            this._container.close(error);
        else
            this._connection.close(error);
    }

    /**
     * @param {!Error} error
     * @private
     */
    _onConnectionError(error) {
        if (this._state === CLIENT_STATE.DISCONNECTING) {
            switch(error.code) {
                case 'ECONNRESET':
                    return;
                case 'ECONNABORTED':
                    return;
            }
        }
        this.emit('error', error);
    }

    /**
     * @param {!TcpConnection} connection
     * @param {boolean} hadError
     * @private
     */
    _onConnectionClosed(connection, hadError) {
        const byServer = this._state === CLIENT_STATE.CONNECTED;
        const statistics = connection.statistics();
        this._state = CLIENT_STATE.DISCONNECTED;
        this._optUsed = 0;
        this._connection = null;
        this.emit('disconnected', hadError, byServer, statistics);
    }

    /**
     * @param {Error} error
     * @param {boolean} hadError
     * @param {?NotifyOfDone} done
     * @param {?NotifyOfFailed} failed
     * @private
     */
    _onConnectionFailed(error, hadError, done, failed) {
        this._state = CLIENT_STATE.DISCONNECTED;
        if (error) {
            switch(error.code) {
                case 'ECONNREFUSED':
                    Raise(ErrMsg(EC.CLIENT_CONNECT_REFUSED), failed, this);
                    break;
                case 'ETIMEDOUT':
                    Raise(ErrMsg(EC.CLIENT_CONNECT_TIMEOUT), failed, this);
                    break;
                default:
                    Raise(error, failed, this);
            }
        } else if (!hadError) {
            Raise(ErrMsg(EC.CLIENT_CONNECT_FAILURE), failed, this);
        }
        if (++this._optUsed < this._options.length) {
            this.emit('reconnecting', this._optUsed);
            process.nextTick(() => this.connect(done, failed));
        } else {
            this._optUsed = 0;
            this.emit('disconnected', hadError, false);
        }
    }

    /**
     * Client shall disconnect from server
     * @param {NotifyOfDone=} done
     * @param {NotifyOfFailed=} failed
     */
    disconnect(done, failed) {
        switch (this._state) {
            case CLIENT_STATE.CONNECTING: {
                this._state = CLIENT_STATE.DISCONNECTING;
                if (typeof done === 'function') this.once('disconnected', done);
                if (this._connection === null) return;
                this._connection.close();      // close connection immediately
                break;
            }
            case CLIENT_STATE.CONNECTED: {
                this._state = CLIENT_STATE.DISCONNECTING;
                if (typeof done === 'function') this.once('disconnected', done);
                this._container.close();       // close following the protocol
                break;
            }
            case CLIENT_STATE.DISCONNECTING: {
                Raise(ErrMsg(EC.CLIENT_STATE_ERROR, 'disconnect', 'disconnecting'), failed);
                break;
            }
            case CLIENT_STATE.DISCONNECTED: {
                Raise(ErrMsg(EC.CLIENT_STATE_ERROR, 'disconnect', 'disconnected'), failed);
                break;
            }
        }
    }

    /**
     * Returns a session object. For an undefined or initial id the default session is provided. The instance is stable
     * for a client and a given id, it will not change even if the client disconnects or reconnects.
     * The session id will not be known to the peer, it is only used locally to handle multiple session instances
     * for a single client instance.
     * @param {string} id - Local identifier for a session.
     * @return {!Session} - The session object.
     */
    session(id = '') {
        if (typeof id !== 'string')
            throw ErrMsg(EC.EP_NAME_INVALID, 'session', id);
        return this._container.session(id);
    }

    /**
     * @param {Session} endpoint
     * @private
     */
    _onSessionOpened(endpoint) {
        if (!endpoint.dynamic())
            return;
        if (!this.emit('session', endpoint))
            endpoint.destroy();
    }

    /**
     * Returns a link endpoint for an outgoing link. The instance is stable for a client and a given name,
     * it will not change even if the client disconnects or reconnects.
     * @param {!LinkName} name - The name of the link, provided to the peer with the ATTACH frame.
     * @return {!Sender} - The link endpoint, a sender.
     */
    sender(name) {
        return this._container.sender(name);
    }

    /**
     * @param {Sender} endpoint
     * @private
     */
    _onSenderOpened(endpoint) {
        if (!endpoint.dynamic())
            return;
        if (!this.emit('sender', endpoint))
            endpoint.destroy();
    }

    /**
     * Returns a link endpoint for an incoming link. The instance is stable for a client and a given name,
     * it will not change even if the client disconnects or reconnects.
     * @param {!LinkName} name - The name of the link, provided to the peer with the ATTACH frame.
     * @return {!Receiver} - The link endpoint, a receiver.
     */
    receiver(name) {
        return this._container.receiver(name);
    }

    /**
     * @param {Receiver} endpoint
     * @private
     */
    _onReceiverOpened(endpoint) {
        if (!endpoint.dynamic())
            return;
        if (!this.emit('receiver', endpoint))
            endpoint.destroy();
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * Returns current connection statistics while being connected and null otherwise.
     * The event 'disconnected' will also provide statistics, a very last time, after the connection was already destroyed.
     * @return {?TcpConnectionStatistics}
     */
    statistics() {
        return this._connection ? this._connection.statistics() : null;
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * Indicates whether or not the client was called to pause receiving any data
     * @return {boolean}
     */
    pausing() {
        return this._state === CLIENT_STATE.CONNECTED ? this._connection.paused() : false;
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * <p>The client shall pause receiving any data, as the broker is sending faster than the application can consume.</p>
     * <p>Before using this method double-check session windows and link credits.</p>
     * <p>As soon as possible call the client to resume.</p>
     * <p>The whole connection is paused. Hence, it affects all frames for all endpoints.</p>
     */
    pause() {
        if (this._state === CLIENT_STATE.CONNECTED) this._connection.pause();
    }

    /**
     * The client shall continue to receive data, after pause was called previously.
     */
    resume() {
        if (this._state === CLIENT_STATE.CONNECTED) this._connection.resume();
    }

}

/**
 * @typedef {Object} UriData
 * @property {string} protocol
 * @property {string} hostname
 * @property {number} port
 * @property {string} pathname
 * @property {string} auth
 * @property {Object} query
 * @property {string} query.cacertfile
 * @property {string} query.certfile
 * @property {string} query.keyfile
 * @property {string} query.verify
 * @private
 */

/**
 * @param {!ClientOptions} target
 * @param {!string} uri
 * @return {!ClientOptions}
 * @private
 */
function mergeCfgURI(target, uri) {
    const data = /** @type {UriData} */(url.parse(uri, true, false));
    let secure = null;

    switch(data.protocol) {
        case 'amqp:':
        {
            delete target.tls;
            delete target.ws;
            delete target.wss;

            if (!target.net) {
                target.net = Object.assign({}, CLIENT_DEFAULT_OPTIONS.net);
            }
            if (data.hostname) {
                target.net.host = data.hostname;
            }
            if (data.port) {
                target.net.port = Number(data.port);
            }

            break;
        }
        case 'amqps:':
        {
            delete target.net;
            delete target.ws;
            delete target.wss;

            if (!target.tls) {
                target.tls = Object.assign({}, CLIENT_DEFAULT_OPTIONS.tls);
            }
            if (data.hostname) {
                target.tls.host = data.hostname;
            }
            if (data.port) {
                target.tls.port = Number(data.port);
            }

            secure = target.tls;

            break;
        }
        case 'ws:':
        {
            delete target.net;
            delete target.tls;
            delete target.wss;

            if (!target.ws) {
                target.ws = Object.assign({}, CLIENT_DEFAULT_OPTIONS.ws);
            }
            if (data.hostname) {
                target.ws.host = data.hostname;
            }
            if (data.port) {
                target.ws.port = Number(data.port);
            }
            if (typeof data.pathname === 'string' && data.pathname.length > 1) {
                target.ws.path = data.pathname;
            }

            break;
        }
        case 'wss:':
        {
            delete target.net;
            delete target.tls;
            delete target.ws;

            if (!target.wss) {
                target.wss = Object.assign({}, CLIENT_DEFAULT_OPTIONS.wss);
            }
            if (data.hostname) {
                target.wss.host = data.hostname;
            }
            if (data.port) {
                target.wss.port = Number(data.port);
            }
            if (typeof data.pathname === 'string' && data.pathname.length > 1) {
                target.wss.path = data.pathname;
            }

            secure = target.wss;

            break;
        }
        case null:
            break;
        default: {
            throw ErrMsg(EC.OPT_INV_URI, data.protocol);
        }
    }

    if (secure) {
        const ca = data.query.cacertfile;
        if (ca) {
            if (Array.isArray(ca)) {
                secure.ca = [];
                for (const file of ca) {
                    secure.ca.push(fs.readFileSync(file));
                }
            } else {
                secure.ca = fs.readFileSync(ca);
            }
        }

        const cert = data.query.certfile;
        if (cert) {
            if (Array.isArray(cert)) {
                secure.cert = [];
                for (const file of cert) {
                    secure.cert.push(fs.readFileSync(file));
                }
            } else {
                secure.cert = fs.readFileSync(cert);
            }
        }

        const key = data.query.keyfile;
        if (key) {
            if (Array.isArray(key)) {
                secure.key = [];
                for (const file of key) {
                    secure.key.push(fs.readFileSync(file));
                }
            } else {
                secure.key = fs.readFileSync(key);
            }
        }
    }

    if (!target.sasl) {
        target.sasl = {};
    }
    if (typeof data.auth === 'string') {
        const spos = data.auth.indexOf(':');
        if (spos === -1) {
            target.sasl.user = data.auth;
            target.sasl.password = '';
        } else {
            target.sasl.user = data.auth.slice(0, spos);
            target.sasl.password = data.auth.slice(spos + 1);
        }
        target.sasl.method = 'PLAIN';
    }

    if (!target.amqp) {
        target.amqp = {};
    }
    if (data.query.container) {
        target.amqp.containerID = typeof data.query.container === 'string' ? data.query.container : data.query.container[0];
    }

    return target;
}

/**
 * @param {(ClientOptions|Object)=} options
 * @return {!Array<ClientOptions>}
 * @private
 */
function setupOptions(options) {
    const cfg = {};

    if (options) {
        if (typeof options !== 'object') {
            throw ErrMsg(EC.OPT_INV_TYPE, 'options', 'object');
        }
        if (options.constructor.name !== 'Object') {
            throw ErrMsg(EC.OPT_INV_TYPE, 'options', 'object');
        }

        mergeValues(cfg, options, [], false);
        delete cfg.uri;
        mergeValues(cfg, CLIENT_DEFAULT_OPTIONS, ['tls', 'net', 'ws', 'wss', 'oa2'], false);

        if (cfg.wss && cfg.wss.path && cfg.wss.path[0] !== '/') throw ErrMsg(EC.OPT_INV_DATA_EXPECT, 'wss.path', '/' + cfg.wss.path);
        if (cfg.ws && cfg.ws.path && cfg.ws.path[0] !== '/') throw ErrMsg(EC.OPT_INV_DATA_EXPECT, 'ws.path', '/' + cfg.ws.path);
        if (cfg.oa2) oa2.setupOptions(cfg.oa2);
        if (!cfg.tls && !cfg.net && !cfg.wss && !cfg.ws) cfg.net = mergeValues({}, CLIENT_DEFAULT_OPTIONS.net, [], false);

        mergeValues(cfg, CLIENT_MINIMUM_OPTIONS, [], true);
        sasl.acceptMechanism(cfg.sasl.mechanism);
    } else {
        mergeValues(cfg, CLIENT_DEFAULT_OPTIONS, ['tls', 'ws', 'wss', 'oa2'], false); // net
        return [cfg];
    }

    if (typeof options.uri === 'string') {
        mergeCfgURI(cfg, options.uri);
        if (!cfg.wss && !cfg.ws && !cfg.tls && !cfg.net) cfg.net = CLIENT_DEFAULT_OPTIONS.net;
        if (!cfg.wss && !cfg.ws) delete cfg.oa2;
        return [cfg];
    }

    if (Array.isArray(options.uri)) {
        const result = [];
        for (const uri of options.uri) {
            if (typeof uri !== 'string')
                throw ErrMsg(EC.OPT_INV_TYPE, 'uri[i]', 'string');
            const data = mergeValues({}, cfg, [], false);
            mergeCfgURI(data, uri);
            if (!cfg.wss && !cfg.ws && !cfg.tls && !cfg.net) cfg.net = CLIENT_DEFAULT_OPTIONS.net;
            if (!cfg.wss && !cfg.ws) delete cfg.oa2;
            result.push(data);
        }
        if (result.length) {
            return result;
        } else {
            delete options.uri;
        }
    }

    if (options.uri === undefined) {
        if (!cfg.wss && !cfg.ws && !cfg.tls && !cfg.net) cfg.net = CLIENT_DEFAULT_OPTIONS.net;
        if (!cfg.wss && !cfg.ws) delete cfg.oa2;
        return [cfg];
    }

    throw ErrMsg(EC.OPT_INV_TYPE, 'uri', ErrOpt('string', 'array', 'undefined'));
}

module.exports = {
    Client : Client,
    setupOptions : setupOptions
};

