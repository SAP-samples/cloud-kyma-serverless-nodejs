'use strict';

const http = require('http');
const https = require('https');
const url = require('url');
const { EC, ErrMsg } = require('../errors');

/**
 * Two grant flows are supported for a trusted application:
 *
 * 1. ResourceOwnerPasswordCredentials    // see {@link https://tools.ietf.org/html/rfc6749#section-4.3}
 * 2. ClientCredentials                   // see {@link https://tools.ietf.org/html/rfc6749#section-4.4}
 *
 */

/**
 * @callback GrantFlowDone
 * @param {Object} headers
 * @private
 */

/**
 * @callback GrantFlowFailed
 * @param {Error} error
 * @private
 */

/**
 * @param {Object} options
 * @private
 */
function setupOptions(options) {
    const request = Object.assign(options.request, url.parse(options.endpoint, true, false));
    if (typeof request.port === 'string') request.port = parseInt(request.port);

    switch (options.flow) {
        case 'client_credentials':
            options.payload = 'grant_type=client_credentials';
            break;
        case 'password':
            options.payload = 'grant_type=password' + '&username=' + encodeURIComponent(options.user) + '&password=' + encodeURIComponent(options.password);
            break;
        default:
            throw ErrMsg(EC.OPT_INV_DATA_EXPECT, 'oa2.flow', 'client_credentials | password');
    }
    options.payload += (options.scope) ? '&scope=' + options.scope : '';

    request.method = 'POST';

    if (typeof request.headers !== 'object') request.headers = {};
    request.headers['Content-Type'] = 'application/x-www-form-urlencoded';
    request.headers['Content-Length'] = Buffer.byteLength(options.payload);
}

/**
 * @param {Object} options
 * @param {GrantFlowDone} done
 * @param {GrantFlowFailed} failed
 * @private
 */
function runGrantFlow(options, done, failed) {
    sendAuthViaParams(options, done, (error) => sendAuthViaHeader(options, done, failed));
}

function sendAuthViaHeader(options, done, failed) {
    const opts = Object.assign({}, options.request);
    opts.auth = options.client + ':' + options.secret;
    sendRequest(opts, options.payload, done, failed);
}

function sendAuthViaParams(options, done, failed) {
    const data = options.payload + 'client_id=' + options.client + 'client_secret=' + options.secret;
    sendRequest(options.request, data, done, failed);
}

function sendRequest(options, payload, done, failed) {
    let buffer = '';
    const request = options.protocol === 'http:' ? http.request(options) : https.request(options);
    request
        .on('response', (response) => {
            response.setEncoding('utf8');
            response
                .on('data', (chunk) => {
                    buffer += chunk;
                })
                .on('end', () => {
                    switch (response.statusCode) {
                        case 200:
                        {
                            try {
                                const data = JSON.parse(buffer);
                                if (typeof data.access_token === 'string') {
                                    done({ 'Authorization': 'Bearer ' + data.access_token});
                                } else {
                                    failed(ErrMsg(EC.OAUTH_NO_ACCESS_TOKEN));
                                }
                            } catch (error) {
                                failed(ErrMsg(EC.OAUTH_RESPONSE_ERROR, error.toString()));
                            }
                            break;
                        }
                        case 400:
                        {
                            try {
                                const data = JSON.parse(buffer);
                                failed(ErrMsg(EC.OAUTH_REQUEST_FAILED, response.statusCode.toString(), data.toString()));
                            } catch (error) {
                                failed(ErrMsg(EC.OAUTH_REQUEST_FAILED, response.statusCode.toString(), buffer));
                            }
                            break;
                        }
                        default:
                        {
                            failed(ErrMsg(EC.OAUTH_REQUEST_FAILED, response.statusCode.toString(), buffer));
                        }
                    }
                })
                .on('error', (error)=> {
                    failed(error);
                });
        })
        .on('error', (error) => {
            failed(error);
        })
        .on('aborted', (error) => {
            failed(error);
        });
    request.write(payload);
    request.end();
}

module.exports.setupOptions = setupOptions;
module.exports.runGrantFlow = runGrantFlow;

