'use strict';

const crypto = require('crypto');
const http = require('http');
const https = require('https');

const { EC, ErrMsg } = require('../errors');
const { TcpReader, TcpWriter, TcpConnection, TcpServer } = require('./tcp');
const { Payload } = require('../serialize/types');
const { writeUInt64BE, readUInt64BE } = require('../tools/bignum');

const constants = require('../serialize/constants');
const PROTOCOL = constants.PROTOCOL.WS;
const USER_AGENT = constants.RUNTIME.LIBRARY.replace('@sap/', 'sap-') + '/' + constants.RUNTIME.VERSION + ' nodejs/' + process.versions.node.replace('v', '');

/*
 *     0                   1                   2                   3
 *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *    +-+-+-+-+-------+-+-------------+-------------------------------+
 *    |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 *    |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 *    |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 *    | |1|2|3|       |K|             |                               |
 *    +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 *    |     Extended payload length continued, if payload len == 127  |
 *    + - - - - - - - - - - - - - - - +-------------------------------+
 *    |                               |Masking-key, if MASK set to 1  |
 *    +-------------------------------+-------------------------------+
 *    | Masking-key (continued)       |          Payload Data         |
 *    +-------------------------------- - - - - - - - - - - - - - - - +
 *    :                     Payload Data continued ...                :
 *    + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 *    |                     Payload Data continued ...                |
 *    +---------------------------------------------------------------+
 */

const WS_FLAG_FIN        = 0x80;

const WS_OP_BITS         = 0x0F;
const WS_OP_CONTINUATION = 0x00;
const WS_OP_TEXT         = 0x01;
const WS_OP_BINARY       = 0x02;
const WS_OP_CLOSE        = 0x08;
const WS_OP_PING         = 0x09;
const WS_OP_PONG         = 0x0A;

const WS_FLAG_MASKED     = 0x80;
const WS_LENGTH_BITS     = 0x7F;

const WS_ACCEPT_SUFFIX   = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';

const WS_HEAD_L64_MASKED = 2 /* start */ + 8 /* size field */ + 4 /* masking key */;
const WS_HEAD_L16_MASKED = 2 /* start */ + 2 /* size field */ + 4 /* masking key */;
const WS_HEAD_125_MASKED = 2 /* start */                      + 4 /* masking key */;

const WS_HEAD_L64_NOMASK = 2 /* start */ + 8 /* size field */;
const WS_HEAD_L16_NOMASK = 2 /* start */ + 2 /* size field */;
const WS_HEAD_125_NOMASK = 2 /* start */;

const WS_CLOSE_CODES = {
    1000: 'normal',
    1001: 'going away',
    1002: 'protocol error',
    1003: 'unsupported data',
    1004: 'reserved',
    1005: 'reserved for extensions',
    1006: 'reserved for extensions',
    1007: 'inconsistent or invalid data',
    1008: 'policy violation',
    1009: 'message too big',
    1010: 'extension handshake missing',
    1011: 'an unexpected condition prevented the request from being fulfilled',
    1012: 'service restart',
    1013: 'try again later'
};

/**
 * @private
 */
class WsReader extends TcpReader{

    /**
     * @param {!StreamParameters} options
     * @param {boolean} unmask
     */
    constructor(options, unmask) {
        super(options);

        /**
         * @type {?object|?boolean}
         * @private
         */
        this._wsIsFin = null;

        /**
         * @type {?number}
         * @private
         */
        this._wsOpcode = null;

        /**
         * @type {?object|?boolean}
         * @private
         */
        this._wsIsMasked = null;

        /**
         * @type {Buffer}
         * @private
         */
        this._wsMask = unmask ? Buffer.allocUnsafe(4) : null;

        /**
         * @type {!number}
         * @private
         */
        this._wsMaskBytes = 0;

        /**
         * @type {?number}
         * @private
         */
        this._wsMaskIndex = null;

        /**
         * @type {?number}
         * @private
         */
        this._wsLength = null;

        /**
         * @type {!number}
         * @private
         */
        this._wsLenBytes = 0;

        /**
         * @type {!number}
         * @private
         */
        this._wsLenIndex = 0;

        /**
         * @type {!Buffer}
         * @private
         */
        this._wsLenBuffer = Buffer.alloc(8);

        /**
         * @type {!Payload}
         * @private
         */
        this._wsDataPing = new Payload();

        /**
         * @type {!Payload}
         * @private
         */
        this._wsDataPong = new Payload();

        /**
         * @type {!Payload}
         * @private
         */
        this._wsDataClose = new Payload();

        /**
         * @type {!number}
         */
        this.wsStatFrame125 = 0;

        /**
         * @type {!number}
         */
        this.wsStatFrameL16 = 0;

        /**
         * @type {!number}
         */
        this.wsStatFrameL64 = 0;
    }

    /**
     * @param {!Buffer} chunk
     * @private
     * @override
     */
    _decode(chunk) {
        const length = chunk.length; let offset = 0;
        while (offset < length) {

            if (this._wsIsFin === null) {
                const byte = chunk.readUInt8(offset++);
                this._wsIsFin = (byte & WS_FLAG_FIN) !== 0;
                this._wsOpcode = byte & WS_OP_BITS;
                continue;
            }

            if (this._wsIsMasked === null) {
                const byte = chunk.readUInt8(offset++);
                this._wsIsMasked = (byte & WS_FLAG_MASKED) !== 0;
                if (this._wsIsMasked) {
                    if (this._wsMask === null) throw ErrMsg(EC.WS_MASK_NOT_EXPECTED);
                    this._wsMaskIndex = 0;
                    this._wsMaskBytes = 4;
                }
                this._wsLength = byte & WS_LENGTH_BITS;
                switch (this._wsLength) {
                    case 126:
                        this.wsStatFrameL16++;
                        this._wsLength = 0;
                        this._wsLenBytes = 2;
                        this._wsLenIndex = 0;
                        break;
                    case 127:
                        this.wsStatFrameL64++;
                        this._wsLength = 0;
                        this._wsLenBytes = 8;
                        this._wsLenIndex = 0;
                        break;
                    default:
                        this.wsStatFrame125++;
                }
                continue;
            }

            if (this._wsLenBytes > 0) {
                if (this._wsLenIndex === 0 && ( offset + this._wsLenBytes - 1 ) < length) {
                    this._wsLength = this._wsReadLength(chunk, offset);
                    offset += this._wsLenBytes;
                } else {
                    while(this._wsLenIndex < this._wsLenBytes && offset < length)
                        this._wsLenBuffer[this._wsLenIndex++] = chunk.readUInt8(offset++);
                    if (this._wsLenIndex < this._wsLenBytes)
                        continue;
                    this._wsLength = this._wsReadLength(this._wsLenBuffer, 0);
                }
                this._wsLenBytes = 0;
                continue;
            }

            if (this._wsMaskBytes > 0){
                while(this._wsMaskBytes > 0 && offset < length)
                    this._wsMask[4 - this._wsMaskBytes--] = chunk.readUInt8(offset++);
                continue;
            }

            const len = Math.min(this._wsLength, chunk.length - offset);
            const data = len ? chunk.slice(offset, offset + len) : null;
            offset += len;
            this._wsLength -= len;

            if (data && this._wsIsMasked)
                this._wsMaskIndex = unmaskPayload(data, this._wsMask, this._wsMaskIndex);

            switch (this._wsOpcode) {
                case WS_OP_BINARY:
                    if (data) {
                        this.decoder.push(data);
                    }
                    break;
                case WS_OP_CONTINUATION:
                    if (data) {
                        this.decoder.push(data);
                    }
                    break;
                case WS_OP_PING:
                    if (data) {
                        this._wsDataPing.chunks.push(data);
                    }
                    if (this._wsLength === 0) {
                        const payload = this._wsDataPing;
                        this._wsDataPing = new Payload();
                        this.emit('ws_ping', payload.toBuffer());
                    }
                    break;
                case WS_OP_PONG:
                    if (data) {
                        this._wsDataPong.chunks.push(data);
                    }
                    if (this._wsLength === 0) {
                        const payload = this._wsDataPong;
                        this._wsDataPong = new Payload();
                        this.emit('ws_pong', payload.toBuffer());
                    }
                    break;
                case WS_OP_CLOSE:
                    if (data) {
                        this._wsDataClose.chunks.push(data);
                    }
                    if (this._wsLength === 0) {
                        const payload = this._wsDataClose;
                        this._wsDataClose = new Payload();
                        this.emit('ws_close', payload.toBuffer());
                    }
                    break;
                case WS_OP_TEXT:
                    throw ErrMsg(EC.WS_CODE_TEXT_NOT_EXPECTED);
            }

            if(this._wsLength === 0) {
                this._wsIsFin = null;
                this._wsIsMasked = null;
            }

        }

    }

    /**
     * @param {Buffer} buffer
     * @param {number} offset
     * @return {number}
     * @private
     */
    _wsReadLength(buffer, offset) {
        if (this._wsLenBytes === 2) {
            return buffer.readUInt16BE(offset);
        } else {
            const v = readUInt64BE(buffer, offset);
            const i = Number(v);
            if (i > Number.MAX_SAFE_INTEGER) throw ErrMsg(EC.WS_INV_PAYLOAD_LENGTH, v);
            return i;
        }
    }
}

/**
 * @param {!Buffer} payload
 * @param {!Buffer} mask
 * @param {number} offset
 * @return {number}
 * @private
 */
function unmaskPayload(payload, mask, offset) {
    let off = 0, len = payload.length, index = offset;
    while (off < len)
        payload[off++] ^= mask[index++ % 4];
    return index;
}

/**
 * @param {!Buffer} payload
 * @return {!Buffer}
 * @private
 */
function maskPayload(payload) {
    const mask = crypto.randomBytes(4);
    let index = payload.length;
    while(index)
        payload[--index] ^= mask[index % 4];
    return mask;
}

/**
 * @typedef {function(opcode:number, head:Buffer, payload:Buffer)} WriteFrame
 * @private
 */

/**
 * @type {WriteFrame}
 * @private
 */
function writeFrame125Masked(opcode, head, payload) {
    const mask = maskPayload(payload);
    head.writeUInt8(opcode | WS_FLAG_FIN, 0);
    head.writeUInt8(payload.length | WS_FLAG_MASKED, 1);
    head.writeUInt8(mask[0], 2);
    head.writeUInt8(mask[1], 3);
    head.writeUInt8(mask[2], 4);
    head.writeUInt8(mask[3], 5);
}

/**
 * @type {WriteFrame}
 * @private
 */
function writeFrameL16Masked(opcode, head, payload) {
    const mask = maskPayload(payload);
    head.writeUInt8(opcode | WS_FLAG_FIN, 0);
    head.writeUInt8(126 | WS_FLAG_MASKED, 1);
    head.writeUInt16BE(payload.length, 2);
    head.writeUInt8(mask[0], 4);
    head.writeUInt8(mask[1], 5);
    head.writeUInt8(mask[2], 6);
    head.writeUInt8(mask[3], 7);
}

/**
 * @type {WriteFrame}
 * @private
 */
function writeFrameL64Masked(opcode, head, payload) {
    const mask = maskPayload(payload);
    head.writeUInt8(opcode | WS_FLAG_FIN, 0);
    head.writeUInt8(127 | WS_FLAG_MASKED, 1);
    writeUInt64BE(head, payload.length, 2);
    head.writeUInt8(mask[0], 10);
    head.writeUInt8(mask[1], 11);
    head.writeUInt8(mask[2], 12);
    head.writeUInt8(mask[3], 13);
}

/**
 * @type {WriteFrame}
 * @private
 */
function writeFrame125NoMask(opcode, head, payload) {
    head.writeUInt8(opcode | WS_FLAG_FIN, 0);
    head.writeUInt8(payload.length, 1);
}

/**
 * @type {WriteFrame}
 * @private
 */
function writeFrameL16NoMask(opcode, head, payload) {
    head.writeUInt8(opcode | WS_FLAG_FIN, 0);
    head.writeUInt8(126, 1);
    head.writeUInt16BE(payload.length, 2);
}

/**
 * @type {WriteFrame}
 * @private
 */
function writeFrameL64NoMask(opcode, head, payload) {
    head.writeUInt8(opcode | WS_FLAG_FIN, 0);
    head.writeUInt8(127, 1);
    writeUInt64BE(head, payload.length, 2);
}

/**
 * @private
 */
class WsWriter extends TcpWriter {

    /**
     * @param {!StreamParameters} options
     * @param {!Socket} socket
     * @param {boolean} mask
     */
    constructor(options, socket, mask) {

        if (mask) {
            // assure payload is copied in any case
            // ws masking modifies ws data
            options = Object.assign({}, options, {ostreamPayloadCopyLimit: Number.MAX_SAFE_INTEGER});
        }

        super(options, socket);

        /**
         * @type {!number}
         */
        this.wsStatFrame125 = 0;

        /**
         * @type {!number}
         */
        this.wsStatFrameL16 = 0;

        /**
         * @type {!number}
         */
        this.wsStatFrameL64 = 0;

        /**
         * @type {!number}
         */
        this.wsStatHeadChunks = 0;

        /**
         * Stores reduced chunk views after header reservation (key) with the original raw chunks allocated (value)
         * @type {WeakMap}
         */
        this._wsRawMap = new WeakMap();

        /**
         * @type {number}
         * @private
         */
        this._WS_HEAD_125 = mask ? WS_HEAD_125_MASKED : WS_HEAD_125_NOMASK;

        /**
         * @type {number}
         * @private
         */
        this._WS_HEAD_L16 = mask ? WS_HEAD_L16_MASKED : WS_HEAD_L16_NOMASK;

        /**
         * @type {number}
         * @private
         */
        this._WS_HEAD_L64 = mask ? WS_HEAD_L64_MASKED : WS_HEAD_L64_NOMASK;

        /**
         * @type {number}
         * @private
         */
        this._WS_HEAD_RSV = mask ? WS_HEAD_L16_MASKED : WS_HEAD_L16_NOMASK;

        /**
         * @type {WriteFrame}
         * @private
         */
        this._writeFrame125 = mask ? writeFrame125Masked : writeFrame125NoMask;

        /**
         * @type {WriteFrame}
         * @private
         */
        this._writeFrameL16 = mask ? writeFrameL16Masked : writeFrameL16NoMask;

        /**
         * @type {WriteFrame}
         * @private
         */
        this._writeFrameL64 = mask ? writeFrameL64Masked : writeFrameL64NoMask;
    }

    /**
     * @param {!number} opcode
     * @param {!Buffer} payload
     * @param {Buffer=} buffer
     * @param {number=} reserved
     */
     wsSend(opcode, payload, buffer, reserved) {
        if (payload.length <= 125) {
            if (reserved && reserved >= this._WS_HEAD_125) {
                this._writeFrame125(opcode, buffer.slice(reserved - this._WS_HEAD_125, reserved), payload);
                super._chunkDispatch(buffer.slice(reserved - this._WS_HEAD_125, reserved + payload.length), buffer);
            } else {
                const rawHead = super._chunkAllocate(this._WS_HEAD_125);        // request chunk with minimum size
                const useHead = rawHead.slice(0, this._WS_HEAD_125);            // limit chunk to the minimum size
                this._writeFrame125(opcode, useHead, payload);
                super._chunkDispatch(useHead, rawHead);
                super._chunkDispatch(payload, buffer);
                this.wsStatHeadChunks++;
            }
            this.wsStatFrame125++;
        } else if (payload.length <= 0xFFFF) {
            if (reserved && reserved >= this._WS_HEAD_L16) {
                this._writeFrameL16(opcode, buffer.slice(reserved - this._WS_HEAD_L16, reserved), payload);
                super._chunkDispatch(buffer.slice(reserved - this._WS_HEAD_L16, reserved + payload.length), buffer);
            } else {
                const rawHead = super._chunkAllocate(this._WS_HEAD_L16);        // request chunk with minimum size
                const useHead = rawHead.slice(0, this._WS_HEAD_L16);            // limit chunk to the minimum size
                this._writeFrameL16(opcode, useHead, payload);
                super._chunkDispatch(useHead, rawHead);
                super._chunkDispatch(payload, buffer);
                this.wsStatHeadChunks++;
            }
            this.wsStatFrameL16++;
        } else {
            if (reserved && reserved >= this._WS_HEAD_L64) {
                this._writeFrameL64(opcode, buffer.slice(reserved - this._WS_HEAD_L64, reserved), payload);
                super._chunkDispatch(buffer.slice(reserved - this._WS_HEAD_L64, reserved + payload.length), buffer);
            } else {
                const rawHead = super._chunkAllocate(this._WS_HEAD_L64);        // request chunk with minimum size
                const useHead = rawHead.slice(0, this._WS_HEAD_L64);            // limit chunk to the minimum size
                this._writeFrameL64(opcode, useHead, payload);
                super._chunkDispatch(useHead, rawHead);
                super._chunkDispatch(payload, buffer);
                this.wsStatHeadChunks++;
            }
            this.wsStatFrameL64++;
        }
    }

    /**
     * @param {number} minSize
     * @return {!Buffer}
     * @override
     */
    _chunkAllocate(minSize) {
        const rawChunk = super._chunkAllocate(minSize ? minSize + this._WS_HEAD_RSV : 0);
        const resChunk = rawChunk.slice(this._WS_HEAD_RSV);
        this._wsRawMap.set(resChunk, rawChunk);
        return resChunk;
    }

    /**
     * @param {!Buffer} useChunk
     * @param {?Buffer} resChunk
     * @override
     */
    _chunkDispatch(useChunk, resChunk) {
        if (resChunk) {
            const rawChunk = this._wsRawMap.get(resChunk);
            if (rawChunk) {
                this._wsRawMap.delete(resChunk);
                this.wsSend(WS_OP_BINARY, useChunk, rawChunk, this._WS_HEAD_RSV);
            } else {
                this.wsSend(WS_OP_BINARY, useChunk);
            }
        } else {
            this.wsSend(WS_OP_BINARY, useChunk);
        }
    }

}

/**
 * @private
 */
class WsConnection extends TcpConnection {

    /**
     * @param {!ConnectOptions} options
     * @param {!Socket} socket
     * @param {!WsReader} reader
     * @param {!WsWriter} writer
     */
    constructor(options, socket, reader, writer) {
        super(options, socket, reader, writer);

        /**
         * @type {number}
         * @private
         */
        this._wsStatPingSent = 0;

        /**
         * @type {number}
         * @private
         */
        this._wsStatPingReceived = 0;

        /**
         * @type {number}
         * @private
         */
        this._wsStatPongReceived = 0;

        /**
         * @type {number}
         * @private
         */
        this._wsCloseCode = 1000;

        /**
         * @type {!WsReader}
         * @private
         */
        this._wsReader = reader;

        /**
         * @type {!WsWriter}
         * @private
         */
        this._wsWriter = writer;

        /**
         * web socket event: ping
         */
        this._wsReader
            .on('ws_ping', (payload) => this._onWsPeerPing(payload))
            .on('ws_pong', (payload) => this._onWsPeerPong(payload))
            .on('ws_close', (payload) => this._onWsPeerClose(payload))
        ;

    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * @param {?Buffer} payload
     */
    wsPing(payload) {
        this._wsWriter.wsSend(WS_OP_PING, payload ? payload : Buffer.allocUnsafe(0));
        this._wsStatPingSent += 1;
    }

    /**
     * @param {Buffer} payload
     * @private
     */
    _onWsPeerPing(payload) {
        this._wsStatPingReceived += 1;
        this._wsWriter.wsSend(WS_OP_PONG, payload);
        this.idle(false);
        this.emit('ws_ping', payload);
    }

    /**
     * @param {Buffer} payload
     * @private
     */
    _onWsPeerPong(payload) {
        this._wsStatPongReceived += 1;
        this.emit('ws_pong', payload);
    }

    /**
     * @param {Buffer} payload
     * @private
     */
    _onWsPeerClose(payload) {
        this.end(null);

        const code = payload.length > 1 ? payload.readInt16BE(0) : undefined;
        const info = payload.length > 2 ? payload.toString('utf8', 2) : '';
        if (code !== 1000) this.emit('error', ErrMsg(EC.WS_CLOSE_ERROR, code, info));
        this.emit('ws_close', code, info);
    }

    /**
     * @override
     */
    _onBeforeEnd() {
        const rc = this._wsCloseCode;
        const tx = WS_CLOSE_CODES[rc];

        const len = tx ? Buffer.byteLength(tx) : 0;
        const buf = Buffer.allocUnsafe(2 + len);
        buf.writeInt16BE(rc, 0);
        if (len) buf.write(tx, 2, len, 'utf8');

        this._wsWriter.encoder.flush(); // protocol data
        this._wsWriter.wsSend(WS_OP_CLOSE, buf);
    }

    /**
     * @typedef {Object} WsConnectionStatistics
     * @property {number} inboundPingRequests - The amount of received ping requests
     * @property {number} outboundPingRequests - The amount of sent ping requests
     * @property {number} inboundPongRequests - The amount of sent pong requests
     * @property {number} outboundHeadChunks - The amount of chunks used for web socket header only (no space reserved in data chunk).
     * @property {number} inboundFrames125 - The amount of web socket frames received with up to 125 bytes.
     * @property {number} outboundFrames125 - The amount of web socket frames sent with up to 125 bytes.
     * @property {number} inboundFramesL16 - The amount of web socket frames received with up to 2^16 bytes.
     * @property {number} outboundFramesL16 - The amount of web socket frames sent with up to 2^16 bytes.
     * @property {number} inboundFramesL64 - The amount of web socket frames received with more than 2^64 bytes.
     * @property {number} outboundFramesL64 - The amount of web socket frames sent with more than 2^64 bytes.
     */

    /**
     * @return {!TcpConnectionStatistics}
     * @override
     */
    statistics() {
        const result = super.statistics();
        result.ws = {
            inboundPingRequests : this._wsStatPingReceived,
            outboundPingRequests : this._wsStatPingSent,
            inboundPongRequests : this._wsStatPongReceived,
            outboundHeadChunks: this._wsWriter.wsStatHeadChunks,
            inboundFrames125: this._wsReader.wsStatFrame125,
            outboundFrames125: this._wsWriter.wsStatFrame125,
            inboundFramesL16: this._wsReader.wsStatFrameL16,
            outboundFramesL16: this._wsWriter.wsStatFrameL16,
            inboundFramesL64: this._wsReader.wsStatFrameL64,
            outboundFramesL64: this._wsWriter.wsStatFrameL64
        };
        return result;
    }

}

/**
 * @abstract
 * @private
 */
class WsServer extends TcpServer {

    /**
     * @param {ServerOptions} options
     * @param {string} type
     * @param {*} server
     */
    constructor(options, type, server) {
        super(options);

        /**
         * @type {http.Server}
         */
        this._server = server;

        /**
         * set event handler
         */
        this._server
            .on('clientError', (error, socket) => this._onClientError(error, socket))
            .on('error', (error) => this._onError(error))
            .on('listening', () => this._onListening(type, this._server.address()))
            .on('request', (request, response) => response.end(createErrorResponse(404), 'ascii'))
            .on('upgrade', (request, socket, head) => this._onUpgrade(request, socket, head))
        ;
    }

    /**
     * @param {Error} error
     * @param {*} socket
     * @private
     */
    _onClientError(error, socket) {
        if (!socket.destroyed)
            socket.end(createErrorResponse(400), 'ascii');
        this._onError(error);
    }

    /**
     * @param {*} request
     * @param {*} socket
     * @param {Buffer} head
     * @private
     */
    _onUpgrade(request, socket, head) {
        try {
            const reply = acceptUpgradeRequest(request);
            const auth = request.headers.authorization;
            const [type, cred] = typeof auth === 'string' ? auth.split(' ', 2) : ['', ''];
            const data = {};

            switch(type) {
                case 'Bearer': {
                    data.token = cred;
                    break;
                }
                case 'Basic': {
                    // noinspection JSCheckFunctionSignatures
                    const [user, pwd] = Buffer.from(cred, 'base64').toString('ascii').split(':', 2);
                    data.user = user;
                    data.password = pwd;
                    break;
                }
            }

            if(!this.emit('authenticate', type, data, request, (error) => this._onAuthenticate(error, reply, socket))) {
                socket.end(createErrorResponse(500), 'ascii');
            }
        } catch(e) {
            socket.end(createErrorResponse(400), 'ascii');
        }
    }

    /**
     * @param {Error} error
     * @param {Object} reply
     * @param {*} socket
     * @private
     */
    _onAuthenticate(error, reply, socket) {
        if (error) {
            socket.end(createErrorResponse(401), 'ascii');
            this._onError(error);
        } else {
            this.emit('connection', socket);
            socket.write(createUpgradeResponse(reply), 'ascii');
        }
    }

    /**
     * @override
     */
    close() {
        this._server.close((error) => this._onClose(error));
    }

}

/**
 * @private
 */
class WsSecureServer extends WsServer {

    /**
     * @param {!ServerOptions} options
     */
    constructor(options) {
        super(options, 'wss', https.createServer(filterHeaderFields(options.wss, {port:null, host:null, backlog:null})));
    }

    /**
     * @override
     */
    listen() {
        const opt = this.options.wss;
        this._server.listen(opt.port, opt.host, opt.backlog);
    }

}

/**
 * @private
 */
class WsSimpleServer extends WsServer {

    /**
     * @param {!ServerOptions} options
     */
    constructor(options) {
        super(options, 'ws', http.createServer());
    }

    /**
     * @override
     */
    listen() {
        const opt = this.options.ws;
        this._server.listen(opt.port, opt.host, opt.backlog);
    }

}

/**
 * @param {!Object} data
 * @param {!Object} compare
 * @private
 */
function acceptHeaderFields(data, compare) {
    const fields = Object.getOwnPropertyNames(compare);
    for (const key of fields) {
        const cmp = compare[key], val = data[key.toLowerCase()];
        if (typeof cmp === 'string' && val === cmp)
            continue;
        if (typeof cmp === 'object' && val !== '' && val.search(cmp) > -1)
            continue;
        throw ErrMsg(EC.WS_UPGRADE_HEADER_MISSING, key);
    }
}

/**
 * @param {number} code
 * @return {string}
 * @private
 */
function createErrorResponse(code) {
    return 'HTTP/1.1 ' + code + ' ' + http.STATUS_CODES[code] + '\r\n\r\n';
}

/**
 * @param {!Object} headers
 * @return {string}
 * @private
 */
function createUpgradeResponse(headers) {
    let s = 'HTTP/1.1 101 Web Socket Protocol Handshake\r\n';
    for (const key of Object.getOwnPropertyNames(headers)) {
        s += key + ':' + headers[key] + '\r\n';
    }
    return s + '\r\n';
}

/**
 * @param {*} request
 * @return {Object}
 * @private
 */
function acceptUpgradeRequest(request) {
    acceptHeaderFields(request.headers, {
        'Upgrade'                : 'websocket',
        'Connection'             : /(^|, |,)Upgrade($| ,|,)/,
        'Sec-WebSocket-Version'  : '13',
        'Sec-WebSocket-Protocol' : new RegExp(`(^|, |,)${PROTOCOL}($| ,|,)`)
    });

    const key = request.headers['sec-websocket-key'];
    const sha1 = crypto.createHash('sha1');
    sha1.update(key + WS_ACCEPT_SUFFIX, 'ascii');

    return {
        'Upgrade'                : 'websocket',
        'Connection'             : 'Upgrade',
        'Sec-Websocket-Accept'   : sha1.digest('base64'),
        'Sec-WebSocket-Protocol' : PROTOCOL
    };
}

/**
 * @param {!{headers:{}, host:string, port:number}} options
 * @param {!{}} fields
 * @returns {!Object}
 * @private
 */
function createUpgradeRequest(options, fields) {
    const headers = Object.assign({
        'User-Agent'             : USER_AGENT,
        'Host'                   : options.host + ':' + options.port,
        'Upgrade'                : 'websocket',
        'Connection'             : 'Upgrade',
        'Sec-WebSocket-Key'      : crypto.randomBytes(16).toString('base64'),
        'Sec-WebSocket-Version'  : '13',
        'Sec-WebSocket-Protocol' : PROTOCOL
    }, fields);

    const params = Object.assign({}, options);
    params.method = 'GET';
    params.headers = Object.assign(filterHeaderFields(options.headers, headers), headers);

    return params;
}

/**
 * @param {*} request
 * @param {*} response
 * @returns {boolean}
 * @private
 */
function acceptKeyValid(request, response) {
    const sha1 = crypto.createHash('sha1');
    sha1.update(request.getHeader('sec-websocket-key') + WS_ACCEPT_SUFFIX, 'ascii');
    return response.headers['sec-websocket-accept'] === sha1.digest('base64');
}

/**
 * @param {!Object} data
 * @param {!Object} compare
 * @private
 */
function filterHeaderFields(data, compare) {
    const result = {};
    const filter = Object.getOwnPropertyNames(compare).map((key) => {
        return key.toLowerCase();
    });
    const fields = Object.getOwnPropertyNames(data);
    for (const key of fields) {
        if (!filter.includes(key.toLowerCase())) result[key] = data[key];
    }
    return result;
}

/**
 * @param {*} request
 * @param {!ClientOptions} options
 * @param {!NotifyOfConnect} done
 * @param {!NotifyOfFailed} failed
 * @private
 */
function connect(request, options, done, failed) {
    request
        .once('upgrade', (response, socket /**, head */) => {
            if (acceptKeyValid(request, response)) {
                try {
                    request.removeAllListeners();
                    done(new WsConnection(options, socket, new WsReader(options.tune, false), new WsWriter(options.tune, socket, true)));
                } catch(e) {
                    failed(e);
                }
            } else {
                socket.destroy();
                failed(ErrMsg(EC.WS_UPGRADE_ACCEPT_MISMATCH));
            }
        })
        .once('response', (response) => {
            let buffer = '';
            response.setEncoding('utf8');
            response
                .on('data', (chunk) => {
                    buffer += chunk;
                })
                .on('end', () => {
                    failed(ErrMsg(EC.WS_UPGRADE_REQUEST_FAILED, response.statusCode, response.statusMessage, buffer.replace(/\n*$/, '')));
                });
        })
        .once('error', (error) => {
            failed(error);
        })
        .once('aborted', () => {
            failed(ErrMsg(EC.WS_UPGRADE_REQUEST_ABORTED));
        });
    request.end();
}

/**
 * @param {!Socket} socket
 * @param {!ConnectOptions} options
 * @return {!TcpConnection}
 * @private
 */
function srvAccept(socket, options) {
    return new WsConnection(options, socket, new WsReader(options.tune, true), new WsWriter(options.tune, socket, false));
}

/**
 * @param {ServerOptions} options
 * @return {TcpServer}
 * @private
 */
function tlsServer(options) {
    return new WsSecureServer(options);
}

/**
 * @param {ServerOptions} options
 * @return {TcpServer}
 * @private
 */
function netServer(options) {
    return new WsSimpleServer(options);
}

/**
 * @param {!ClientOptions} options
 * @param {!Object} headers
 * @param {!NotifyOfConnect} done
 * @param {!NotifyOfFailed} failed
 * @private
 */
function tlsConnect(options, headers, done, failed) {
    connect(https.request(createUpgradeRequest(options.wss, headers)), options, done, failed);
}

/**
 * @param {!ClientOptions} options
 * @param {!Object} headers
 * @param {!NotifyOfConnect} done
 * @param {!NotifyOfFailed} failed
 * @private
 */
function netConnect(options, headers, done, failed) {
    connect(http.request(createUpgradeRequest(options.ws, headers)), options, done, failed);
}

module.exports = {
    WsReader : WsReader,
    WsWriter : WsWriter,
    tlsServer : tlsServer,
    netServer : netServer,
    tlsAccept : srvAccept,
    netAccept : srvAccept,
    tlsConnect : tlsConnect,
    netConnect : netConnect
};

