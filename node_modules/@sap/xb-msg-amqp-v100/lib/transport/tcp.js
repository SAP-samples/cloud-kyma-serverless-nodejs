'use strict';

const EventEmitter = require('events');
const tls = require('tls');
const net = require('net');

const { Writable, Transform } = require('stream');
const { Encoder } = require('../serialize/encoder');
const { Decoder } = require('../serialize/decoder');

/**
 * @typedef {Object} ConnectOptions
 * @property {ProtocolSettings} amqp - Protocol specific settings
 * @property {StreamParameters} tune - Fine tuning
 * @private
 */

/**
 * @callback NotifyOfConnect
 * @param {!TcpConnection} connection
 * @private
 */

/**
 * @callback NotifyOfTimeout
 * @param {number} timeout
 * @return {number}
 * @private
 */

/**
 * @param {*=} result
 * @return {*}
 * @private
 */
function nop(result) { return result; }

/**
 * @private
 */
class TcpReader extends Transform {

    /**
     * @param {!StreamParameters} options
     */
    constructor(options) {

        super({
            decodeStrings: false,
            allowHalfOpen: false,
            highWaterMark: undefined,
            writableObjectMode: false,
            writableHighWaterMark: options.istreamHighWaterBytes,  // as of nodeJS 8, fixed in Aug 2017
            readableObjectMode: true,
            readableHighWaterMark: options.istreamHighWaterFrames, // as of nodeJS 8, fixed in Aug 2017
        });

        /**
         * @type {Decoder}
         */
        this.decoder = new Decoder(options,
            (frame) => this.push(frame)
        );

    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * @param {!Buffer} chunk
     * @param {!string} encoding
     * @param {!function(Error=, Frame=)} callback
     * @override
     */
    _transform(chunk, encoding, callback) {
        try {
            this._decode(chunk);
            callback();
        } catch (e) {
            this.decoder.stop();
            callback(e);
        }
    }

    /**
     * @param {!Buffer} chunk
     * @abstract
     */
    _decode(chunk) {
        this.decoder.push(chunk);
    }

}

/**
 * @private
 */
class TcpWriter extends Writable {

    /**
     * @param {!StreamParameters} options
     * @param {!Socket} socket
     */
    constructor(options, socket) {

        super({
            highWaterMark: options.ostreamHighWaterFrames,
            decodeStrings: false,
            objectMode: true,
        });

        /**
         * @type {number}
         */
        this.statChunkDefAllocCount = 0;

        /**
         * @type {number}
         */
        this.statChunkBigAllocCount = 0;

        /**
         * @type {number}
         */
        this.statChunkRecycledCount = 0;

        /**
         * @const {number}
         * @private
         */
        this._chunkDefaultSize = options.ostreamChunkDefaultSize;

        /**
         * @type {number}
         * @private
         */
        this._bytesInFlightCount = 0;

        /**
         * @const {number}
         * @private
         */
        this._bytesInFlightLimit = options.ostreamHighWaterBytes;

        /**
         * @type {boolean}
         * @private
         */
        this._bytesInFlightPause = false;

        /**
         * @const {number}
         * @private
         */
        this._chunkRecycleLimit = options.ostreamChunkRecycleLimit;

        /**
         * @type {!Array<!Buffer>}
         * @private
         */
        this._chunkRecycleCache = [];

        /**
         * @type {boolean}
         * @private
         */
        this._nextTickNotActive = true;

        /**
         * @type {!Socket}
         * @private
         */
        this._socket = socket;

        /**
         * @type {!Encoder}
         */
        this.encoder = new Encoder(options,
            (minSize) => this._chunkAllocate(minSize),
            (useChunk, rawChunk) => this._chunkDispatch(useChunk, rawChunk)
        );

        this._socket
            .on('error', () => this._socket.destroyed ? this._onSocketClosed() : undefined)
            .on('close', () => this._onSocketClosed())
        ;

    }

    // noinspection JSUnusedGlobalSymbols, JSUnusedLocalSymbols
    /**
     * @param {!Frame} frame
     * @param {string} encoding
     * @param {function(Error=, Buffer=)} callback
     * @override
     * @final
     */
    _write(frame, encoding, callback) {
        try {
            if (this.encoder.push(frame) && this._nextTickNotActive) {
                this._nextTickNotActive = false;
                process.nextTick(() => this._onProcessNextTick());
            }
            if (this._bytesInFlightCount > this._bytesInFlightLimit) {
                this._bytesInFlightPause = true;
            }
            if (this._bytesInFlightPause) {
                this.once('continue', callback);
                return;
            }
            callback();
        } catch (e) {
            this.encoder.stop();
            callback(e);
        }
    }

    /**
     * @private
     */
    _onSocketClosed() {
        this.write = () => nop(false);
        this.encoder.stop();
        this._socket.write = () => nop(false);
        this._onProcessNextTick = nop;
    }

    /**
     * @private
     */
    _onProcessNextTick() {
        try {
            this._nextTickNotActive = true;
            this.encoder.flush();
        } catch (e) {
            this.encoder.stop();
            this.emit('error', e);
        }
    }

    /**
     * @param {number} minSize
     * @return {!Buffer}
     */
    _chunkAllocate(minSize) {
        if (minSize && minSize > this._chunkDefaultSize) {
            ++this.statChunkBigAllocCount;
            return Buffer.allocUnsafe(minSize);
        } else if (this._chunkRecycleCache.length === 0) {
            ++this.statChunkDefAllocCount;
            return Buffer.allocUnsafe(this._chunkDefaultSize);
        } else {
            ++this.statChunkRecycledCount;
            return this._chunkRecycleCache.pop();
        }
    }

    /**
     * @param {!Buffer} useChunk
     * @param {?Buffer} rawChunk
     */
    _chunkDispatch(useChunk, rawChunk) {
        this._bytesInFlightCount += useChunk.length;
        try {
            this._socket.write(useChunk, (error) => this._chunkReleased(error, useChunk, rawChunk));
        } catch(e) {
            this._onSocketClosed();
        }
    }

    /**
     * @param {!Error} error
     * @param {!Buffer} useChunk
     * @param {Buffer} rawChunk
     * @private
     */
    _chunkReleased(error, useChunk, rawChunk) {
        if (error) {
            this._onSocketClosed();
            return;
        }
        if (rawChunk && rawChunk.length === this._chunkDefaultSize && this._chunkRecycleCache.length < this._chunkRecycleLimit) {
            this._chunkRecycleCache.push(rawChunk);
        }
        this._bytesInFlightCount -= useChunk.length;
        if (this._bytesInFlightPause && this._bytesInFlightCount < this._bytesInFlightLimit) {
            this._bytesInFlightPause = false;
            this.emit('continue');
        }
    }

}

/**
 * @private
 */
class TcpConnection extends EventEmitter {

    /**
     * Closed before authenticated.
     * @event TcpConnection#abort
     * @param {boolean} hadError
     * @private
     */

    /**
     * Authenticated successfully.
     * @event TcpConnection#valid
     * @private
     */

    /**
     * Ready for use by protocol layer.
     * @event TcpConnection#ready
     * @private
     */

    /**
     * Idle state, e.g. empty frame was received.
     * @event TcpConnection#idle
     * @private
     */

    /**
     * Error occurred.
     * @event TcpConnection#error
     * @param {Error} error
     * @private
     */

    /**
     * Inbound error requires to close, last chance to end with error frame instead of direct close.
     * @event TcpConnection#assert
     * @param {Error} error
     * @private
     */

    /**
     * Ending without immediate close, last chance to set an individual close timer.
     * @event TcpConnection#final
     * @param {boolean} hadAssert
     * @param {number} closeTimeout
     * @private
     */

    /**
     * Closed finally.
     * @event TcpConnection#close
     * @param {boolean} hadError
     * @private
     */

    /**
     * @param {!ConnectOptions} options
     * @param {Socket} socket
     * @param {!TcpReader} reader
     * @param {!TcpWriter} writer
     */
    constructor(options, socket, reader, writer) {
        super();

        /**
         * @type {ConnectOptions}
         */
        this.options = options;

        /**
         * @type {!number}
         */
        this.statConnectedSince = Date.now();

        /**
         * @type {number}
         */
        this.statInboundDrains = 0;

        /**
         * @type {number}
         */
        this.statOutboundDrains = 0;

        /**
         * @type {boolean}
         * @private
         */
        this._valid = false;

        /**
         * @type {boolean}
         * @private
         */
        this._ready = false;

        /**
         * @type {number}
         * @private
         */
        this._paused = 0;

        /**
         * @type {Error}
         * @private
         */
        this._assert = null;

        /**
         * @type {!Socket}
         */
        this._socket = socket;

        /**
         * @type {!TcpReader}
         */
        this.istream = reader;

        /**
         * @type {!TcpWriter}
         */
        this.ostream = writer;

        /* socket settings */

        if (options.tune.socketNoDelay) {
            this._socket.setNoDelay(true);
        }

        this._socket
            .on('error', (error) => this.emit('error', error))
            .on('end', () => this._socket.destroyed ? undefined : this.close())
            .on('close', (hadError) => this.emit(this._valid ? 'close' : 'abort', hadError))
        ;

        /* istream handler */

        this.istream
            .on('error', (error) => this.assert(error))
            .on('drain', () => this.statInboundDrains += 1)
        ;

        /* ostream handler */

        this.ostream
            .on('error', (error) => this.close(error))
            .on('drain', () => this.statOutboundDrains += 1)
        ;

        this._socket.pipe(this.istream);
    }

    /**
     * @param {boolean} local
     * @return {string}
     */
    host(local = false) {
        // noinspection JSUnresolvedVariable
        return local ? this._socket.localAddress : this._socket.remoteAddress;
    }

    /**
     * @param {boolean} local
     * @return {number}
     */
    port(local = false) {
        // noinspection JSUnresolvedVariable
        return local ? this._socket.localPort : this._socket.remotePort;
    }

    /**
     *
     */
    valid() {
        if (this._valid)
            return;
        this._valid = true;

        process.nextTick(() => {
            if (this._socket.destroyed)
                return;
            this.emit('valid');
        });
    }

    /**
     * @param {number} timeout
     * @param {NotifyOfTimeout} handler
     */
    ready(timeout, handler) {
        if (this._ready)
            return;
        this._ready = true;

        if (timeout && handler) {
            this._socket.on('timeout', () => this._socket.setTimeout(handler(timeout)));
            this._socket.setTimeout(timeout);
        }

        this.istream.cork();
        process.nextTick(() => {
            if (this._socket.destroyed)
                return;
            this.emit('ready');
            this.istream.uncork();
        });
    }

    /**
     * @param {boolean} local
     */
    idle(local) {
        this.emit('idle', local);
    }

    /**
     * @return {boolean}
     */
    paused() {
        return this._paused > 0;
    }

    /**
     *
     */
    pause() {
        this._paused += 1;
        this.istream.cork();
    }

    /**
     *
     */
    resume() {
        this._paused -= 1;
        this.istream.uncork();
    }

    /**
     * @param {Error} error
     */
    assert(error) {
        this._assert = error;
        if (this._valid && this._socket.end !== nop)
            this.emit('assert', error);
        if (this._socket.end !== nop)
            this.close(error);
    }

    /**
     * @param {Frame=} frame
     */
    end(frame = null) {
        try {
            this._socket.removeAllListeners('timeout');
            const timeout = this.options.tune.socketEndCloseTimeout;
            if (timeout > 0) this._socket.setTimeout(timeout, () => this.close());

            this.emit('final', this._assert !== null, timeout);
            if (frame) this.ostream.encoder.push(frame);
            this._onBeforeEnd();

            this.ostream.encoder.flush();
            this.ostream.encoder.stop();
            this.ostream.end();
            this._socket.end();

            this._socket.end = nop;
            this.end = nop;
            this.pause = nop;
            this.resume = nop;
        } catch (e) {
            this._socket.end = nop;
            this.end = nop;
            this.pause = nop;
            this.resume = nop;
        }
    }

    /**
     * @abstract
     */
    _onBeforeEnd() {
    }

    /**
     * @param {Error=} error
     */
    close(error = null) {
        try {
            this.ostream.encoder.stop();
            this.ostream.end();
            this._socket.destroy(error);

            this._socket.end = nop;
            this._socket.destroy = nop;
            this.end = nop;
            this.close = nop;
            this.pause = nop;
            this.resume = nop;
        } catch (e) {
            this._socket.end = nop;
            this._socket.destroy = nop;
            this.end = nop;
            this.close = nop;
            this.pause = nop;
            this.resume = nop;
        }
    }

    /**
     * @typedef {Object} TcpConnectionStatistics
     * @property {Date} connectedSince - The point in time when the connection was established
     * @property {number} inboundHeartbeats - The amount of heartbeats received from the broker since connected.
     * @property {number} outboundHeartbeats -  The amount of heartbeats sent to the broker since connected.
     * @property {number} inboundDrains - The amount of drain events for the inbound stream (after it was throttled).
     * @property {number} outboundDrains - The amount of drain events for the outbound stream (after it was throttled).
     * @property {number} inboundMethods - The amount of methods received.
     * @property {number} outboundMethods - The amount of methods sent.
     * @property {number} inboundBytes - The amount of bytes received.
     * @property {number} outboundBytes - The amount of bytes sent.
     * @property {number} inboundFrames - The amount of frames received.
     * @property {number} outboundFrames - The amount of frames sent.
     * @property {number} inboundChunks - The amount of chunks received.
     * @property {number} outboundChunks - The amount of chunks sent.
     * @property {number} outboundChunksRecycled - The outbound chunk recycle count
     * @property {number} outboundChunksDefAlloc - The amount of allocated chunks using default chunk size
     * @property {number} outboundChunksBigAlloc - The amount of allocated chunks above default chunk size
     * @property {WsConnectionStatistics} ws - The web socket connection statistics (if used)
     */

    /**
     * @return {!TcpConnectionStatistics}
     */
    statistics() {
        return /** @type {TcpConnectionStatistics} */ {
            connectedSince         : this.statConnectedSince,
            inboundDrains          : this.statInboundDrains,
            outboundDrains         : this.statOutboundDrains,
            inboundBytes           : this._socket.bytesRead,
            outboundBytes          : this._socket.bytesWritten,
            inboundFrames          : this.istream.decoder.statFrameCount,
            outboundFrames         : this.ostream.encoder.statFrameCount,
            inboundChunks          : this.istream.decoder.statChunkCount,
            outboundChunks         : this.ostream.encoder.statChunkCount,
            outboundChunksRecycled : this.ostream.statChunkRecycledCount,
            outboundChunksDefAlloc : this.ostream.statChunkDefAllocCount,
            outboundChunksBigAlloc : this.ostream.statChunkBigAllocCount,
        };
    }

}

/**
 * @abstract
 * @private
 */
class TcpServer extends EventEmitter {

    /**
     * @event TcpServer#listening
     * @param {string} address
     * @param {number=} port
     * @param {string=} family
     * @private
     */

    /**
     * @event TcpServer#connection
     * @param {Socket} socket
     * @private
     */

    /**
     * @event TcpServer#error
     * @param {Error} error
     * @private
     */

    /**
     * @event TcpServer#close
     * @param {Error=} error
     * @private
     */

    /**
     * @param {!ServerOptions} options
     */
    constructor(options) {
        super();

        /**
         * @type {ServerOptions}
         */
        this.options = options;
    }

    /**
     * @abstract
     */
    listen() {
    }

    /**
     * @abstract
     */
    close() {
    }

    /**
     * @param {string} type
     * @param {string|object} address
     * @return {boolean}
     */
    _onListening(type, address) {
        if (typeof address === 'object')
            return this.emit('listening', type, address.address, address.port, address.family);
        else
            return this.emit('listening', type, address);
    }

    /**
     * @param {Socket} socket
     */
    _onConnection(socket) {
        this.emit('connection', socket);
    }

    /**
     * @param {Error} error
     */
    _onError(error) {
        this.emit('error', error);
    }

    /**
     * @param {Error=} error
     */
    _onClose(error) {
        this.emit('close', error);
    }

}

/**
 * @private
 */
class TcpSecureServer extends TcpServer {

    /**
     * @param {!ServerOptions} options
     */
    constructor(options) {
        super(options);

        /**
         * @type {Server}
         */
        this._server = tls.createServer(Object.assign({allowHalfOpen : false, pauseOnConnect : false}, options.tls));

        /**
         * set event handler
         */
        this._server
            .on('listening', () => this._onListening('tls', this._server.address()))
            .on('secureConnection', (socket) => this._onConnection(socket))
            .on('error', (error) => this._onError(error))
        ;
    }

    /**
     * @override
     */
    listen() {
        this._server.listen(this.options.tls);
    }

    /**
     * @override
     */
    close() {
        this._server.close((error) => this._onClose(error));
    }

}

/**
 * @private
 */
class TcpSimpleServer extends TcpServer {

    /**
     * @param {!ServerOptions} options
     */
    constructor(options) {
        super(options);

        /**
         * @type {Server}
         */
        this._server = net.createServer(Object.assign({allowHalfOpen : false, pauseOnConnect : false}, options.net));

        /**
         * set event handler
         */
        this._server
            .on('listening', () => this._onListening('net', this._server.address()))
            .on('connection', (socket) => this._onConnection(socket))
            .on('error', (error) => this._onError(error))
        ;
    }

    /**
     * @override
     */
    listen() {
        this._server.listen(this.options.net);
    }

    /**
     * @override
     */
    close() {
        this._server.close((error) => this._onClose(error));
    }

}

/**
 * @param {ServerOptions} options
 * @return {TcpServer}
 * @private
 */
function tlsServer(options) {
    return new TcpSecureServer(options);
}

/**
 * @param {ServerOptions} options
 * @return {TcpServer}
 * @private
 */
function netServer(options) {
    return new TcpSimpleServer(options);
}

/**
 * @param {Socket} socket
 * @param {ConnectOptions} options
 * @return {TcpConnection}
 * @private
 */
function srvAccept(socket, options) {
    return new TcpConnection(options, socket, new TcpReader(options.tune), new TcpWriter(options.tune, socket));
}

/**
 * @param {!ClientOptions} options
 * @param {!NotifyOfConnect} done
 * @param {!NotifyOfFailed} failed
 * @private
 */
function tlsConnect(options, done, failed) {
    const socket = tls.connect(options.tls, () => {
        try {
            socket.removeListener('error', failed);
            done(new TcpConnection(options, socket, new TcpReader(options.tune), new TcpWriter(options.tune, socket)));
        } catch(e) {
            failed(e);
        }
    });
    socket.once('error', failed);
}

/**
 * @param {!ClientOptions} options
 * @param {!NotifyOfConnect} done
 * @param {!NotifyOfFailed} failed
 * @private
 */
function netConnect(options, done, failed) {
    const socket = net.connect(options.net, () => {
        try {
            socket.removeListener('error', failed);
            done(new TcpConnection(options, socket, new TcpReader(options.tune), new TcpWriter(options.tune, socket)));
        } catch(e) {
            failed(e);
        }
    });
    socket.once('error', failed);
}

module.exports = {
    TcpReader : TcpReader,
    TcpWriter : TcpWriter,
    TcpConnection : TcpConnection,
    TcpServer : TcpServer,
    tlsServer : tlsServer,
    netServer : netServer,
    tlsAccept : srvAccept,
    netAccept : srvAccept,
    tlsConnect : tlsConnect,
    netConnect : netConnect
};

