'use strict';

const { EC, ErrMsg, ErrOpt } = require('../errors');
const { Payload, Composite, Serializable } = require('../serialize/types');

const constants = require('../serialize/constants');
const JSYM_DESCRIPTOR = constants.RUNTIME.SYMBOL.DESCRIPTOR;
const SIMPLE = constants.CONSTRUCT.PRIMITIVE.SIMPLE;
const COMPLEX = constants.CONSTRUCT.PRIMITIVE.COMPLEX;
const NULL = SIMPLE.NULL;
const ULONG = SIMPLE.ULONG;
const UUID = SIMPLE.UUID;
const BIN8 = SIMPLE.BIN8;
const BIN32 = SIMPLE.BIN32;
const STR8 = SIMPLE.STR8;
const STR32 = SIMPLE.STR32;
const SYM8 = SIMPLE.SYM8;
const SYM32 = SIMPLE.SYM32;
const LIST0 = COMPLEX.LIST0;
const LIST8 = COMPLEX.LIST8;
const LIST32 = COMPLEX.LIST32;

const SIMPLE_TYPES = new Set([]); Object.getOwnPropertyNames(SIMPLE).forEach((key)=>{SIMPLE_TYPES.add(SIMPLE[key]);});
const MSG_ID_TYPES = new Set([NULL, ULONG, UUID, BIN8, BIN32, STR8, STR32]);
const ANNO_KEY_TYPES = new Set([ULONG, SYM8, SYM32]);
const SEQ_DATA_TYPES = new Set([LIST0, LIST8, LIST32]);

const MSG_HEADER = constants.DESCRIPTOR.MESSAGE.HEADER;
const DEL_ANNO = constants.DESCRIPTOR.MESSAGE.ANNOTATIONS.DELIVERY;
const MSG_ANNO = constants.DESCRIPTOR.MESSAGE.ANNOTATIONS.MESSAGE;
const MSG_PROP = constants.DESCRIPTOR.MESSAGE.PROPERTIES.IMMUTABLE;
const APP_PROP = constants.DESCRIPTOR.MESSAGE.PROPERTIES.APPLICATION;
const BIN_DATA = constants.DESCRIPTOR.MESSAGE.DATA.BINARY;
const SEQ_DATA = constants.DESCRIPTOR.MESSAGE.DATA.SEQUENCE;
const VAL_DATA = constants.DESCRIPTOR.MESSAGE.DATA.VALUE;
const MSG_FOOTER = constants.DESCRIPTOR.MESSAGE.FOOTER;

const CT_AMQP10 = constants.VALUE.TRANSFER.CONTENT_TYPE.AMQP;

/**                                                        Bare Message
 *                                                               |
 *                                         .---------------------+--------------------.
 *                                         |                                          |
 *    +--------+-------------+-------------+------------+--------------+--------------+-------------+
 *    | header | delivery-   | message-    | properties | application- | application- | footer      |
 *    |        | annotations | annotations |            | properties   | data         |             |
 *    +--------+-------------+-------------+------------+--------------+--------------+-------------+
 *    |                                                                                             |
 *    '-------------------------------------------+-------------------------------------------------'
 *                                                |
 *                                         Annotated Message
 *
 *                                      Decoded Message Object
 *                                                |
 *    +--------+-------------+-------------+------------+-----------------------------+-------------+
 *    | header | delivery    | annotations | properties |           payload           | footer      |
 *    |  class |  Map<Sym,*> |  Map<Sym,*> |      class |             class           |  Map<Sym,*> |
 *    +--------+-------------+-------------+------------+--------------+--------------+-------------+
 *                                                      | properties   | chunks       |
 *                                                      |    Object    | Array<Buffer>|
 *                                                      '--------------+--------------'
 *                                                                     |
 *                                                                     +--- data (=== decoded chunks)
 *                                                                     +--- type (=== mime type or 'amqp-1.0'
 *                                                                     +--- encoding
 */

/**
 * @private
 * @final
 */
class Message extends Serializable {

    /**
     *
     */
    constructor() {
        super();

        /**
         * @type {MessageHeader}
         */
        this.header = null;

        /**
         * @type {MessageAnnotations}
         */
        this.delivery = null;

        /**
         * @type {MessageAnnotations}
         */
        this.annotations = null;

        /**
         * @type {MessageProperties}
         */
        this.properties = null;

        /**
         * @type {MessagePayload}
         */
        this.payload = null;

        /**
         * @type {MessageAnnotations}
         */
        this.footer = null;

    }

    /**
     * @param {!Encoder} encoder
     * @override
     */
    encodeData(encoder) {
        if (this.header) {
            encoder.valueComposite(/** @type{!Composite} */ (this.header));
        }

        if (this.delivery) {
            encoder.writeDescriptor(DEL_ANNO);
            encoder.valueAnyMap(this.delivery,
                (value) => encoder.writeValue(true, ANNO_KEY_TYPES, value),
                (value) => encoder.writeValue(false, null, value)
            );
        }

        if (this.annotations) {
            encoder.writeDescriptor(MSG_ANNO);
            encoder.valueAnyMap(this.annotations,
                (value) => encoder.writeValue(true, ANNO_KEY_TYPES, value),
                (value) => encoder.writeValue(false, null, value)
            );
        }

        if (this.payload && typeof this.payload === 'object') {
            const p = (this.properties && typeof this.properties == 'object') ? this.properties : new MessageProperties();
            const pty = !p.contentType && this.payload.type && this.payload.type !== CT_AMQP10;
            const pec = !p.contentEncoding && this.payload.encoding;

            if (pty) p.contentType = this.payload.type;
            if (pec) p.contentEncoding = this.payload.encoding;
            if (pty || pec) this.properties = p;
        }
        if (this.properties) {
            encoder.valueComposite(/** @type{!Composite} */ (this.properties));
        }

        if (this.payload) {
            const payload = this.payload;
            if (Buffer.isBuffer(payload)) {
                encoder.writeDescriptor(BIN_DATA);
                encoder.valueBinary(payload);
            } else if (Array.isArray(payload) && payload.every(item => Buffer.isBuffer(item))) {
                encoder.writeDescriptor(BIN_DATA);
                encoder.valueBinaryArray(payload);
            } else if (payload && typeof payload === 'object') {
                if (payload.properties && typeof payload.properties === 'object') {
                    encoder.writeDescriptor(APP_PROP);
                    encoder.valueObjMap(payload.properties,
                        (value) => encoder.writeString(true, value),
                        (value) => encoder.writeValue(false, SIMPLE_TYPES, value)
                    );
                }

                if (payload.chunks && !(Array.isArray(payload.chunks) && payload.chunks.every(item => Buffer.isBuffer(item)))) {
                    throw ErrMsg(EC.ENCODE_INV_PAYLOAD_CHUNKS, typeof payload.chunks === 'object' ? payload.chunks.constructor.name : payload.chunks );
                }

                if (payload.type !== CT_AMQP10) {
                    encoder.writeDescriptor(BIN_DATA);
                    encoder.valueBinaryArray(payload.chunks ? payload.chunks : []);
                } else if (payload.chunks && payload.chunks.length) {
                    for (const buf of payload.chunks) if (buf) encoder.writeDataBlob(buf);
                } else if (Array.isArray(payload.data) && payload.data[JSYM_DESCRIPTOR] === SEQ_DATA) {
                    encoder.valueAnyRestricted(payload.data, SEQ_DATA_TYPES);
                } else if (Array.isArray(payload.data) && payload.data.every(item => Array.isArray(item) && item[JSYM_DESCRIPTOR] === SEQ_DATA)) {
                    for (const s of payload.data) encoder.valueAnyRestricted(s, SEQ_DATA_TYPES);
                } else if (typeof payload.data === 'object') {
                    payload.data[JSYM_DESCRIPTOR] = VAL_DATA;
                    encoder.valueAny(payload.data);
                } else {
                    encoder.writeDescriptor(VAL_DATA);
                    encoder.valueAny(payload.data);
                }
            } else {
                throw ErrMsg(EC.ENCODE_INV_PAYLOAD_TYPE, typeof this.payload === 'object' ? this.payload.constructor.name : this.payload );
            }
        }

        if (this.footer) {
            encoder.writeDescriptor(MSG_FOOTER);
            encoder.valueAnyMap(this.footer,
                (value) => encoder.writeValue(true, ANNO_KEY_TYPES, value),
                (value) => encoder.writeValue(false, null, value)
            );
        }
    }

    /**
     * @param {!Decoder} decoder
     * @override
     */
    decodeData(decoder) {
        const readAnnoKey = () => decoder.readValue(true, null, ANNO_KEY_TYPES);
        const readAnnoVal = () => decoder.readValue(false, null, null);
        const readPropKey = () => decoder.readString(true, null);
        const readPropVal = () => decoder.readValue(false, null, SIMPLE_TYPES);

        let desc, last, type;
        const marker = decoder.initStreamMarker();
        while (decoder.bytesExpected > decoder.bytesConsumed) {
            desc = decoder.readDescriptor(false, false);
            switch(desc) {
                case MSG_HEADER: {
                    this.header = /**@type{MessageHeader}*/(decoder.readCompositeValue(new MessageHeader()));
                    marker(null);
                    break;
                }
                case DEL_ANNO: {
                    this.delivery = decoder.readAnyMap(false, null, readAnnoKey, readAnnoVal);
                    marker(null);
                    break;
                }
                case MSG_ANNO: {
                    this.annotations = decoder.readAnyMap(false, null, readAnnoKey, readAnnoVal);
                    marker(null);
                    break;
                }
                case MSG_PROP: {
                    this.properties = /**@type{MessageProperties}*/(decoder.readCompositeValue(new MessageProperties()));
                    marker(null);
                    break;
                }
                case APP_PROP: {
                    if (this.payload === null) {
                        this.payload = new Payload();
                    } else if (this.payload.properties) {
                        throw ErrMsg(EC.DECODE_INV_MESSAGE_DATA_2ND, decoder.bytesConsumed, desc);
                    }
                    this.payload.properties = decoder.readObjMap(false, null, readPropKey, readPropVal);
                    marker(null);
                    break;
                }
                case BIN_DATA: {
                    if (this.payload === null)
                        this.payload = new Payload();
                    else if (last && desc !== last)
                        throw ErrMsg(EC.DECODE_INV_MESSAGE_DATA, decoder.bytesConsumed, desc, last);
                    last = desc;

                    type = decoder.readDataUInt8();
                    switch(type){
                        case BIN8:
                            decoder.readDataBlobArray(this.payload.chunks, decoder.readDataUInt8());
                            break;
                        case BIN32:
                            decoder.readDataBlobArray(this.payload.chunks, decoder.readDataUInt32());
                            break;
                        case NULL:
                            break;
                        default:
                            throw ErrMsg(EC.DECODE_CODE_UNEXPECTED, decoder.bytesConsumed, type, ErrOpt(BIN8, BIN32));
                    }
                    marker(null);
                    break;
                }
                case SEQ_DATA: {
                    if (this.payload === null)
                        this.payload = new Payload();
                    else if (last && desc !== last)
                        throw ErrMsg(EC.DECODE_INV_MESSAGE_DATA, decoder.bytesConsumed, desc, last);
                    last = desc;
                    this.payload.type = CT_AMQP10;

                    if (this.payload.data === null) {
                        this.payload.data = decoder.readValue(true, null, SEQ_DATA_TYPES);
                        this.payload.data[JSYM_DESCRIPTOR] = SEQ_DATA;
                    } else if (this.payload.data[JSYM_DESCRIPTOR] === SEQ_DATA) {
                        this.payload.data = [this.payload.data];
                        this.payload.data.push(decoder.readValue(true, null, SEQ_DATA_TYPES));
                    } else {
                        this.payload.data.push(decoder.readValue(true, null, SEQ_DATA_TYPES));
                    }

                    marker(this.payload.chunks);
                    break;
                }
                case VAL_DATA: {
                    if (this.payload === null)
                        this.payload = new Payload();
                    else if (last && last !== desc)
                        throw ErrMsg(EC.DECODE_INV_MESSAGE_DATA, decoder.bytesConsumed, desc, last);
                    else if (last)
                        throw ErrMsg(EC.DECODE_INV_MESSAGE_DATA_2ND, decoder.bytesConsumed, desc);
                    last = desc;
                    this.payload.type = CT_AMQP10;

                    this.payload.data = decoder.readValue(false, null, null);
                    if (typeof this.payload.data === 'object') this.payload.data[JSYM_DESCRIPTOR] = VAL_DATA;

                    marker(this.payload.chunks);
                    break;
                }
                case MSG_FOOTER: {
                    this.footer = decoder.readAnyMap(false, null, readAnnoKey, readAnnoVal);
                    marker(null);
                    break;
                }
                default: {
                    throw ErrMsg(EC.DECODE_INV_MESSAGE_SECTION, desc);
                }
            }
        }

        if (this.properties && this.payload) {
            if (!this.payload.type && this.properties.contentType) this.payload.type = this.properties.contentType;
            if (!this.payload.encoding && this.properties.contentEncoding) this.payload.encoding = this.properties.contentEncoding;
        }

        return true;
    }

}

/**
 * @private
 * @final
 */
class MessageHeader extends Composite {

    /**
     *
     */
    constructor() {
        super(MSG_HEADER);

        /**
         * @type {?Bool}
         */
        this.durable = null;

        /**
         * @type {?UByte}
         */
        this.priority = null;

        /**
         * @type {?Milliseconds}
         */
        this.ttl = null;

        /**
         * @type {?Bool}
         */
        this.firstAcquirer = null;

        /**
         * @type {?UInt}
         */
        this.deliveryCount = null;
    }

    /**
     * @returns {!FormatCode}
     * @override
     */
    defineComp() {
        return LIST8;
    }

    /**
     * @param {!Encoder} encoder
     * @return {!FieldCount}
     * @override
     */
    encodeComp(encoder) {
        encoder.writeBool(false, this.durable);
        encoder.writeUByte(false, this.priority);
        encoder.writeUInt(false, this.ttl);
        encoder.writeBool(false, this.firstAcquirer);
        encoder.writeUInt(false, this.deliveryCount);
        return 5;
    }

    /**
     * @param {!Decoder} decoder
     * @param {BlockCountCheck=} scope
     * @override
     */
    decodeComp(decoder, scope) {
        this.durable = decoder.readBool(false, scope);
        this.priority = decoder.readUByte(false, scope);
        this.ttl = decoder.readUInt(false, scope);
        this.firstAcquirer = decoder.readBool(false, scope);
        this.deliveryCount = decoder.readUInt(false, scope);
    }

}

/**
 * @private
 * @final
 */
class MessageProperties extends Composite {

    /**
     *
     */
    constructor() {
        super(MSG_PROP);

        /**
         * @type {?MessageID}
         */
        this.messageID = null;

        /**
         * @type {?BinaryValue}
         */
        this.userID = null;

        /**
         * @type {?AddressString}
         */
        this.to = null;

        /**
         * @type {?StringValue}
         */
        this.subject = null;

        /**
         * @type {?AddressString}
         */
        this.replyTo = null;

        /**
         * @type {?MessageID}
         */
        this.correlationID = null;

        /**
         * @type {?SymbolValue}
         */
        this.contentType = null;

        /**
         * @type {?SymbolValue}
         */
        this.contentEncoding = null;

        /**
         * @type {?Timestamp}
         */
        this.absoluteExpiryTime = null;

        /**
         * @type {?Timestamp}
         */
        this.creationTime = null;

        /**
         * @type {?StringValue}
         */
        this.groupID = null;

        /**
         * @type {?SequenceNumber}
         */
        this.groupSequence = null;

        /**
         * @type {?StringValue}
         */
        this.replyToGroupID = null;

    }

    /**
     * @returns {!FormatCode}
     * @override
     */
    defineComp() {
        return LIST32;
    }

    /**
     * @param {!Encoder} encoder
     * @return {!FieldCount}
     * @override
     */
    encodeComp(encoder) {
        encoder.writeValue(false, MSG_ID_TYPES, this.messageID);
        encoder.writeBinary(false, this.userID);
        encoder.writeString(false, this.to);
        encoder.writeString(false, this.subject);
        encoder.writeString(false, this.replyTo);
        encoder.writeValue(false, MSG_ID_TYPES, this.correlationID);
        encoder.writeSymbol(false, this.contentType);
        encoder.writeSymbol(false, this.contentEncoding);
        encoder.writeTimestamp(false, this.absoluteExpiryTime);
        encoder.writeTimestamp(false, this.creationTime);
        encoder.writeString(false, this.groupID);
        encoder.writeUInt(false, this.groupSequence);
        encoder.writeString(false, this.replyToGroupID);
        return 13;
    }

    /**
     * @param {!Decoder} decoder
     * @param {BlockCountCheck=} scope
     * @override
     */
    decodeComp(decoder, scope) {
        this.messageID = decoder.readValue(false, scope, MSG_ID_TYPES);
        this.userID = decoder.readBinary(false, scope);
        this.to = decoder.readString(false, scope);
        this.subject = decoder.readString(false, scope);
        this.replyTo = decoder.readString(false, scope);
        this.correlationID = decoder.readValue(false, scope, MSG_ID_TYPES);
        this.contentType = decoder.readSymbol(false, scope);
        this.contentEncoding = decoder.readSymbol(false, scope);
        this.absoluteExpiryTime = decoder.readTimestamp(false, scope);
        this.creationTime = decoder.readTimestamp(false, scope);
        this.groupID = decoder.readString(false, scope);
        this.groupSequence = decoder.readUInt(false, scope);
        this.replyToGroupID = decoder.readString(false, scope);
    }

}

module.exports = {
    Message : Message,
    MessageHeader : MessageHeader,
    MessageProperties : MessageProperties
};

