'use strict';

const EventEmitter = require('events');
const {Begin, End, Attach, Detach, Flow, Transfer, Disposition} = require('../performative/frames');
const {DeliveryRejected, ErrorValue} = require('../performative/types');
const {HandleFactory, SerialNumberUInt} = require('./types');
const {EC, ErrMsg} = require('../errors');

const constants = require('../serialize/constants');
const SND_MODE_UNSETTLED = constants.VALUE.LINK.SND_SETTLE_MODE.UNSETTLED;
const SND_MODE_SETTLED = constants.VALUE.LINK.SND_SETTLE_MODE.SETTLED;
const RCV_MODE_FIRST = constants.VALUE.LINK.RCV_SETTLE_MODE.FIRST;

/**
 * @private
 */
class SessionState extends EventEmitter {

    /**
     * @event SessionState#begin
     * @param {!Begin} frame
     * @private
     */

    /**
     * @event SessionState#flow
     * @param {!Flow} frame
     * @private
     */

    /**
     * @event SessionState#end
     * @param {!End} frame
     * @private
     */

    /**
     * @event SessionState#drain-outgoing
     * @private
     */

    /**
     * @param {!ConnectionState} connection
     * @param {!Session} endpoint
     */
    constructor(connection, endpoint) {
        super();

        /**
         * @type {ConnectionState}
         */
        this.connection = connection;

        /**
         * @type {Session}
         */
        this.endpoint = endpoint;

        /**
         * @type {ChannelHandle}
         */
        this.outgoingHandle = -1;

        /**
         * @type {ChannelHandle}
         */
        this.incomingHandle = -1;

        /**
         * @type {Error}
         */
        this.outgoingError = null;

        /**
         * @type {Error}
         */
        this.incomingError = null;

        /**
         * @type {HandleFactory}
         */
        this.linkHandleFactory = new HandleFactory(connection.options.maxLinkHandle);

        /**
         * @type {Map<LinkHandle, !(OutgoingLinkState|IncomingLinkState)>}
         * @private
         */
        this._inputLinkHandles = new Map();

        /**
         * @type {DeliveryNumber}
         * @private
         */
        this._nextDeliveryID = /** @type{DeliveryNumber}*/ (0);

        /**
         * @type {TransferNumber}
         * @private
         */
        this._nextOutgoingID = /** @type{TransferNumber}*/ (0);

        /**
         * @type {UInt}
         * @private
         */
        this._outgoingWindow = /** @type{UInt}*/ (connection.options.outgoingSessionWindow);

        /**
         * @type {UInt}
         * @private
         */
        this._remoteIncomingWindow = /** @type{UInt}*/ (0);

        /**
         * @type {TransferNumber}
         * @private
         */
        this._nextIncomingID = null;

        /**
         * @type {UInt}
         * @private
         */
        this._incomingWindow = /** @type{UInt}*/ (connection.options.incomingSessionWindow);

        /**
         * @type {UInt}
         * @private
         */
        this._remoteOutgoingWindow = /** @type{UInt}*/ (0);

        /**
         * @type {UInt}
         * @private
         *
         * estimate value of peer's remoteIncomingWindow to decide on sending a flow frame to update, actually to continue working
         * - peer and self maintain incomingWindow, outgoingWindow, both values are decreased with unsettled transfers and increased with dispositions
         * - peer and self may use different window sizes, the one or the other may reach its limit first
         * - peer and self maintain remoteIncomingWindow, remoteOutgoingWindow to reflect the other endpoints situation, only decrementing !
         *
         * - peer running sender may pause transfers due to missing credit (link issue) or outgoingWindow === 0 or remoteIncomingWindow === 0
         * - dispositions send to peer may increase peer outgoingWindow again, but not peer's remoteIncomingWindow
         *
         * - hence, handle the submitted self incomingWindow as a kind of credit, count it here and send flow to renew it
         * - send flow if incomingWindowCredit <= incomingWindowLWM (usually 25% of window size) and if incomingUnsettled.size <= incomingWindowLWM as well
         * - with that the number of needed flow frames is minimized while transfer capacity is used in an optimized way
         *
         * second case is about settled frames
         * - here no dispositions are sent (fire and forget)
         * - in this case check already on incoming transfer, if incomingWindowCredit <= incomingWindowLWM send a flow as well
         * - independent from why flow is triggered the flow frame attributes are always calculated precisely from current session state, always same logic
         */
        this._incomingWindowCredit = /** @type{UInt}*/ (0);

        /**
         * @type {UInt}
         * @private
         */
        this._outgoingWindowLWM = 0;

        /**
         * @type {UInt}
         * @private
         */
        this._incomingWindowLWM = 0;

        /**
         * @type {UInt}
         * @private
         */
        this._windowPercentLWM = 25;

        /**
         * @type {Map<DeliveryNumber, Transfer>}
         * @private
         */
        this._outgoingUnsettled = new Map();

        /**
         * @type {Map<DeliveryNumber, Transfer>}
         * @private
         */
        this._incomingUnsettled = new Map();

        /**
         * @type {Array<Transfer>}
         * @private
         */
        this._outgoingQueue = [];

        /**
         * @type {boolean}
         * @private
         */
        this._outgoingStreamPause = false;

        /**
         * @type {boolean}
         * @private
         */
        this._outgoingWindowPause = false;

        /**
         * @type {boolean}
         * @private
         */
        this._remoteIncomingPause = false;

        /**
         * @type {NotifyOfTransferSplit}
         * @private
         */
        this._cbSendTransferSplit = () => this._onSendTransferSplit();

        /**
         * @type {function()}
         * @private
         */
        this._cbSendStreamDrain = () => this._onSendStreamDrain();
    }

    _windowLowWaterMark(window) {
        return Math.floor(window * this._windowPercentLWM / 100);
    }

    /**
     * @param {LinkHandle} handle
     * @return {!(OutgoingLinkState|IncomingLinkState)}
     * @private
     */
    _linkByIncomingHandle(handle) {
        const s = this._inputLinkHandles.get(handle);
        if (s) return s;
        throw ErrMsg(EC.LINK_HANDLE_UNKNOWN, handle);
    }

    /**
     * @param {!Begin} frame
     */
    onSendBegin(frame) {
        this.outgoingHandle = this.connection.channelHandleFactory.provide();
        this._outgoingWindow = frame.outgoingWindow;
        this._incomingWindow = frame.incomingWindow;
        this._outgoingWindowLWM = this._windowLowWaterMark(frame.outgoingWindow);
        this._incomingWindowLWM = this._windowLowWaterMark(frame.incomingWindow);
        this._incomingWindowCredit = frame.incomingWindow;
        frame.nextOutgoingID = this._nextOutgoingID;
        frame.remoteChannel = this.incomingHandle > -1 ? this.incomingHandle : null;
        frame.handleMax = this.connection.options.maxLinkHandle;
        frame.channel = this.outgoingHandle;
        this.connection.onSendBegin(frame, this);
    }

    /**
     * @param {!Begin} frame
     */
    onPeerBegin(frame) {
        this.incomingHandle = frame.channel;
        this.linkHandleFactory.limit = Math.min(this.connection.options.maxLinkHandle, frame.handleMax ? frame.handleMax : 0xFFFFFFFF);
        this._nextIncomingID = frame.nextOutgoingID;
        this._remoteIncomingWindow = frame.incomingWindow;
        this._remoteOutgoingWindow = frame.outgoingWindow;
        this.emit('begin', frame);
    }

    /**
     * @param {!End} frame
     */
    onSendEnd(frame) {
        frame.channel = this.outgoingHandle;
        if (this.outgoingError) {
            frame.error = new ErrorValue(this.outgoingError);
        }
        this.outgoingHandle = -1;
        this.connection.channelHandleFactory.recycle(frame.channel);
        this.connection.onSendEnd(frame, this);
    }

    /**
     * @param {!End} frame
     */
    onPeerEnd(frame) {
        this.incomingHandle = -1;
        this.emit('end', frame);
    }

    /**
     * @param {!Attach} frame
     */
    onSendAttach(frame) {
        frame.channel = this.outgoingHandle;
        this.connection.onSendFrame(frame);
    }

    /**
     * @param {!Attach} frame
     */
    onPeerAttach(frame) {
        if (frame.handle > this.connection.options.maxLinkHandle)
            throw ErrMsg(EC.LINK_HANDLE_OUT_OF_RANGE, frame.handle, this.connection.options.maxLinkHandle, frame.name);
        if (this._inputLinkHandles.has(frame.handle))
            throw ErrMsg(EC.LINK_HANDLE_IN_USE, frame.handle, this._inputLinkHandles.get(frame.handle).name);

        const ep = (frame.roleReceiver) ? this.connection.container.sender(frame.name, this.endpoint, true) : this.connection.container.receiver(frame.name, this.endpoint, true);
        const ls = this.connection.getLinkState(ep);

        if (ls.incomingHandle > -1)
            throw ErrMsg(EC.LINK_HANDLE_OVERRIDE, frame.handle, ls.name, ls.incomingHandle);

        this._inputLinkHandles.set(frame.handle, ls);
        ls.onPeerAttach(frame);

        if (ls.outgoingHandle > -1) this._onSendTransferDrain();
    }

    /**
     * @param {!Detach} frame
     * @param {(OutgoingLinkState|IncomingLinkState)} link
     */
    onSendDetach(frame, link) {
        if (frame.closed && link.constructor === OutgoingLinkState) {
            for (const [id, transfer] of this._outgoingUnsettled) {
                if (frame.handle === transfer.linkHandle) {
                    this._outgoingUnsettled.delete(id);
                }
            }
        }
        frame.channel = this.outgoingHandle;
        this.connection.onSendFrame(frame);
    }

    /**
     * @param {!Detach} frame
     */
    onPeerDetach(frame) {
        const ls = this._linkByIncomingHandle(frame.handle);
        this._inputLinkHandles.delete(frame.handle);
        ls.onPeerDetach(frame);
    }

    /**
     * @param {!Flow} frame
     */
    onInitFlow(frame) {
        this._outgoingWindow = frame.outgoingWindow;
        this._incomingWindow = frame.incomingWindow;
        this._outgoingWindowLWM = this._windowLowWaterMark(frame.outgoingWindow);
        this._incomingWindowLWM = this._windowLowWaterMark(frame.incomingWindow);
        this.onSendFlow(frame);
    }

    /**
     * @param {Flow=} frame
     */
    onSendFlow(frame = new Flow()) {
        frame.nextOutgoingID = this._nextOutgoingID;
        frame.nextIncomingID = this._nextIncomingID;
        frame.outgoingWindow = /** @type{UInt}*/ (Math.max(0, this._outgoingWindow - this._outgoingUnsettled.size));
        frame.incomingWindow = /** @type{UInt}*/ (Math.max(0, this._incomingWindow - this._incomingUnsettled.size));
        this._incomingWindowCredit = frame.incomingWindow;
        if (this.outgoingHandle < 0) {
            return;
        }
        frame.channel = this.outgoingHandle;
        this.connection.onSendFrame(frame);
    }

    /**
     * @param {!Flow} frame
     */
    onPeerFlow(frame) {
        const remoteNextIncomingID = frame.nextIncomingID ? frame.nextIncomingID : 0;
        const remoteIncomingWindow = frame.incomingWindow - SerialNumberUInt.delta(remoteNextIncomingID, this._nextOutgoingID);
        this._remoteIncomingWindow = /** @type{UInt} */ Math.max(0, remoteIncomingWindow);
        this._remoteOutgoingWindow = frame.outgoingWindow;

        if (typeof frame.handle === 'number') {
            this._linkByIncomingHandle(frame.handle).onPeerFlow(frame);
        }
        if (this._remoteIncomingPause && this._remoteIncomingWindow > 0) {
            this._remoteIncomingPause = false;
            if (this._outgoingStreamPause === false && this._outgoingWindowPause === false) this._onSendTransferDrain();
        }

        this.emit('flow', frame);
    }

    /**
     * @param {!Disposition} frame
     */
    onSendDisposition(frame) {
        if (frame.settled) {
            const unsettled = frame.roleReceiver ? this._incomingUnsettled : this._outgoingUnsettled;
            const settleIDs = SerialNumberUInt.interval(frame.first, frame.last);
            for (const id of settleIDs) {
                unsettled.delete(id);
            }
            if (this._incomingWindowCredit <= this._incomingWindowLWM && this._incomingUnsettled.size <= this._incomingWindowLWM) {
                this.onSendFlow();
            }
        }
        if (this.outgoingHandle < 0) {
            return;
        }
        frame.channel = this.outgoingHandle;
        this.connection.onSendFrame(frame);
    }

    /**
     * @param {Disposition} frame
     */
    onPeerDisposition(frame) {
        if (!frame.roleReceiver && !frame.settled)
            throw ErrMsg(EC.SENDER_DISPOSITION_UNSETTLED);

        let transfer, reply = null, replies = [];
        const unsettled = frame.roleReceiver ? this._outgoingUnsettled : this._incomingUnsettled;
        const settleIDs = SerialNumberUInt.interval(frame.first, frame.last);

        for (const id of settleIDs) {
            transfer = unsettled.get(id);
            if (transfer && (!transfer.onDispose || transfer.onDispose(frame))) {
                unsettled.delete(id);
                if (!frame.settled) {
                    if (reply && reply.last === id - 1) { // at serial number overflow switch disposition frame for sure
                        reply.last = id;
                    } else {
                        replies.push(reply = new Disposition());
                        reply.roleReceiver = !frame.roleReceiver;
                        reply.last = reply.first = id;
                        reply.settled = true;
                    }
                }
            }
        }

        for (reply of replies) {
            reply.channel = this.outgoingHandle;
            this.connection.onSendFrame(reply);
        }
        if (frame.roleReceiver && this._outgoingWindowPause && this._outgoingUnsettled.size <= this._outgoingWindowLWM) {
            this._outgoingWindowPause = false;
            if (this._remoteIncomingPause === false && this._outgoingStreamPause === false) this._onSendTransferDrain();
        }
    }

    /**
     * @param {!Transfer} frame
     * @return {boolean}
     */
    onSendTransfer(frame) {
        if (this.outgoingHandle < 0 || this._remoteIncomingPause || this._outgoingWindowPause || this._outgoingStreamPause) {
            this._outgoingQueue.push(frame);
            return false;
        }
        if (!frame.settled && this._outgoingUnsettled.size >= this._outgoingWindow) {
            this._outgoingWindowPause = true;
            this._outgoingQueue.push(frame);
            return false;
        }
        if (this._remoteIncomingWindow < 1) {
            this._remoteIncomingPause = true;
            this._outgoingQueue.push(frame);
            return false;
        }
        this._onSendTransferStart(frame);
        return this.connection.onSendFrame(frame) ? true : this._onSendStreamPause();
    }

    /**
     * @private
     */
    _onSendTransferDrain() {
        let frame, queue = this._outgoingQueue, unsettled = this._outgoingUnsettled;
        while (queue.length && unsettled.size < this._outgoingWindow) {
            if (this._remoteIncomingWindow < 1) {
                this._remoteIncomingPause = true;
                return;
            }
            frame = queue.shift();
            this._onSendTransferStart(frame);
            if (!this.connection.onSendFrame(frame)) return this._onSendStreamPause();
        }
        if (queue.length === 0) {
            this.emit('drain-outgoing');
        }
    }

    /**
     * Called one time when the transfer is really going to be sent
     * Define the delivery ID
     * Count the transfer a first time, not knowing whether it will be slit by encoder
     *
     * @param {Transfer} frame
     */
    _onSendTransferStart(frame) {
        frame.deliveryID = this._nextDeliveryID;
        this._nextDeliveryID = SerialNumberUInt.increment(this._nextDeliveryID, 1);

        this._nextOutgoingID = SerialNumberUInt.increment(this._nextOutgoingID, 1);
        if (this._remoteIncomingWindow > 0) this._remoteIncomingWindow--;

        if (!frame.settled) this._outgoingUnsettled.set(frame.deliveryID, frame);

        frame.onSplit = this._cbSendTransferSplit;
        frame.channel = this.outgoingHandle;
    }

    /**
     * Callback from encoder: transfer is split due to limited maxFrameSize
     * This will be known while encoding only, avoiding any mem copies or pre-calculation
     * Transfer counter must be adjusted
     */
    _onSendTransferSplit() {
        this._nextOutgoingID = SerialNumberUInt.increment(this._nextOutgoingID, 1);
        if (this._remoteIncomingWindow > 0) this._remoteIncomingWindow--;
    }

    /**
     * @return {boolean}
     * @private
     */
    _onSendStreamPause() {
        if (this._outgoingStreamPause === false) {
            this._outgoingStreamPause = true;
            this.connection.once('drain-outgoing', this._cbSendStreamDrain);
        }
        return false;
    }

    /**
     * @private
     */
    _onSendStreamDrain() {
        if (this._outgoingStreamPause === true) {
            this._outgoingStreamPause = false;
            if (this._outgoingWindowPause === false && this._remoteIncomingPause === false) this._onSendTransferDrain();
        }
    }

    /**
     * @param {!Transfer} frame
     */
    onPeerTransfer(frame) {
        if (this._nextIncomingID === null)
            throw ErrMsg(EC.INCOMING_WINDOW_SEQUENCE, this.incomingHandle, frame.linkHandle, frame.deliveryID);
        if (this._incomingUnsettled.has(frame.deliveryID))
            throw ErrMsg(EC.INCOMING_WINDOW_SEQUENCE, this.incomingHandle, frame.linkHandle, frame.deliveryID);

        this._nextIncomingID = SerialNumberUInt.increment(this._nextIncomingID, 1);
        this._remoteOutgoingWindow = /** @type{UInt} */ Math.max(0, this._remoteOutgoingWindow - 1);
        this._incomingWindowCredit = /** @type{UInt} */ Math.max(0, this._incomingWindowCredit - 1);

        if (!frame.aborted && !frame.more && !frame.settled) {
            if (this._incomingUnsettled.size >= this._incomingWindow)
                throw ErrMsg(EC.INCOMING_WINDOW_OVERFLOW, this.incomingHandle, frame.linkHandle, frame.deliveryID, this._incomingUnsettled.size);
            this._incomingUnsettled.set(frame.deliveryID, frame);
        }

        if (this._incomingWindowCredit <= this._incomingWindowLWM) {
            this.onSendFlow(); // always calculate with completed transfers only, do not reduce by partial frames
        }

        if (!frame.aborted && !frame.more) {
            this._linkByIncomingHandle(frame.linkHandle).onPeerTransfer(frame);
        }
    }

}

/**
 * @private
 */
class OutgoingLinkState extends EventEmitter {

    /**
     * @event OutgoingLinkState#attach
     * @param {!Attach} frame
     * @private
     */

    /**
     * @event OutgoingLinkState#flow
     * @param {!Flow} frame
     * @private
     */

    /**
     * @event OutgoingLinkState#detach
     * @param {!Detach} frame
     * @private
     */

    /**
     * @event OutgoingLinkState#drain
     * @private
     */

    /**
     * @param {!SessionState} session
     * @param {LinkName} name
     */
    constructor(session, name) {
        super();

        /**
         * @type {!SessionState}
         */
        this.session = session;

        /**
         * @type {LinkName}
         */
        this.name = name;

        /**
         * @type {LinkHandle}
         */
        this.outgoingHandle = -1;

        /**
         * @type {LinkHandle}
         */
        this.incomingHandle = -1;

        /**
         * @type {Error}
         */
        this.outgoingError = null;

        /**
         * @type {Error}
         */
        this.incomingError = null;

        /**
         * @type {SequenceNumber}
         */
        this.delivered = /** @type {SequenceNumber} */ (0);

        /**
         * @type {UInt}
         */
        this.credit = /** @type {UInt} */ (0);

        /**
         * @type {Bool}
         */
        this.draining = false;

        /**
         * @type {SndSettleMode}
         */
        this._sndSettleMode = 0;

        /**
         * @type {RcvSettleMode}
         */
        this._rcvSettleMode = 0;

        /**
         * @type {Array<Transfer>}
         * @private
         */
        this._outgoingQueue = [];

        /**
         * @type {boolean}
         * @private
         */
        this._outgoingStreamPause = false;

        /**
         * @type {boolean}
         * @private
         */
        this._outgoingCreditPause = false;

        /**
         * @type {function()}
         * @private
         */
        this._cbSendStreamDrain = () => this._onSendStreamDrain();
    }

    /**
     * @param {!Attach} frame
     * @param {!SessionState} session
     */
    onSendAttach(frame, session) {
        if (session !== this.session) {
            this.session.removeListener('drain-outgoing', this._cbSendStreamDrain);
            this.session = session;
        }

        this.outgoingHandle = this.session.linkHandleFactory.provide();
        this._sndSettleMode = frame.sndSettleMode;
        frame.delivered = this.delivered;
        frame.handle = this.outgoingHandle;
        this.session.onSendAttach(frame);
    }

    /**
     * @param {!Attach} frame
     */
    onPeerAttach(frame) {
        this.incomingHandle = frame.handle;
        this._rcvSettleMode = frame.rcvSettleMode;
        this.emit('attach', frame);

        if (this._outgoingStreamPause) {
            this._cbSendStreamDrain();
        }
    }

    /**
     * @param {!Detach} frame
     */
    onSendDetach(frame) {
        if (this.outgoingError) {
            frame.error = new ErrorValue(this.outgoingError);
        }
        frame.handle = this.outgoingHandle;
        this.outgoingHandle = -1;
        this.session.onSendDetach(frame, this);
        this.session.linkHandleFactory.recycle(frame.handle);
    }

    /**
     * @param {!Detach} frame
     */
    onPeerDetach(frame) {
        this.incomingHandle = -1;
        this.emit('detach', frame);
    }

    /**
     * @param {UInt} available
     * @param {UInt} queued
     */
    submitFlow(available, queued) {
        if (this.draining && queued === 0) {
            if (this.credit > 0) {
                this.delivered = /** @type {SequenceNumber} */ SerialNumberUInt.increment(this.delivered, this.credit);
                this.credit = /** @type {UInt} */ (0);
            }
        }

        if (this.outgoingHandle < 0) return;
        const frame = new Flow();
        frame.handle = this.outgoingHandle;
        frame.delivered = this.delivered;
        frame.credit = this.credit;
        frame.available = available;
        frame.drain = this.draining;
        frame.echo = false;
        this.session.onSendFlow(frame);
    }

    /**
     * @param {!Flow} frame
     */
    onPeerFlow(frame) {
        this.credit = (typeof frame.delivered === 'number') ? frame.credit - SerialNumberUInt.delta(frame.delivered, this.delivered) : frame.credit;
        this.draining = frame.drain;
        if (this._outgoingCreditPause && this.credit > 0) {
            this._outgoingCreditPause = false;
        }
        if (!this._outgoingStreamPause && !this._outgoingCreditPause && this._outgoingQueue.length > 0) {
            this._onSendDrain();
        }
        this.emit('flow', frame);
    }

    /**
     * @param {!Transfer} frame
     * @return {boolean}
     */
    onSendTransfer(frame) {
        if (this.outgoingHandle < 0 || this._outgoingCreditPause || this._outgoingStreamPause) {
            this._outgoingQueue.push(frame);
            return false;
        }
        if (this.credit <= 0) {
            this._outgoingCreditPause = true;
            this._outgoingQueue.push(frame);
            return false;
        }
        this._finalizeTransfer(frame);
        return this.session.onSendTransfer(frame) ? true : this._onSendStreamPause();
    }

    /**
     * @return {boolean}
     * @private
     */
    _onSendStreamPause() {
        if (this._outgoingStreamPause === false) {
            this._outgoingStreamPause = true;
            this.session.once('drain-outgoing', this._cbSendStreamDrain);
        }
        return false;
    }

    /**
     * @private
     */
    _onSendStreamDrain() {
        if (this._outgoingStreamPause === true) {
            this._outgoingStreamPause = false;
            if (!this._outgoingCreditPause) this._onSendDrain();
        }
    }

    /**
     * @private
     */
    _onSendDrain() {
        let frame, queue = this._outgoingQueue;
        while (queue.length && this.credit > 0) {
            frame = queue.shift();
            this._finalizeTransfer(frame);
            if (!this.session.onSendTransfer(frame)) return this._onSendStreamPause();
        }
        if (queue.length === 0) {
            this.emit('drain');
        } else {
            this._outgoingCreditPause = true;
        }
    }

    /**
     * @param {Transfer} frame
     * @private
     */
    _finalizeTransfer(frame) {
        if (this._rcvSettleMode === RCV_MODE_FIRST) {
            frame.rcvSettleMode = null;
        }
        switch (this._sndSettleMode) {
            case SND_MODE_SETTLED:
                frame.settled = true;
                frame.rcvSettleMode = null;
                break;
            case SND_MODE_UNSETTLED:
                frame.settled = null;
                break;
        }
        frame.linkHandle = this.outgoingHandle;

        this.delivered = /** @type{SequenceNumber} */ SerialNumberUInt.increment(this.delivered, 1);
        this.credit -= /** @type{UInt} */ (1);
    }

}

/**
 * @private
 */
class IncomingLinkState extends EventEmitter {

    /**
     * @event IncomingLinkState#attach
     * @param {!Attach} frame
     * @private
     */

    /**
     * @event IncomingLinkState#flow
     * @param {!Flow} frame
     * @private
     */

    /**
     * @event IncomingLinkState#transfer
     * @param {!Transfer} frame
     * @private
     */

    /**
     * @event IncomingLinkState#detach
     * @param {!Detach} frame
     * @private
     */

    /**
     * @event IncomingLinkState#ready
     * @param {!Attach} frame
     * @private
     */

    /**
     * @param {!SessionState} session
     * @param {LinkName} name
     */
    constructor(session, name) {
        super();

        /**
         * @type {!SessionState}
         */
        this.session = session;

        /**
         * @type {LinkName}
         */
        this.name = name;

        /**
         * @type {LinkHandle}
         */
        this.outgoingHandle = -1;

        /**
         * @type {LinkHandle}
         */
        this.incomingHandle = -1;

        /**
         * @type {Error}
         */
        this.outgoingError = null;

        /**
         * @type {Error}
         */
        this.incomingError = null;

        /**
         * @type {SequenceNumber}
         */
        this.delivered = /** @type {SequenceNumber} */ (0);

        /**
         * @type {UInt}
         */
        this.available =  /** @type {UInt} */ (0);

        /**
         * @type {UInt}
         */
        this.credit = /** @type {UInt} */ (0);

        /**
         * @type {SequenceNumber}
         */
        this.approved = /** @type {SequenceNumber} */ (0);

        /**
         * @type {?SndSettleMode}
         */
        this._sndSettleMode = null;

        /**
         * @type {?RcvSettleMode}
         */
        this._rcvSettleMode = null;
    }

    /**
     * @param {!Attach} frame
     * @param {!SessionState} session
     */
    onSendAttach(frame, session) {
        this.session = session;
        this.outgoingHandle = this.session.linkHandleFactory.provide();
        frame.handle = this.outgoingHandle;
        this._rcvSettleMode = frame.rcvSettleMode;
        this.session.onSendAttach(frame);
    }

    /**
     * @param {!Attach} frame
     */
    onPeerAttach(frame) {
        this.incomingHandle = frame.handle;
        this._sndSettleMode = frame.sndSettleMode;
        this.emit('attach', frame);
        this.emit('ready', frame);
    }

    /**
     * @param {!Detach} frame
     */
    onSendDetach(frame) {
        if (this.outgoingError) {
            frame.error = new ErrorValue(this.outgoingError);
        }
        frame.handle = this.outgoingHandle;
        this.outgoingHandle = -1;
        this.session.onSendDetach(frame, this);
        this.session.linkHandleFactory.recycle(frame.handle);
    }

    /**
     * @param {!Detach} frame
     */
    onPeerDetach(frame) {
        this.incomingHandle = -1;
        this.emit('detach', frame);
    }

    /**
     * @param {!Flow} frame
     */
    onSendFlow(frame) {
        const approved = SerialNumberUInt.increment(this.delivered, frame.credit);
        if (SerialNumberUInt.less(this.approved, approved)) {
            this.approved = approved;
        }
        this.credit = frame.credit;
        frame.handle = this.outgoingHandle;
        frame.delivered = this.delivered;
        frame.available = this.available;
        frame.drain = false;
        frame.echo = false;
        this.session.onSendFlow(frame);
    }

    /**
     * @param {!Flow} frame
     */
    onPeerFlow(frame) {
        this.available = frame.available;
        this.delivered = frame.delivered;
        this.emit('flow', frame);
    }

    /**
     * @param {!Transfer} frame
     */
    onPeerTransfer(frame) {
        if (this._sndSettleMode === SND_MODE_SETTLED && !frame.settled)
            throw ErrMsg(EC.LINK_SETTLE_MODE_MISMATCH, 'false', 'true');
        if (this._sndSettleMode === SND_MODE_UNSETTLED && frame.settled)
            throw ErrMsg(EC.LINK_SETTLE_MODE_MISMATCH, 'true', 'false');
        if (this.approved === this.delivered || SerialNumberUInt.less(this.approved, this.delivered))
            throw ErrMsg(EC.LINK_CREDIT_ALREADY_CONSUMED, this.incomingHandle);

        this.delivered = SerialNumberUInt.increment(this.delivered, 1);
        if (this.available > 0) this.available -= /** @type{UInt} */ (1);
        if (this.credit > 0) this.credit -= /** @type{UInt} */ (1);

        if (!this.emit('transfer', frame) && !frame.settled) {
            this.onFreeTransfer(frame, new DeliveryRejected(ErrMsg(EC.MSG_REJECTED_AFTER_DETACH, frame.deliveryID, frame.linkHandle)));
        }
    }

    /**
     * @param {Transfer} transfer
     * @param {DeliveryOutcome} outcome
     */
    onFreeTransfer(transfer, outcome) {
        if (transfer.settled) return;
        const frame = new Disposition();
        frame.roleReceiver = true;
        frame.first = transfer.deliveryID;
        frame.settled = this._rcvSettleMode === RCV_MODE_FIRST;
        frame.state = outcome;
        this.session.onSendDisposition(frame);
    }

}

module.exports = {
    SessionState: SessionState,
    OutgoingLinkState: OutgoingLinkState,
    IncomingLinkState: IncomingLinkState
};

