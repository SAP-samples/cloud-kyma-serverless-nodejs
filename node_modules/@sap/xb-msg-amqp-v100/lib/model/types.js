'use strict';

const {EC, ErrMsg} = require('../errors');

/*********************************************************************************************************************/
/** defined types: api layer *****************************************************************************************/
/*********************************************************************************************************************/

/**
 * @typedef {Object} ProtocolSettings - Protocol specific settings
 * @property {string} containerID - The id of the client container.
 * @property {string} peerHostName - An optional name of the host (either fully qualified or relative) to which the client is connecting.
 * @property {number} maxChannelHandle - The highest channel number that can be used on the connection.
 * @property {number} maxLinkHandle - The highest link handle value that can be used on a session.
 * @property {number} maxFrameSize - The largest frame size that the client is able to accept on this connection.
 * @property {number} maxMessageSize - The largest message size that the client is able to accept on this connection.
 * @property {string} autoDeliveryTagPrefix - The prefix is used for each generated delivery tag, written with UTF8 encoding.
 * @property {number} outgoingSessionWindow - A default for sessions outgoing window size
 * @property {number} incomingSessionWindow - A default for sessions incoming window size
 * @property {number} minRemoteOutgoingWindow - A limit for remote outgoing session window, when reached session flow shall increase it automatically
 * @property {number} maxReceiverLinkCredit - A default for link credit upper limit
 * @property {number} minReceiverLinkCredit - A default for link credit lower limit, when reached new credits shall be sent automatically
 * @property {number} linkHighWaterMsgCount - A default for link stream high water message count, incoming or outgoing, by default 16 messages
 * @property {MapMessageSource} mapIncomingMessageSource - A callback to set stream message source from transfer data, by default all data
 * @property {MapMessageTarget} mapOutgoingMessageTarget - A callback to set transfer data from stream message target, by default all data
 * @property {number} idleTimeoutMilliseconds - The idle timeout in milliseconds, send to peer and used as socket idle timeout, 0 means no idle timeout
 * @property {boolean} idleTimeoutTryKeepAlive - Indicates whether or not to try keep alive connection by sending empty frames on idle timeout
 * @property {number} emptyPacketIdleSeconds - A timeout in seconds of socket inactivity after which an empty AMQP frame will be sent to keep connection alive
 */

/**
 * @typedef {Object} PeerInfo
 * @property {string} platform
 * @property {string} product
 * @property {string} version
 * @property {string} description
 * @property {string} hostname
 * @property {string} container
 * @property {Milliseconds} idleTimeout
 */

/**
 * @typedef {string} SessionID
 */

/**
 * @typedef {Object} SessionOptions
 * @property {SymbolArray} offered
 * @property {SymbolArray} desired
 * @property {Fields} properties
 */

/**
 * @typedef {Object} LinkOptions
 * @property {SndSettleMode} sndSettleMode
 * @property {RcvSettleMode} rcvSettleMode
 * @property {ULong} maxMessageSize
 * @property {LinkSourceData} source
 * @property {LinkTargetData} target
 * @property {SymbolArray} offered
 * @property {SymbolArray} desired
 * @property {Fields} properties
 */

/**
 * @typedef {Object} LinkSourceData
 * @property {AddressString} address
 * @property {TerminusDurability} durable
 * @property {TerminusExpiryPolicy} expires
 * @property {Seconds} timeout
 * @property {Bool} dynamic
 * @property {LinkDynamicProperties} dynamicProperties
 * @property {DistributionMode} distributionMode
 * @property {FilterSet} filter - see http://www.amqp.org/specification/1.0/filters
 * @property {SymbolValue} defaultOutcome
 * @property {SymbolArray} outcomes
 * @property {SymbolArray} capabilities
 */

/**
 * @typedef {Object} LinkTargetData
 * @property {AddressString} address
 * @property {TerminusDurability} durable
 * @property {TerminusExpiryPolicy} expires
 * @property {Seconds} timeout
 * @property {Bool} dynamic
 * @property {LinkDynamicProperties} dynamicProperties
 * @property {SymbolArray} capabilities
 */

/**
 * @typedef {Object} LinkDynamicProperties
 * @property {ULong} lifetimePolicy
 * @property {DistributionModeArray} supportedDistModes
 */

/**
 * @typedef {Object} StreamMessage
 * @property {StreamMessageSource} source
 * @property {StreamMessageTarget} target
 * @property {Buffer|Array<Buffer>|Payload|Object} payload - payload data, incoming streams always provide Payload objects, outgoing streams accept all listed types
 * @property {NotifyOfMessageDone} done - A callback to use after successful message processing
 * @property {NotifyOfMessageFailed} failed - A callback to use on failed message processing
 */

/**
 * @typedef {Object} StreamMessageSource
 * @property {DeliveryTag} deliveryTag
 * @property {Bool} batchable
 * @property {Bool} settled
 * @property {RcvSettleMode} rcvSettleMode
 * @property {MessageHeaderData} header
 * @property {MessageAnnotations} annotations
 * @property {MessagePropertyData} properties
 */

/**
 * @typedef {Object} StreamMessageTarget
 * @property {DeliveryTag} deliveryTag
 * @property {Bool} batchable
 * @property {Bool} settled
 * @property {RcvSettleMode} rcvSettleMode
 * @property {MessageHeaderData} header
 * @property {MessageAnnotations} annotations
 * @property {MessagePropertyData} properties
 */

/**
 * @typedef {Object} MessageHeaderData
 * @property {Bool} durable
 * @property {UByte} priority
 * @property {Milliseconds} ttl
 * @property {Bool} firstAcquirer
 * @property {UInt} deliveryCount
 */

/**
 * @typedef {Object} MessagePropertyData
 * @property {MessageID} messageID
 * @property {BinaryValue} userID
 * @property {AddressString} to
 * @property {StringValue} subject
 * @property {AddressString} replyTo
 * @property {MessageID} correlationID
 * @property {SymbolValue} contentType
 * @property {SymbolValue} contentEncoding
 * @property {Timestamp} absoluteExpiryTime
 * @property {StringValue} groupID
 * @property {SequenceNumber} groupSequence
 * @property {StringValue} replyToGroupID
 */

/*********************************************************************************************************************/
/** defined types: api extension *************************************************************************************/
/*********************************************************************************************************************/

/**
 * @typedef {Object} TransferData
 * @property {DeliveryTag} deliveryTag
 * @property {Bool} batchable
 * @property {Bool} settled
 * @property {RcvSettleMode} rcvSettleMode
 * @property {MessageHeaderData} message.header
 * @property {MessageAnnotations} message.annotations
 * @property {MessagePropertyData} message.properties
 * @property {MessagePayload} message.payload
 */

/**
 * @callback AdjustSelfIdleTimeout
 * @param {Milliseconds} selfIdleTimeout
 * @param {boolean} selfTryKeepAlive
 * @param {PeerInfo} peerInfo
 * @return {Milliseconds}
 */

/**
 * @callback MapMessageSource
 * @param {LinkSourceData} rcvSource
 * @param {TransferData} transfer
 * @return {StreamMessageSource|*}
 */

/**
 * @callback MapMessageTarget
 * @param {LinkTargetData} sndTarget
 * @param {StreamMessageTarget|*} msgTarget
 * @return {TransferData}
 */

/*********************************************************************************************************************/
/** default callbacks: api layer *************************************************************************************/

/*********************************************************************************************************************/

/**
 * @param {Milliseconds} selfIdleTimeout
 * @param {boolean} selfTryKeepAlive
 * @param {PeerInfo} peer
 * @return {Milliseconds}
 */
function adjustSelfIdleTimeout(selfIdleTimeout, selfTryKeepAlive, peer) {
    if (!selfTryKeepAlive) {
        return selfIdleTimeout;
    } else if (selfIdleTimeout && peer.idleTimeout) {
        return Math.min(selfIdleTimeout, peer.idleTimeout / 2);
    } else if (peer.idleTimeout) {
        return peer.idleTimeout / 2;
    } else {
        return selfIdleTimeout;
    }
}

/**
 * @param {LinkSourceData} rcvSource
 * @param {TransferData} transfer
 * @return {StreamMessageSource|*}
 * @private
 */
function mapMessageSource(rcvSource, transfer) {
    return {
        deliveryTag: transfer.deliveryTag,
        batchable: transfer.batchable ? transfer.batchable : false,
        settled: transfer.settled ? transfer.settled : false,
        rcvSettleMode: transfer.rcvSettleMode,
        header: transfer.message.header,
        annotations: transfer.message.annotations,
        properties: transfer.message.properties
    };
}

/**
 * @param {LinkTargetData} sndTarget
 * @param {StreamMessageTarget|*} msgTarget
 * @return {?TransferData}
 * @private
 */
function mapMessageTarget(sndTarget, msgTarget) {
    return (msgTarget === null || typeof msgTarget !== 'object') ? null : {
        deliveryTag: typeof msgTarget.deliveryTag === 'string' ? msgTarget.deliveryTag : null,
        batchable: typeof msgTarget.batchable === 'boolean' ? msgTarget.batchable : null,
        settled: typeof msgTarget.settled === 'boolean' ? msgTarget.settled : null,
        rcvSettleMode: typeof msgTarget.rcvSettleMode === 'number' ? msgTarget.rcvSettleMode : null,
        header: typeof msgTarget.header === 'object' ? msgTarget.header : null,
        annotations: typeof msgTarget.annotations === 'object' ? msgTarget.annotations : null,
        properties: typeof msgTarget.properties === 'object' ? msgTarget.properties : null
    };
}

/*********************************************************************************************************************/
/** defined types: api internal **************************************************************************************/
/*********************************************************************************************************************/

/**
 * @callback NotifyOfMessageDone
 * @param {DeliveryTag} tag
 * @private
 */

/**
 * @callback NotifyOfMessageFailed
 * @param {Error} error
 * @param {DeliveryTag} tag
 * @private
 */

/*********************************************************************************************************************/
/** implemented types: api layer *************************************************************************************/

/*********************************************************************************************************************/

/**
 * @private
 */
class HandleFactory {

    /**
     * @param {number} limit
     */
    constructor(limit) {

        /**
         * @type {number}
         */
        this.limit = limit;

        /**
         * @type {number}
         * @private
         */
        this._next = 0;

        /**
         * @type {Array<number>}
         * @private
         */
        this._reuse = [];
    }

    /**
     * @return {number}
     */
    provide() {
        if (this._reuse.length)
            return this._reuse.pop();
        else if (this._next < this.limit)
            return ++this._next;
        else
            throw new ErrMsg(EC.HANDLE_LIMIT_REACHED, this.limit);
    }

    /**
     * @param {number} handle
     */
    recycle(handle) {
        this._reuse.push(handle);
    }
}

/**
 * @private
 */
class DeliveryTagFactory {

    /**
     * @param {string} prefix
     */
    constructor(prefix) {

        /**
         * @type {number}
         * @private
         */
        this._countUInt32 = 0;

        /**
         * @type {number}
         * @private
         */
        this._limitUInt32 = 0xFFFFFFFF;

        /**
         * @type {number}
         * @private
         */
        this._countOffset = Buffer.byteLength(prefix, 'utf8');

        /**
         * @type {!Buffer}
         * @private
         */
        this._tagTemplate = Buffer.alloc(this._countOffset + 4);

        /**
         * init template
         */
        this._tagTemplate.write(prefix, 'utf8');
    }

    /**
     * @return {DeliveryTag}
     */
    provide() {
        if (this._countUInt32 === this._limitUInt32) this._countUInt32 = 0;
        this._tagTemplate.writeUInt32BE(++this._countUInt32, this._countOffset);
        return this._tagTemplate.toString('hex');
    }

}

/**
 * see https://www.ietf.org/rfc/rfc1982.txt
 */

const SN_UINT_SERIAL_BITS = 32;
const SN_UINT_VALUE_RANGE = Math.pow(2, SN_UINT_SERIAL_BITS);
const SN_UINT_MAX_VALUE = Math.pow(2, SN_UINT_SERIAL_BITS) - 1;
const SN_UINT_MAX_DELTA = Math.pow(2, SN_UINT_SERIAL_BITS - 1) - 1;
const SN_UINT_COMPARE_DIFF = Math.pow(2, SN_UINT_SERIAL_BITS - 1);

class SerialNumberUInt {


    /**
     * @param {UInt} low
     * @param {UInt} high
     * @return {Array<UInt>}
     */
    static interval(low, high) {
        const result = [];

        if (typeof high !== 'number') {
            high = low;
        }
        let i = low;
        if (high < low) {
            while (i <= SN_UINT_MAX_VALUE) {
                result.push(i++);
            }
            i = 0;
        }
        while (i <= high) {
            result.push(i++);
        }

        return result;
    }

    /**
     * @param {UInt|SequenceNumber} low
     * @param {UInt|SequenceNumber} high
     * @return {UInt}
     */
    static delta(low, high) {
        if (high < low) {
            return /** @type{UInt}*/ (SN_UINT_MAX_VALUE - low + high);
        }
        return /** @type{UInt}*/ (high - low);
    }

    /**
     * @param {UInt|SequenceNumber} value
     * @param {UInt|number} delta
     * @return {UInt|SequenceNumber}
     */
    static increment(value, delta) {
        return /** @type{UInt}*/ (value + delta) % SN_UINT_VALUE_RANGE;
    }

    /**
     * @param {UInt|SequenceNumber} s1
     * @param {UInt|number} s2
     * @return {boolean}
     */
    static less(s1, s2) {
        return (s1 < s2 && (s2 - s1) < SN_UINT_COMPARE_DIFF) || (s1 > s2 && (s1 - s2) > SN_UINT_COMPARE_DIFF);
    }

}

module.exports = {
    HandleFactory,
    DeliveryTagFactory,
    SerialNumberUInt,
    adjustSelfIdleTimeout,
    mapMessageSource,
    mapMessageTarget
};

