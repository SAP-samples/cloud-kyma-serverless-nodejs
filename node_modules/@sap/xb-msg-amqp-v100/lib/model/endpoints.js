'use strict';

const EventEmitter = require('events');
const {Readable, Writable} = require('stream');
const {EC, ErrMsg} = require('../errors');
const {Begin, End, Attach, Detach, Flow, Transfer, Disposition} = require('../performative/frames');
const {LinkSource, LinkTarget, DeliveryReceived, DeliveryAccepted, DeliveryRejected, DeliveryReleased, DeliveryModified} = require('../performative/types');
const {MessageHeader, MessageProperties} = require('../performative/message');
const {DeliveryTagFactory} = require('./types');
const {objectValues} = require('../tools/options');

const constants = require('../serialize/constants');
const MESSAGE_FORMAT = constants.VALUE.TRANSFER.MESSAGE_FORMAT.AMQP;
const SND_MODE_UNSETTLED = constants.VALUE.LINK.SND_SETTLE_MODE.UNSETTLED;
const SND_MODE_SETTLED = constants.VALUE.LINK.SND_SETTLE_MODE.SETTLED;
const SND_MODE_MIXED = constants.VALUE.LINK.SND_SETTLE_MODE.MIXED;
const RCV_MODE_FIRST = constants.VALUE.LINK.RCV_SETTLE_MODE.FIRST;
const RCV_MODE_SECOND = constants.VALUE.LINK.RCV_SETTLE_MODE.SECOND;

const TERMINUS_DURABLE = objectValues(constants.VALUE.TERMINUS.DURABILITY);
const TERMINUS_EXPIRES = objectValues(constants.VALUE.TERMINUS.EXPIRY_POLICY);
const LINK_DISTR_POLICY = objectValues(constants.VALUE.LINK.DISTR_POLICY);

/**
 * An abstract endpoint.
 * @private
 * @abstract
 */
class Endpoint extends EventEmitter {

    /**
     * The endpoint is opened and can be used.
     * @event Endpoint#opened
     * @private
     */

    /**
     * The endpoint is closed.
     * @event Endpoint#closed
     * @private
     */

    /**
     * The endpoint will be destroyed. Release instance immediately.
     * @event Endpoint#destroy
     * @private
     */

    /**
     * @param {!Container} container
     * @param {boolean} dynamic
     */
    constructor(container, dynamic) {
        super();

        /**
         * @type {Container}
         * @protected
         */
        this._container = container;

        /**
         * @type {boolean}
         * @protected
         */
        this._dynamic = dynamic;

        /**
         * @type {boolean}
         * @protected
         */
        this._destroyed = false;

        /**
         * @type {?SymbolArray}
         * @protected
         */
        this._offered = null;

        /**
         * @type {?SymbolArray}
         * @protected
         */
        this._desired = null;

        /**
         * @type {?Fields}
         * @protected
         */
        this._properties = null;

        /**
         * @type {function()}
         * @private
         */
        this._cbStateInit = (connection) => this._onStateInit(connection);

        /**
         * @type {function()}
         * @private
         */
        this._cbStateFree = () => this._onStateFree();

        /**
         *
         */
        if (dynamic) {
            const tryDestroy = () => (this._destroyed) ? undefined : this.destroy();
            this._cbStateFree = tryDestroy;
            this.once('closed', tryDestroy);
        }

        /**
         * set event handler
         */
        this._container.on('state', this._cbStateInit);

        /**
         * set event handler
         */
        this._container.on('close', this._cbStateFree);
    }

    /**
     * Endpoint was created on peer request. Lifetime is restricted to current connection.
     * The endpoint will be destroyed as soon as it is closed.
     * @return {boolean}
     * @final
     */
    dynamic() {
        return this._dynamic;
    }

    /**
     * The local endpoint is active. It will automatically call its corresponding remote endpoint to get active,
     * as soon as the logical parent endpoint (session or connection) is ready.
     * @return {boolean}
     * @abstract
     */
    active() {
    }

    /**
     * The local endpoint and its corresponding remote endpoint are both active.
     * @return {boolean}
     * @abstract
     */
    opened() {
    }

    /**
     * The local endpoint is closed.
     * @return {boolean}
     * @abstract
     */
    closed() {
    }

    /**
     * The endpoint cannot be used anymore and it is also not registered anymore. Release the reference.
     * @return {boolean}
     * @final
     */
    destroyed() {
        return this._destroyed;
    }

    /**
     * @param {Error=} error
     * @final
     */
    destroy(error = null) {
        if (this._destroyed)
            throw ErrMsg(EC.EP_STATE_ERROR, this.constructor.name, 'destroyed', 'destroy');

        this._destroyed = true;
        this.emit('destroy');
        this._doDestroy(error);

        this._container.removeListener('state', this._cbStateInit);
        this._container.removeListener('close', this._cbStateFree);
        if (this._state) this._onStateFree();
    }

    /**
     * @param {Error} error
     * @protected
     * @abstract
     */
    _doDestroy(error) {
    }

    /**
     * @param {ConnectionState} state
     * @protected
     * @abstract
     */
    _onStateInit(state) {
    }

    /**
     * @protected
     * @abstract
     */
    _onStateFree() {
    }

}

/**
 * A session endpoint.
 * @final
 */
class Session extends Endpoint {

    /**
     * @event Session#opened
     */

    /**
     * @event Session#flow
     */

    /**
     * @event Session#ending
     */

    /**
     * @event Session#closed
     */

    /**
     * @event Session#destroy
     */

    /**
     * @param {!Container} container
     * @param {boolean} dynamic
     */
    constructor(container, dynamic) {
        super(container, dynamic);

        /**
         * no limit for event 'destroy', used by each endpoint, can be many, however usually 1-3
         */
        this.setMaxListeners(0);

        /**
         * @type {boolean}
         * @private
         */
        this._active = false;

        /**
         * @type {SessionState}
         * @private
         */
        this._state = null;

        /**
         * @type {UInt}
         * @private
         */
        this._outgoingWindow = /** @type{UInt} */ (container.settings.outgoingSessionWindow);

        /**
         * @type {UInt}
         * @private
         */
        this._incomingWindow = /** @type{UInt} */ (container.settings.incomingSessionWindow);

        /**
         * @type {function()}
         * @private
         */
        this._cbConnectionReady = () => this._onConnectionReady();

        /**
         * @type {function()}
         * @private
         */
        this._cbPeerBegin = (frame) => this._onPeerBegin(frame);

        /**
         * @type {function()}
         * @private
         */
        this._cbPeerFlow = (frame) => this._onPeerFlow(frame);

        /**
         * @type {function()}
         * @private
         */
        this._cbPeerEnd = (frame) => this._onPeerEnd(frame);

        /**
         * set initial state
         */
        if (container.state) this._onStateInit(container.state);
    }

    /**
     * @return {boolean}
     * @override
     */
    active() {
        return this._active;
    }

    /**
     * @return {boolean}
     * @override
     */
    opened() {
        return this._state && this._state.outgoingHandle >= 0 && this._state.incomingHandle >= 0;
    }

    /**
     * @return {boolean}
     * @override
     */
    closed() {
        return !this._state || (this._state.outgoingHandle < 0 && this._state.incomingHandle < 0);
    }

    /**
     * @param {UInt=} outgoing
     * @param {UInt=} incoming
     * @param {SessionOptions=} options
     */
    begin(outgoing, incoming, options) {
        if (this._destroyed)
            throw ErrMsg(EC.EP_STATE_ERROR, 'session', 'destroyed', 'begin');
        if (this._active)
            throw ErrMsg(EC.EP_STATE_ERROR, 'session', 'active', 'begin');

        this._outgoingWindow = Validator.readUInt(outgoing, this._outgoingWindow);
        this._incomingWindow = Validator.readUInt(incoming, this._incomingWindow);

        const data = Validator.readData(options);
        this._offered = Validator.readSymbols(data.offered, this._offered);
        this._desired = Validator.readSymbols(data.desired, this._desired);
        this._properties = Validator.readFields(data.properties, this._properties);

        this._active = true;
        if (this.closed() && this._state && this._state.connection.ready)
            this._begin();
    }

    /**
     * @param {UInt=} incoming
     * @param {UInt=} outgoing
     */
    flow(incoming, outgoing) {
        if (this._destroyed)
            throw ErrMsg(EC.EP_STATE_ERROR, 'session', 'destroyed', 'flow');
        if (!this._active)
            throw ErrMsg(EC.EP_STATE_ERROR, 'session', 'inactive', 'flow');

        this._outgoingWindow = Validator.readUInt(outgoing, this._outgoingWindow);
        this._incomingWindow = Validator.readUInt(incoming, this._incomingWindow);

        if (this._state && this._state.outgoingHandle > -1)
            this._flow();
    }

    /**
     * @param {Error} error
     */
    end(error = null) {
        if (this._destroyed)
            throw ErrMsg(EC.EP_STATE_ERROR, 'session', 'destroyed', 'end');
        if (!this._active)
            throw ErrMsg(EC.EP_STATE_ERROR, 'session', 'inactive', 'end');
        this._doDestroy(error);
    }

    /**
     * @param {Error} error
     * @protected
     * @override
     */
    _doDestroy(error) {
        this.emit('ending');
        this._active = false;
        if (this._state)
            this._state.outgoingError = error;
        if (this.opened())
            this._end();
    }

    /**
     * @param {!Begin} frame
     * @private
     */
    _onPeerBegin(frame) {
        if (this._state.outgoingHandle < 0)
            this._begin();
        if (this._dynamic && !this._destroyed)
            this._active = true;
        if (this._active)
            this.emit('opened');
        else
            this._end();
    }

    /**
     * @param {!Flow} frame
     * @private
     */
    _onPeerFlow(frame) {
        if (this._state.outgoingHandle >= 0)
            this.emit('flow');
    }

    /**
     * @param {!End} frame
     * @private
     */
    _onPeerEnd(frame) {
        const state = this._state;

        if (state.outgoingHandle >= 0)
            this._end();
        if (frame.error)
            state.incomingError = frame.error.toObject();

        const ox = state.outgoingError;
        state.outgoingError = null;
        const ix = state.incomingError;
        state.incomingError = null;

        if (ix && !this.emit('closed', ox, ix))
            state.connection.emit('error', ix);

        if (this._active && !ix)
            this._begin();
    }

    /**
     * @private
     */
    _onConnectionReady() {
        if (this._active && this._state.outgoingHandle < 0)
            this._begin();
    }

    /**
     * @param {ConnectionState} state
     * @private
     */
    _onStateInit(state) {
        this._state = state.getSessionState(this)
            .on('begin', this._cbPeerBegin)
            .on('flow', this._cbPeerFlow)
            .on('end', this._cbPeerEnd)
        ;
        this._state.connection.once('ready', this._cbConnectionReady);
    }

    /**
     * @private
     */
    _onStateFree() {
        this._state.connection.removeListener('ready', this._cbConnectionReady);
        this._state
            .removeListener('begin', this._cbPeerBegin)
            .removeListener('flow', this._cbPeerFlow)
            .removeListener('end', this._cbPeerEnd)
        ;
        this._state = null;
    }

    /**
     * @private
     */
    _begin() {
        const frame = new Begin();
        frame.incomingWindow = this._incomingWindow;
        frame.outgoingWindow = this._outgoingWindow;
        frame.offered = this._offered;
        frame.desired = this._desired;
        frame.properties = this._properties;
        this._state.onSendBegin(frame);
    }

    /**
     * @private
     */
    _flow() {
        const frame = new Flow();
        frame.incomingWindow = this._incomingWindow;
        frame.outgoingWindow = this._outgoingWindow;
        this._state.onInitFlow(frame);
    }

    /**
     * @private
     */
    _end() {
        const frame = new End();
        this._state.onSendEnd(frame);
    }

}

/**
 * An abstract link endpoint.
 * @private
 * @abstract
 */
class Link extends Endpoint {

    /**
     * @param {!Container} container
     * @param {!Session} session
     * @param {!LinkName} name
     * @param {!RoleReceiver} role
     * @param {boolean} dynamic
     */
    constructor(container, session, name, role, dynamic) {
        super(container, dynamic);

        /**
         * @type {!Session}
         * @protected
         */
        this._session = session;

        /**
         * @type {!LinkName}
         * @protected
         */
        this._name = name;

        /**
         * @type {RoleReceiver}
         * @protected
         */
        this._role = role;

        /**
         * @type {OutgoingLinkState|IncomingLinkState}
         * @protected
         */
        this._state = null;

        /**
         * @type {OutgoingStream|IncomingStream}
         * @protected
         */
        this._stream = null;

        /**
         * @type {SndSettleMode}
         * @protected
         */
        this._sndSettleMode = SND_MODE_UNSETTLED;

        /**
         * @type {SndSettleMode}
         * @protected
         */
        this._rcvSettleMode = RCV_MODE_FIRST;

        /**
         * @type {ULong}
         * @protected
         */
        this._maxMessageSize = container.settings.maxMessageSize;

        /**
         * @type {?LinkSourceData}
         * @protected
         */
        this._source = null;

        /**
         * @type {?LinkTargetData}
         * @protected
         */
        this._target = null;

        /**
         * @type {function()}
         * @private
         */
        this._cbSessionOpened = () => this._onSessionOpened();

        /**
         * @type {function()}
         * @private
         */
        this._cbSessionEnding = () => this._onSessionEnding();

        /**
         * @type {function()}
         * @private
         */
        this._cbSessionDestroy = () => this._onSessionDestroy();

        /**
         * @type {function(Error)}
         * @protected
         */
        this._cbStreamEnding = () => this._onStreamEnding();

        /**
         * @type {function(Attach)}
         * @private
         */
        this._cbPeerAttach = (frame) => this._onPeerAttach(frame);

        /**
         * @type {function(Detach)}
         * @private
         */
        this._cbPeerDetach = (frame) => this._onPeerDetach(frame);

        /**
         * set event handler
         */
        this._session
            .on('opened', this._cbSessionOpened)
            .on('ending', this._cbSessionEnding)
            .on('destroy', this._cbSessionDestroy)
        ;

        /**
         * set initial state
         */
        if (container.state)
            this._onStateInit(container.state);

    }

    /**
     * @return {!Session}
     * @final
     */
    session() {
        return this._session;
    }

    /**
     * @return {!LinkName}
     * @final
     */
    name() {
        return this._name;
    }

    /**
     * @returns {LinkOptions}
     */
    options() {
        return /** @type{LinkOptions}*/({
            sndSettleMode: this._sndSettleMode,
            rcvSettleMode: this._rcvSettleMode,
            maxMessageSize: this._maxMessageSize,
            source: Object.assign({}, this._source),
            target: Object.assign({}, this._target),
            offered: this._offered ? Array.from(this._offered) : null,
            desired: this._desired ? Array.from(this._desired) : null,
            properties: this._properties ? new Map(this._properties) : null
        });
    }

    /**
     * @return {boolean}
     * @override
     */
    active() {
        return this._stream !== null;
    }

    /**
     * @return {boolean}
     * @override
     */
    opened() {
        return this._state && this._state.outgoingHandle >= 0 && this._state.incomingHandle >= 0;
    }

    /**
     * @return {boolean}
     * @override
     */
    closed() {
        return !this._state || (this._state.outgoingHandle < 0 && this._state.incomingHandle < 0);
    }

    /**
     * @param {Error=} error
     */
    detach(error = null) {
        if (this._destroyed)
            throw ErrMsg(EC.EP_STATE_ERROR, `${this.constructor.name.toLowerCase()} '${this._name}'`, 'destroyed', 'detach');
        if (this._stream === null)
            throw ErrMsg(EC.EP_STATE_ERROR, `${this.constructor.name.toLowerCase()} '${this._name}'`, 'inactive', 'detach');
        this._onSelfDetach(error);
    }

    /**
     * @param {!Attach} frame
     * @protected
     * @abstract
     */
    _acceptAttach(frame) {
    }

    /**
     * @param {AddressString|LinkOptions|string|Object} options
     * @param {SessionID=} session
     * @protected
     */
    _onSelfAttach(options, session) {
        const args = Validator.readLinkOptions(options, this._role);
        this._source = Validator.readLinkSource(args.source);
        this._target = Validator.readLinkTarget(args.target);
        this._sndSettleMode = Validator.readUByteEnum(args.sndSettleMode, [SND_MODE_UNSETTLED, SND_MODE_SETTLED, SND_MODE_MIXED], this._sndSettleMode);
        this._rcvSettleMode = Validator.readUByteEnum(args.rcvSettleMode, [RCV_MODE_FIRST, RCV_MODE_SECOND], this._rcvSettleMode);
        this._maxMessageSize = Validator.readULong(args.maxMessageSize, this._maxMessageSize);
        this._offered = Validator.readSymbols(args.offered, this._offered);
        this._desired = Validator.readSymbols(args.desired, this._desired);
        this._properties = Validator.readFields(args.properties, this._properties);

        if ((typeof session === 'string')) {
            this._session
                .removeListener('opened', this._cbSessionOpened)
                .removeListener('ending', this._cbSessionEnding)
                .removeListener('destroy', this._cbSessionDestroy)
            ;
            this._session = this._container.session(session)
                .on('opened', this._cbSessionOpened)
                .on('ending', this._cbSessionEnding)
                .on('destroy', this._cbSessionDestroy)
            ;
        }

        if (this._session.destroyed())
            throw ErrMsg(EC.EP_STATE_ERROR, `session '${typeof session === 'string' ? session : '<dynamic>'}'`, 'destroyed', 'attach');
        else if (this._session.opened())
            this._onSessionOpened();
        else if (!this._session.active())
            this._session.begin();
    }

    /**
     * @param {Error} error
     * @private
     */
    _onSelfDetach(error) {
        if (this._state)
            this._state.outgoingError = error;
        if (this._stream !== null && !this._stream.destroyed)
            this._stream.destroy();
        if (this._state && this._state.outgoingHandle > -1 && this._state.session.outgoingHandle > -1)
            this._detach();
    }

    /**
     * @param {!Attach} frame
     * @private
     */
    _onPeerAttach(frame) {
        if (!this._destroyed)
            this._acceptAttach(frame);
        if (this._state.outgoingHandle < 0)
            this._attach();
        if (this._stream === null)
            this._detach();
        else
            this.emit('opened');
    }

    /**
     * @param {!Detach} frame
     * @private
     */
    _onPeerDetach(frame) {
        const state = this._state;
        if (frame.error)
            state.incomingError = frame.error.toObject();
        if (this._stream !== null && !this._stream.destroyed)
            this._stream.destroy();
        if (state.outgoingHandle > -1)
            this._detach();
    }

    /**
     * @param {Error} error
     * @private
     * @override
     */
    _doDestroy(error) {
        this._session
            .removeListener('opened', this._cbSessionOpened)
            .removeListener('ending', this._cbSessionEnding)
            .removeListener('destroy', this._cbSessionDestroy)
        ;
        this._onSelfDetach(error);
    }

    /**
     * @param {ConnectionState} state
     * @private
     * @override
     */
    _onStateInit(state) {
        this._state = state.getLinkState(this);
        this._state
            .on('attach', this._cbPeerAttach)
            .on('detach', this._cbPeerDetach)
        ;
    }

    /**
     * @private
     * @override
     */
    _onStateFree() {
        this._state
            .removeListener('attach', this._cbPeerAttach)
            .removeListener('detach', this._cbPeerDetach)
        ;
        this._state = null;
    }

    /**
     * @private
     */
    _onSessionOpened() {
        if (this.active())
            this._attach();
    }

    /**
     * @private
     */
    _onSessionEnding() {
        if (!this._destroyed && this.active())
            this._onSelfDetach(null);
    }

    /**
     * @private
     */
    _onSessionDestroy() {
        if (!this._destroyed)
            this.destroy();
    }

    /**
     * @private
     */
    _onStreamEnding() {
        this._stream = null;
        let ox = null, ix = null;
        const state = this._state;
        if (state) {
            ox = state.outgoingError;
            state.outgoingError = null;
            ix = state.incomingError;
            state.incomingError = null;
            if (state.outgoingHandle > -1) this._detach();
        }
        if (!this.emit('closed', ox, ix) && ix)
            state.session.connection.emit('error', ix);
    }

    /**
     * @protected
     */
    _attach() {
        const frame = new Attach();
        frame.name = this._name;
        frame.roleReceiver = this._role;
        frame.sndSettleMode = this._sndSettleMode;
        frame.rcvSettleMode = this._rcvSettleMode;
        frame.source = /** @type {LinkSource} */ (this._source);
        frame.target = /** @type {LinkTarget} */ (this._target);
        frame.maxMessageSize = this._maxMessageSize;
        frame.offered = this._offered;
        frame.desired = this._desired;
        frame.properties = this._properties;
        this._state.onSendAttach(frame, this._state.session.connection.getSessionState(this._session));
    }

    /**
     * @protected
     */
    _detach() {
        const frame = new Detach();
        frame.closed = true;               // always
        this._state.onSendDetach(frame);
    }

}

/**
 * An outgoing link endpoint.
 * @final
 */
class Sender extends Link {

    /**
     * @event Sender#opened
     */

    /**
     * @event Sender#flow
     */

    /**
     * @event Sender#closed
     */

    /**
     * @event Sender#destroy
     */

    /**
     * @param {!Container} container
     * @param {!Session} session
     * @param {!LinkName} name
     * @param {boolean} dynamic
     */
    constructor(container, session, name, dynamic) {
        super(container, session, name, false, dynamic);

        /**
         * @type {DeliveryTagFactory}
         * @private
         */
        this._deliveryTagFactory = new DeliveryTagFactory(container.settings.autoDeliveryTagPrefix);
    }

    /**
     * @return {OutgoingStream}
     */
    stream() {
        return this._stream;
    }

    /**
     * @param {AddressString|LinkOptions|string|Object} options
     * @param {SessionID=} session
     * @param {UInt=} available
     * @return {!OutgoingStream}
     */
    attach(options, session, available = 0) {
        if (this._destroyed)
            throw ErrMsg(EC.EP_STATE_ERROR, `${this.constructor.name.toLowerCase()} '${this._name}'`, 'destroyed', 'attach');
        if (this._stream !== null)
            throw ErrMsg(EC.EP_STATE_ERROR, `${this.constructor.name.toLowerCase()} '${this._name}'`, 'active', 'attach');

        this._stream = this._createStream(Validator.readUInt(available, 0));
        this._onSelfAttach(options, session);
        return this._stream;
    }

    /**
     * @param {UInt} available
     * @return {OutgoingStream}
     */
    _createStream(available) {
        const stream = new OutgoingStream(this._container, this, this._target, this._deliveryTagFactory, available);
        stream.once('finish', this._cbStreamEnding);
        stream.once('close', this._cbStreamEnding);
        return stream;
    }

    /**
     * @param {!Attach} frame
     * @protected
     * @override
     */
    _acceptAttach(frame) {
        this._maxMessageSize = (typeof frame.maxMessageSize === 'number') ? Math.min(frame.maxMessageSize, this._container.settings.maxMessageSize) : this._maxMessageSize;
        this._rcvSettleMode = (typeof frame.rcvSettleMode === 'number') ? frame.rcvSettleMode : this._rcvSettleMode;
        this._target = frame.target ? frame.target : this._target;

        if (this._dynamic) {   // accept also 'own' settings as requested by peer, can still be detached by application
            this._sndSettleMode = (typeof frame.sndSettleMode === 'number') ? frame.sndSettleMode : this._sndSettleMode;
            this._source = frame.source ? frame.source : this._source;
            if (this._stream === null) this._stream = this._createStream(0);
        }
    }

}

/**
 *
 */
class OutgoingStream extends Writable {

    /**
     * @param {Container} container
     * @param {Sender} endpoint
     * @param {LinkTargetData} sndTarget
     * @param {DeliveryTagFactory} dtFactory
     * @param {UInt} available
     */
    constructor(container, endpoint, sndTarget, dtFactory, available) {
        super({
            highWaterMark: container.settings.linkHighWaterMsgCount,
            decodeStrings: false,
            objectMode: true,
            emitClose: false
        });

        /**
         * @type {Container}
         * @private
         */
        this._container = container;

        /**
         * @type {Sender}
         * @private
         */
        this._endpoint = endpoint;

        /**
         * @type {LinkTargetData}
         * @private
         */
        this._sndTarget = sndTarget;

        /**
         * @type {MapMessageTarget}
         * @private
         */
        this._mapTarget = container.settings.mapOutgoingMsgTarget;

        /**
         * @type {!DeliveryTagFactory}
         */
        this._dtFactory = dtFactory;

        /**
         * @type {OutgoingLinkState}
         * @private
         */
        this._state = null;

        /**
         * @type {UInt}
         * @private
         */
        this._available = available;

        /**
         * @type {UInt}
         * @private
         */
        this._queued = 0;

        /**
         * @type {boolean}
         * @private
         */
        this._emitReady = true;

        /**
         * @type {Array<!JsStyleCallback>}
         * @private
         */
        this._awaitDrain = [];

        /**
         * @type {Set<!Transfer>}
         * @private
         */
        this._inTransit = new Set();

        /**
         * @type {?JsStyleCallback}
         * @private
         */
        this._cbTransitDone = null;

        /**
         * @type {NotifyOfMessageFailed}
         * @private
         */
        this._cbDefFailed = (error) => (error ? this.emit('error', error) : undefined);

        /**
         * @type {function(ConnectionState)}
         * @private
         */
        this._cbStateInit = (state) => this._onStateInit(state);

        /**
         * @type {function()}
         * @private
         */
        this._cbStateFree = () => this._onStateFree();

        /**
         * @type {function()}
         * @private
         */
        this._cbStateStart = (frame) => this._onStateStart(frame);

        /**
         * @type {function()}
         * @private
         */
        this._cbStateFlow = (frame) => this._onStateFlow(frame);

        /**
         * @type {function()}
         * @private
         */
        this._cbStateDrain = () => this._onStateDrain();

        /**
         * set event handler
         */
        this._container.on('state', this._cbStateInit);

        /**
         * set event handler
         */
        this._container.on('close', this._cbStateFree);

        /**
         * set initial state
         */
        if (container.state) this._onStateInit(container.state);
    }

    /**
     * @return {!Sender}
     */
    sender() {
        return this._endpoint;
    }

    // noinspection JSUnusedGlobalSymbols
    /**
     * Provides a new auto-generated delivery tag. Application can register it before assigning it to a message.
     * @type {DeliveryTag}
     */
    newDeliveryTag() {
        return this._dtFactory.provide();
    }

    /**
     * Updates the amount of available messages.
     * @param {UInt=} available
     */
    flow(available) {
        this._available = Validator.readUInt(available, 0);
        if (this._state) this._state.submitFlow(this._available, this._queued);
    }

    /**
     * The amount of messages delivered over this stream instance since last connect.
     * @return {SequenceNumber}
     */
    delivered() {
        return this._state ? this._state.delivered : 0;
    }

    /**
     * The amount of messages still expected from application.
     * @return {UInt}
     */
    available() {
        return this._available;
    }

    /**
     * The remaining credit, provided by receiver for the link at the current connection.
     * @return {UInt}
     */
    credit() {
        return this._state ? this._state.credit : 0;
    }

    /**
     * @param {ConnectionState} state
     * @private
     */
    _onStateInit(state) {
        this._state = state.getLinkState(this._endpoint)
            .once('flow', this._cbStateStart)
            // start registers .on('flow', this._cbStateFlow)
            .on('drain', this._cbStateDrain)
        ;
        // push pending transfers to new link state (on new connection)
        // sending will not yet be possible, but transfers are already added to links outgoing queue
        this._resumeInTransit();
    }

    /**
     * @private
     */
    _onStateFree() {
        if (this._state) this._state // may already be null if owner was destroyed while container emits 'close' event
            .removeListener('flow', this._cbStateStart)
            .removeListener('flow', this._cbStateFlow)
            .removeListener('drain', this._cbStateDrain)
        ;
        this._state = null;
    }

    /**
     * @param {Flow} frame
     * @private
     */
    _onStateStart(frame) {
        if (this._awaitDrain.length)
            this._onStateDrain();
        if (this._emitReady)
            process.nextTick(() => this._onStateReady());

        this._state.submitFlow(this._available, this._queued);
        this._state.on('flow', this._cbStateFlow);
    }

    /**
     * @param {Flow} frame
     * @private
     */
    _onStateFlow(frame) {
        if (frame.drain) {
            if (this._queued === 0)
                this._state.submitFlow(this._available, this._queued);
        }
    }

    /**
     * @private
     */
    _onStateReady() {
        if (this._state && this._emitReady) {
            this._emitReady = false;
            this.emit('ready');
        }
    }

    /**
     * @private
     */
    _onStateDrain() {
        while (this._awaitDrain.length) {
            process.nextTick(this._awaitDrain.shift());
        }
    }

    /**
     * @param {!Transfer} transfer
     * @param {!NotifyOfMessageDone} msgDone
     * @private
     */
    _onTransferStarted(transfer, msgDone) {
        transfer.message.header.deliveryCount += 1;
        this._queued -= 1;
        if (this._queued === 0 && this._state && this._state.draining)
            this._state.submitFlow(this._available, this._queued);

        if (transfer.settled) {
            this._releaseTransfer(transfer);
            msgDone(transfer.deliveryTag);
        }
    }

    /**
     * @param {!Transfer} transfer
     * @param {!Disposition} disposition
     * @param {!NotifyOfMessageDone} msgDone
     * @param {!NotifyOfMessageFailed} msgFailed
     * @return {boolean} - settled ?
     * @private
     */
    _onTransferDispose(transfer, disposition, msgDone, msgFailed) {
        this._releaseTransfer(transfer);
        switch (disposition.state ? disposition.state.constructor : null) {
            case DeliveryAccepted:
                msgDone(transfer.deliveryTag);
                break;
            case DeliveryRejected:
                msgFailed(disposition.state.error ? disposition.state.error.toObject() : ErrMsg(EC.MSG_REJECTED_BY_PEER), transfer.deliveryTag);
                break;
            case DeliveryReleased:
                msgFailed(null, transfer.deliveryTag);
                break;
            case DeliveryModified:
                msgFailed(null, transfer.deliveryTag);
                break;
            case DeliveryReceived:
                if (!disposition.settled) return false;
                break;
            default:
                if (!disposition.settled) return false;
        }
        return true;
    }

    /**
     * @param {!Transfer} transfer
     * @param {!Error} error
     * @param {!NotifyOfMessageFailed} msgFailed
     * @private
     */
    _onTransferFailure(transfer, error, msgFailed) {
        this._releaseTransfer(transfer);
        msgFailed(error, transfer.deliveryTag);
    }

    /**
     * @param {!Transfer} transfer
     * @private
     */
    _releaseTransfer(transfer) {
        transfer.onStarted = null;
        transfer.onDispose = null;
        transfer.onFailure = null;
        this._inTransit.delete(transfer);
        if (this._inTransit.size === 0 && typeof this._cbTransitDone === 'function') {
            process.nextTick(this._cbTransitDone);
            this._cbTransitDone = null;
        }
    }

    /**
     * @private
     */
    _resumeInTransit() {
        this._queued = this._inTransit.size;
        for (const transfer of this._inTransit) {
            this._state.onSendTransfer(transfer);
        }
    }

    /**
     * @param {StreamMessage} message
     * @param {string} encoding
     * @param {JsStyleCallback} callback
     * @protected
     * @override
     */
    _write(message, encoding, callback) {
        try {
            const transfer = new Transfer(MESSAGE_FORMAT);
            const msg = transfer.message;
            const data = this._mapTarget(this._sndTarget, message.target);
            if (data) {
                transfer.deliveryTag = data.deliveryTag ? data.deliveryTag : this._dtFactory.provide();
                transfer.batchable = data.batchable ? true : null;
                transfer.settled = data.settled ? true : null;
                transfer.rcvSettleMode = Validator.readUByteEnum(data.rcvSettleMode, [RCV_MODE_FIRST, RCV_MODE_SECOND], null);
                msg.header = Validator.readObjectData(data.header, MessageHeader, true);
                msg.annotations = Validator.readAnnotations(data.annotations, null);
                msg.properties = Validator.readObjectData(data.properties, MessageProperties, false);
                if (!Number.isInteger(msg.header.deliveryCount)) msg.header.deliveryCount = 0;
            } else {
                transfer.deliveryTag = this._dtFactory.provide();
                msg.header = new MessageHeader();
                msg.header.deliveryCount = 0;
            }
            msg.payload = /**@type{MessagePayload}*/(message.payload);

            const done = (typeof message.done === 'function') ? message.done : nop;
            const failed = (typeof message.failed === 'function') ? message.failed : this._cbDefFailed;

            transfer.onStarted = () => this._onTransferStarted(transfer, done);
            transfer.onDispose = (disposition) => this._onTransferDispose(transfer, disposition, done, failed);
            transfer.onFailure = (error) => this._onTransferFailure(transfer, error, failed);
            this._inTransit.add(transfer);
            if (this._available > 0) this._available -= 1;
            this._queued += 1;

            if (this._state === null || this._state.onSendTransfer(transfer) === false) {
                this._awaitDrain.push(callback);
                return;
            }

            callback();
        } catch (e) {
            callback(e);
        }
    }

    /**
     * @protected
     * @override
     */
    _final(callback) {
        if (this._inTransit.size) {
            this._cbTransitDone = callback;
            return;
        }
        callback();
    }

    /**
     * @param error
     * @param callback
     * @protected
     * @override
     */
    _destroy(error, callback) {
        this._container.removeListener('state', this._cbStateInit);
        this._container.removeListener('close', this._cbStateFree);
        const state = this._state;
        if (state) {
            this._onStateFree();
            for (const transfer of this._inTransit) {
                transfer.onFailure(null);
            }
        }
        if (this._writableState) {
            const waiting = this._writableState.getBuffer();
            for (const request of waiting) {
                const message = request.chunk;
                if (typeof message.failed === 'function') {
                    const data = this._mapTarget(this._sndTarget, message.target);
                    message.failed(null, data && data.deliveryTag ? data.deliveryTag : null);
                }
            }
        }
        process.nextTick(() => this.emit('close'));
    }

}

/** workaround for node release 6.X */

if (typeof OutgoingStream.prototype.destroy !== 'function') {
    OutgoingStream.prototype.destroy = function (err = null, cb = null) {
        if (this._writableState.destroyed) {
            if (cb) {
                cb(err);
            } else if (err) {
                this.emit('error', err);
            }
            return this;
        }
        this._writableState.destroyed = true;

        this._destroy(err || null, (e) => {
            if (!cb && e) {
                process.nextTick(() => this.emit('error', e));
            } else if (cb) {
                cb(e);
            }
        });

        // noinspection JSUnusedGlobalSymbols
        this._write = (message, encoding, callback) => {
            callback();
        };
        this._writableState.needDrain = false;
        this.end();
        this._onStateDrain();

        return this;
    };
    Object.defineProperty(OutgoingStream.prototype, 'destroyed', {
        enumerable: false,
        get() {
            return (this._writableState === undefined) ? false : this._writableState.destroyed;
        }
    });
}

/**
 * An incoming link endpoint.
 * @final
 */
class Receiver extends Link {

    /**
     * @event Receiver#opened
     */

    /**
     * @event Receiver#flow
     */

    /**
     * @event Receiver#closed
     */

    /**
     * @event Receiver#destroy
     */

    /**
     * @param {!Container} container
     * @param {!Session} session
     * @param {!LinkName} name
     * @param {boolean} dynamic
     */
    constructor(container, session, name, dynamic) {
        super(container, session, name, true, dynamic);
    }

    /**
     * @return {IncomingStream}
     */
    stream() {
        return this._stream;
    }

    /**
     * @param {AddressString|LinkOptions|string|Object} options
     * @param {SessionID=} session
     * @param {UInt=} maxCredit
     * @param {UInt=} minCredit
     * @return {!IncomingStream}
     * @override
     */
    attach(options, session, maxCredit = this._container.settings.maxReceiverLinkCredit, minCredit = this._container.settings.minReceiverLinkCredit) {
        if (this._destroyed)
            throw ErrMsg(EC.EP_STATE_ERROR, `${this.constructor.name.toLowerCase()} '${this._name}'`, 'destroyed', 'attach');
        if (this._stream !== null)
            throw ErrMsg(EC.EP_STATE_ERROR, `${this.constructor.name.toLowerCase()} '${this._name}'`, 'active', 'attach');

        this._stream = this._createStream(Validator.readUInt(maxCredit, this._container.settings.maxReceiverLinkCredit), Validator.readUInt(minCredit, this._container.settings.minReceiverLinkCredit));
        this._onSelfAttach(options, session);
        return this._stream;
    }

    /**
     * @param {UInt} maxCredit
     * @param {UInt} minCredit
     * @return IncomingStream
     * @private
     */
    _createStream(maxCredit, minCredit) {
        const stream = new IncomingStream(this._container, this, this._source, maxCredit, minCredit);
        stream.once('end', this._cbStreamEnding);
        stream.once('close', this._cbStreamEnding);
        return stream;
    }

    /**
     * @param {!Attach} frame
     * @protected
     * @override
     */
    _acceptAttach(frame) {
        this._maxMessageSize = frame.maxMessageSize ? Math.min(frame.maxMessageSize, this._container.settings.maxMessageSize) : this._maxMessageSize;
        this._sndSettleMode = (typeof frame.sndSettleMode === 'number') ? frame.sndSettleMode : this._sndSettleMode;
        this._source = frame.source ? frame.source : this._source;

        this._state.session.connection.transport.istream.decoder.setMaxMessageSize(frame.channel, frame.handle, this._maxMessageSize);

        if (this._dynamic) {   // accept also 'own' settings as requested by peer, can still be detached by application
            this._rcvSettleMode = (typeof frame.rcvSettleMode === 'number') ? frame.rcvSettleMode : this._rcvSettleMode;
            this._target = frame.target ? frame.target : this._target;
            if (this._stream === null) this._stream = this._createStream(this._container.settings.maxReceiverLinkCredit, this._container.settings.minReceiverLinkCredit);
        }
    }

}

/**
 *
 */
class IncomingStream extends Readable {

    /**
     * @param {!Container} container
     * @param {!Receiver} endpoint
     * @param {LinkSourceData} rcvSource
     * @param {!UInt} maxCredit
     * @param {!UInt} minCredit
     */
    constructor(container, endpoint, rcvSource, maxCredit, minCredit) {
        super({
            highWaterMark: container.settings.linkHighWaterMsgCount,
            decodeStrings: false,
            objectMode: true,
            emitClose: false
        });

        /**
         * @type {Container}
         * @private
         */
        this._container = container;

        /**
         * @type {Receiver}
         * @private
         */
        this._endpoint = endpoint;

        /**
         * @type {LinkSourceData}
         * @private
         */
        this._rcvSource = rcvSource;

        /**
         * @type {MapMessageSource}
         * @private
         */
        this._mapSource = container.settings.mapIncomingMsgSource;

        /**
         * @type {IncomingLinkState}
         * @private
         */
        this._state = null;

        /**
         * @type {boolean}
         * @private
         */
        this._pause = false;

        /**
         * @type {UInt}
         * @private
         */
        this._maxCredit = maxCredit;

        /**
         * @type {UInt}
         * @private
         */
        this._minCredit = minCredit;

        /**
         * @type {!Set<!Transfer>}
         * @private
         */
        this._inTransit = new Set();

        /**
         * @type {function(ConnectionState)}
         * @private
         */
        this._cbStateInit = (connection) => this._onStateInit(connection);

        /**
         * @type {function()}
         * @private
         */
        this._cbStateFree = () => this._onStateFree();

        /**
         * @type {function()}
         * @private
         */
        this._cbStateReady = (frame) => this._onStateReady(frame);

        /**
         * @type {function(!Transfer)}
         * @private
         */
        this._cbPeerTransfer = (transfer) => this._onPeerTransfer(transfer);

        /**
         * set event handler
         */
        this._container.on('state', this._cbStateInit);

        /**
         * set event handler
         */
        this._container.on('close', this._cbStateFree);

        /**
         * set initial state
         */
        if (container.state) this._onStateInit(container.state);
    }

    /**
     * @return {!Receiver}
     */
    receiver() {
        return this._endpoint;
    }

    /**
     * @param {number=} maxCredit
     * @param {number=} minCredit
     */
    flow(maxCredit, minCredit) {
        this._maxCredit = Validator.readUInt(maxCredit, this._container.settings.maxReceiverLinkCredit);
        this._minCredit = Validator.readUInt(minCredit, this._container.settings.minReceiverLinkCredit);
        this._submitFlow(this._maxCredit);
    }

    /**
     * The amount of messages received by this stream instance, since last connect.
     * @return {SequenceNumber}
     */
    delivered() {
        return this._state ? this._state.delivered : 0;
    }

    /**
     * The amount of available messages, already in transit or just estimated by sender.
     * @return {UInt}
     */
    available() {
        return this._state ? this._state.available : 0;
    }

    /**
     * The remaining credit for the sender.
     * @return {UInt}
     */
    credit() {
        return this._state ? this._state.credit : 0;
    }

    /**
     * @param {ConnectionState} connection
     * @private
     */
    _onStateInit(connection) {
        this._state = connection.getLinkState(this._endpoint)
            .on('ready', this._cbStateReady)
            .on('transfer', this._cbPeerTransfer)
        ;
    }

    /**
     * @private
     */
    _onStateFree() {
        if (this._state) this._state // may already be null if owner was destroyed while container emits 'close' event
            .removeListener('ready', this._cbStateReady)
            .removeListener('transfer', this._cbPeerTransfer)
        ;
        this._state = null;
        this._pause = false;
    }

    /**
     * @param {!Attach} frame
     * @private
     */
    _onStateReady(frame) {
        this._submitFlow(this._maxCredit);
        this.emit('subscribed');
    }

    /**
     * @param {!Transfer} transfer
     * @private
     */
    _onPeerTransfer(transfer) {
        const state = this._state;
        const message = {
            source: this._mapSource(this._rcvSource, /**@type{TransferData}*/(transfer)),
            target: {},
            payload: transfer.message.payload,
            done: () => this._onTransferOutcome(state, transfer, new DeliveryAccepted()),
            failed: (error) => this._onTransferOutcome(state, transfer, error ? new DeliveryRejected(error) : new DeliveryReleased())
        };
        transfer.message = null;     // not needed for disposition, stream item and application will keep the only reference

        this._inTransit.add(transfer);
        const pause = !this.push(message);

        if (state === this._state) { // can change while pushing a stream item due to runtime error, disconnect or reconnect
            if (pause) {
                this._pause = true;
                this._submitFlow(0);
            } else if (this._state.credit <= this._minCredit) {
                this._submitFlow(this._maxCredit);
            }
        }
    }

    /**
     * @param {!IncomingLinkState} state
     * @param {!Transfer} transfer
     * @param {!DeliveryOutcome} outcome
     * @private
     */
    _onTransferOutcome(state, transfer, outcome) {
        if (!this._inTransit.delete(transfer)) {
            throw ErrMsg(EC.MSG_DONE_NOT_EXPECTED, transfer.deliveryID);
        } else if (state === this._state) {
            state.onFreeTransfer(transfer, outcome);
        }
    }

    /**
     * @param {UInt} credit
     * @private
     */
    _submitFlow(credit) {
        const frame = new Flow();
        frame.credit = credit;
        frame.drain = false;
        this._state.onSendFlow(frame);
    }

    /**
     * @param {number} size
     * @protected
     */
    _read(size) {
        if (this._pause) {
            this._pause = false;
            if (this._state) this._submitFlow(this._maxCredit);
        }
    }

    /**
     * @param error
     * @param callback
     * @protected
     * @override
     */
    _destroy(error, callback) {
        this._container.removeListener('state', this._cbStateInit);
        this._container.removeListener('close', this._cbStateFree);
        const state = this._state;
        if (state) {
            this._onStateFree();
            for (const transfer of this._inTransit) {
                state.onFreeTransfer(transfer, new DeliveryRejected(ErrMsg(EC.MSG_REJECTED_AFTER_DETACH, transfer.deliveryID, transfer.linkHandle)));
            }
        }
        process.nextTick(() => this.emit('close'));
    }

}

/** workaround for node release 6.X */

if (typeof IncomingStream.prototype.destroy !== 'function') {
    IncomingStream.prototype.destroy = function (err = null, cb = null) {
        if (this._readableState.destroyed) {
            if (cb) {
                cb(err);
            } else if (err) {
                this.emit('error', err);
            }
            return this;
        }
        this._readableState.destroyed = true;

        this._destroy(err || null, (e) => {
            if (!cb && e) {
                process.nextTick(() => this.emit('error', e));
            } else if (cb) {
                cb(e);
            }
        });
        this._readableState.buffer.clear();

        return this;
    };
    Object.defineProperty(IncomingStream.prototype, 'destroyed', {
        enumerable: false,
        get() {
            return (this._readableState === undefined) ? false : this._readableState.destroyed;
        }
    });
}

/**
 * @private
 */
class Validator {

    /**
     * @param {*} data
     * @return {{}}
     */
    static readData(data) {
        return (data && typeof data === 'object') ? data : {};
    }

    /**
     * @param {*} val
     * @param {?string} def
     * @return {?string}
     */
    static readString(val, def) {
        return (typeof val === 'string') ? val : def;
    }

    /**
     * @param {*} val
     * @param {?Bool} def
     * @return {Bool}
     */
    static readBool(val, def) {
        return (typeof val === 'boolean') ? val : def;
    }

    /**
     * @param {*} val
     * @param {?UInt} def
     * @return {UInt}
     */
    static readUInt(val, def) {
        return (Number.isInteger(val) && val >= 0 && val <= 0xFFFFFFFF) ? val : def;
    }

    /**
     * @param {*} val
     * @param {?ULong} def
     * @return {ULong}
     */
    static readULong(val, def) {
        return (Number.isInteger(val) && val >= 0 && val <= Number.MAX_SAFE_INTEGER) ? val : def;
    }

    /**
     * @param {*} val
     * @param {Array<UInt>} flt
     * @param {?UInt} def
     * @return {UInt}
     */
    static readUByteEnum(val, flt, def) {
        return flt.includes(val) ? val : def;
    }

    /**
     * @param {*} val
     * @param {Array<UInt>} flt
     * @param {?UInt} def
     * @return {UInt}
     */
    static readUIntEnum(val, flt, def) {
        return flt.includes(val) ? val : def;
    }

    /**
     * @param {*} val
     * @param {Array<string>} flt
     * @param {?string} def
     * @return {?string}
     */
    static readSymbolEnum(val, flt, def) {
        return flt.includes(val) ? val : def;
    }

    /**
     * @param {*} val
     * @param {?SymbolArray} def
     * @return {?SymbolArray}
     */
    static readSymbols(val, def = null) {
        return Array.isArray(val) ? val.filter(sym => typeof sym === 'string') : def;
    }

    /**
     * @param {*} val
     * @param {?Fields} def
     * @return {?Fields}
     */
    static readFields(val, def) {
        return val && typeof val === 'object' ? Validator._obj2Map(val, null) : def;
    }

    /**
     * @param {*} val
     * @param {*} cls
     * @param {boolean} def
     * @return {*}
     */
    static readObjectData(val, cls, def) {
        return val && typeof val === 'object' ? Object.assign(new cls(), val) : def ? new cls() : null;
    }

    /**
     * @param {*} val
     * @param {?Map} def
     * @return {?Map}
     */
    static readAnnotations(val, def) {
        return val && typeof val === 'object' ? Validator._obj2Map(val, null) : def;
    }

    /**
     * @param {Object} val
     * @param {?Map} def
     * @return {?Map}
     */
    static _obj2Map(val, def) {
        switch (val.constructor.name) {
            case 'Map': {
                return /** @type {Map} */ (val);
            }
            case 'Object': {
                const map = new Map();
                for (const key of Object.getOwnPropertyNames(val)) map.set(key, val[key]);
                return map;
            }
            default:
                return def;
        }
    }

    /**
     * @param {*} val
     * @param {RoleReceiver} roleReceiver
     * @return {LinkOptions}
     */
    static readLinkOptions(val, roleReceiver) {
        switch (typeof val) {
            case 'string':
                return (roleReceiver) ? {source: {address: val}} : {target: {address: val}};
            case 'object':
                return /**@type{LinkOptions}*/ (val === null) ? {} : val.hasOwnProperty('source') || val.hasOwnProperty('target') ? val : roleReceiver ? {source: val} : {target: val};
            default:
                return /**@type{LinkOptions}*/ {};
        }
    }

    /**
     * @param {*} val
     * @return {?LinkSourceData}
     */
    static readLinkSource(val) {
        switch (typeof val) {
            case 'string': {
                const source = new LinkSource();
                source.address = val;
                return source;
            }
            case 'object': {
                const source = new LinkSource();
                this._readCommonLinkData(val, source);
                source.distributionMode = Validator.readSymbolEnum(val.distributionMode, LINK_DISTR_POLICY, null);
                source.filter = null;
                source.defaultOutcome = null;
                source.outcomes = Validator.readSymbols(val.outcomes);
                return source;
            }
            default: {
                return null;
            }
        }
    }

    /**
     * @param {*} val
     * @return {?LinkTargetData}
     */
    static readLinkTarget(val) {
        switch (typeof val) {
            case 'string': {
                const target = new LinkTarget();
                target.address = val;
                return target;
            }
            case 'object': {
                const target = new LinkTarget();
                this._readCommonLinkData(val, target);
                return target;
            }
            default: {
                return null;
            }
        }
    }

    /**
     * @private
     */
    static _readCommonLinkData(val, data) {
        data.address = Validator.readString(val.address, null);
        data.durable = Validator.readUIntEnum(val.durable, TERMINUS_DURABLE, null);
        data.expires = Validator.readSymbolEnum(val.expires, TERMINUS_EXPIRES, null);
        data.timeout = Validator.readUInt(val.timeout, null);
        data.dynamic = Validator.readBool(val.dynamic, null);
        data.dynamicProperties = Validator.readFields(val.dynamicProperties, null);
        data.capabilities = Validator.readSymbols(val.capabilities);
    }

}

function nop() {
}

module.exports = {
    Session: Session,
    Link: Link,
    Sender: Sender,
    Receiver: Receiver
};

