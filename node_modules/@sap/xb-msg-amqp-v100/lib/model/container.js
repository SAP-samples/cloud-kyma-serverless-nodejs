'use strict';

const EventEmitter = require('events');
const { EC, ErrMsg, AmqpError } = require('../errors');
const { Open, Begin, Attach, Flow, Transfer, Disposition, Detach, End, Close, Empty } = require('../performative/frames');
const { ErrorValue } = require('../performative/types');
const { HandleFactory } = require('./types');
const { SessionState, OutgoingLinkState, IncomingLinkState } = require('./flow');
const { Session, Sender, Receiver } = require('./endpoints');

const constants = require('../serialize/constants');
const SELF_INFO = new Map([
    ['platform', 'node-' + process.version],
    ['product' , constants.RUNTIME.LIBRARY],
    ['version' , constants.RUNTIME.VERSION]
]);

/**
 * @private
 */
class Container extends EventEmitter {

    /**
     * @event Container#error
     * @param {Error} error
     * @private
     */

    /**
     * @event Container#state
     * @private
     */

    /**
     * @event Container#close
     * @private
     */

    /**
     * A new session was opened for the very first time
     * @event Container#session
     * @param {Session} endpoint
     * @private
     */

    /**
     * A new sender was opened for the very first time
     * @event Container#sender
     * @param {Sender} endpoint
     * @private
     */

    /**
     * A new receiver was opened for the very first time
     * @event Container#receiver
     * @param {Receiver} endpoint
     * @private
     */

    /**
     * @param {!ProtocolSettings} settings
     */
    constructor(settings) {
        super();

        /**
         * no limit for events 'state' and 'close', used by each endpoint and endpoint stream
         */
        this.setMaxListeners(0);

        /**
         * @type {!ProtocolSettings}
         */
        this.settings = settings;

        /**
         * @type {?ConnectionState}
         */
        this.state = null;

        /**
         * @type {Map<string, !Session>}
         * @private
         */
        this._sessions = new Map();

        /**
         * @type {Map<string, !Sender>}
         * @private
         */
        this._senders = new Map();

        /**
         * @type {Map<string, !Receiver>}
         * @private
         */
        this._receivers = new Map();
    }

    /**
     * @param {?SessionID} id
     * @return {!Session}
     */
    session(id) {
        let ep = this._sessions.get(id);
        if (!ep) {
            const dyn = typeof id !== 'string';
            ep = new Session(this, dyn);
            if (!dyn) {
                this._sessions.set(id, ep);
                ep.once('destroy', () => this._sessions.delete(id));
            }
            ep.once('opened', () => this.emit('session', ep));
        }
        return ep;
    }

    /**
     * @param {LinkName} name
     * @param {Session=} session
     * @param {boolean=} dynamic
     * @return {Sender}
     */
    sender(name, session, dynamic = false) {
        let ep = this._senders.get(name);
        if (!ep) {
            if (name === '' || typeof name !== 'string') throw new ErrMsg(EC.EP_NAME_INVALID, 'sender', name);
            ep = new Sender(this, session ? session : this.session(''), name, dynamic);
            this._senders.set(name, ep);
            ep.once('opened', () => this.emit('sender', ep));
            ep.once('destroy', () => this._senders.delete(name));
        }
        return ep;
    }

    /**
     * @param {LinkName} name
     * @param {Session=} session
     * @param {boolean=} dynamic
     * @return {Receiver}
     */
    receiver(name, session, dynamic = false) {
        let ep = this._receivers.get(name);
        if (!ep) {
            if (name === '' || typeof name !== 'string') throw new ErrMsg(EC.EP_NAME_INVALID, 'receiver', name);
            ep = new Receiver(this, session ? session : this.session(''), name, dynamic);
            this._receivers.set(name, ep);
            ep.once('opened', () => this.emit('receiver', ep));
            ep.once('destroy', () => this._receivers.delete(name));
        }
        return ep;
    }

    /**
     * @param {!TcpConnection} connection
     */
    bind(connection) {
        this.state = new ConnectionState(this, connection);

        this.state
            .on('error', (error) => {
                this.emit('error', error);
            })
            .once('close', (hadError) => {
                this.state = null;
                this.emit('close', hadError);
            })
        ;

        this.emit('state', this.state);
    }

    /**
     *
     */
    open() {
        this.state.submitOpen();
    }

    /**
     * @param {Error=} error
     */
    close(error = null) {
        this.state.submitClose(error);
    }

}

/**
 * @private
 */
class ConnectionState extends EventEmitter {

    /**
     * @event ConnectionState#ready
     * @private
     */

    /**
     * @event ConnectionState#error
     * @param {Error} error
     * @private
     */

    /**
     * @event ConnectionState#close
     * @private
     */

    /**
     * @event ConnectionState#drain-outgoing
     * @private
     */

    /**
     * @param {!Container} container
     * @param {!TcpConnection} connection
     */
    constructor(container, connection) {
        super();

        /**
         * relax the limit, each session subscribes the "ready"-event
         */
        this.setMaxListeners(connection.options.amqp.maxChannelHandle);

        /**
         * @type {!ProtocolSettings}
         */
        this.options = connection.options.amqp;

        /**
         * @type {boolean}
         */
        this.ready = false;

        /**
         * @type {?PeerInfo}
         */
        this.peerInfo = null;

        /**
         * @type {PeerInfo}
         */
        this.selfInfo = createPeerInfo(SELF_INFO, null, createContainerID(this.options.containerID, connection), this.options.idleTimeoutMilliseconds);

        /**
         * @type {!Container}
         */
        this.container = container;

        /**
         * @type {!TcpConnection}
         */
        this.transport = connection;

        /**
         * @type {!Map<!Session, !SessionState>}
         * @private
         */
        this._sessions = new Map();

        /**
         * @type {Map<!Link, !(OutgoingLinkState|IncomingLinkState)>}
         * @private
         */
        this._links = new Map();

        /**
         * @type {!Map<ChannelHandle, !SessionState>}
         * @private
         */
        this._incomingChannels = new Map();

        /**
         * @type {!Map<ChannelHandle, !SessionState>}
         * @private
         */
        this._outgoingChannels = new Map();

        /**
         * @type {HandleFactory}
         */
        this.channelHandleFactory = new HandleFactory(this.options.maxChannelHandle);

        /**
         * set event handler
         */
        this.transport
            .once('ready', () => this._onConnectionReady())
            .once('close', () => this._onConnectionClose())
        ;

        this.transport.ostream.on('drain', () => this._onOutgoingDrain());
        this.transport.istream.on('data', (frame) => this._onIncomingFrame(frame));
        this.transport.istream.decoder.maxFrameSize = this.options.maxFrameSize;
        this.transport.istream.decoder.maxMessageSizeDefault = this.options.maxMessageSize;

        /**
         * set initial receive state
         */
        this._onPeerFrame = this._awaitOpen;
    }

    /**
     * Assure single unique state object for any endpoint
     * @param {!Session} endpoint
     * @return {!SessionState}
     */
    getSessionState(endpoint) {
        let s = this._sessions.get(endpoint);
        if (!s) {
            s = new SessionState(this, endpoint);
            this._sessions.set(endpoint, s);
            // noinspection JSUnresolvedFunction
            endpoint.once('destroy', () => this._sessions.delete(endpoint));
        }
        return s;
    }

    /**
     * Assure single unique state object for any endpoint
     * @param {!Link} endpoint
     * @return {!(OutgoingLinkState|IncomingLinkState)}
     */
    getLinkState(endpoint) {
        let s = this._links.get(endpoint);
        if (!s) {
            const ps = this.getSessionState(endpoint.session());
            if (endpoint instanceof Sender)
                s = new OutgoingLinkState(ps, endpoint.name());
            else
                s = new IncomingLinkState(ps, endpoint.name());
            this._links.set(endpoint, s);
            // noinspection JSUnresolvedFunction
            endpoint.once('destroy', () => this._links.delete(endpoint));
        }
        return s;
    }

    /**
     * @private
     */
    _onConnectionReady() {
        this.ready = true;
        this.emit('ready');
    }

    /**
     * @private
     */
    _onConnectionClose() {
        // nop connection-relevant methods
        this._onIncomingFrame = nop;
        this._onConnectionReady = nop;
        this.onSendFrame = () => nop(false);

        // unbind state from all endpoints
        this.emit('close');
    }

    /**
     * @private
     */
    _onOutgoingDrain() {
        this.emit('drain-outgoing');
    }

    /**
     * @param {!Frame} frame
     * @private
     */
    _onIncomingFrame(frame) {
        try {
            this._onPeerFrame(frame);
        } catch(error) {
            if (error instanceof AmqpError)
                this.transport.assert(error);
            else
                this.transport.close(error);
        }
    }

    /**
     * @param {number} timeout
     */
    _onIdleTimeoutKeepAlive(timeout) {
        this.transport.ostream.write(new Empty());
        this.transport.idle(true);
        return timeout;
    }

    /**
     * @param {number} timeout
     */
    _onIdleTimeoutDisconnect(timeout) {
        const error = ErrMsg(EC.IDLE_TIMEOUT_DISCONNECT, timeout);
        this.emit('error', error);
        this.transport.end(new Close(new ErrorValue(error)));
        return 0;
    }

    /**
     * @param {!Empty} frame
     * @private
     */
    _onPeerEmpty(frame) {
        this.transport.idle(false);
    }

    /**
     *
     */
    submitOpen() {
        this.submitOpen = nop;                     // method works only one time
        const frame = new Open();
        frame.containerID = this.selfInfo.container;
        frame.hostname = this.peerInfo ? this.peerInfo.hostname : this.options.peerHostName ? this.options.peerHostName : null;
        frame.maxFrameSize = this.transport.istream.decoder.maxFrameSize;
        frame.channelMax = this.options.maxChannelHandle;
        frame.idleTimeout = this.options.idleTimeoutTryKeepAlive ? null : this.options.idleTimeoutMilliseconds;
        frame.properties = SELF_INFO;
        this.transport.ostream.write(frame);
    }

    /**
     * @param {!Open} frame
     * @private
     */
    _onPeerOpen(frame) {
        this.channelHandleFactory.limit = Math.min(this.channelHandleFactory.limit, frame.channelMax ? frame.channelMax : 0xFFFF);
        this.transport.ostream.encoder.maxFrameSize = frame.maxFrameSize ? frame.maxFrameSize : 0xFFFFFFFF;
        this.selfInfo.hostname = frame.hostname ? frame.hostname : '';
        this.peerInfo = createPeerInfo(frame.properties, this.options.peerHostName ? this.options.peerHostName : null, frame.containerID, frame.idleTimeout);
        this._onPeerFrame = this._awaitFrame;
        this.options.idleTimeoutMilliseconds = this.options.adjustSelfIdleTimeout(this.options.idleTimeoutMilliseconds, this.options.idleTimeoutTryKeepAlive, this.peerInfo);
        this.submitOpen();                         // will be nop if already done
        this.transport.ready(this.options.idleTimeoutMilliseconds, this.options.idleTimeoutTryKeepAlive ? (timeout) => this._onIdleTimeoutKeepAlive(timeout) : (timeout) => this._onIdleTimeoutDisconnect(timeout));
    }

    /**
     * {Error=} error
     */
    submitClose(error = null) {
        this.transport.end(new Close(error ? new ErrorValue(error) : null));
        this._onPeerFrame = this._awaitClose;      // wait for close
        this.onSendFrame = () => nop(false);       // close as last frame
        this.submitClose = nop;                    // and only one time
    }

    /**
     * @param {!Close} frame
     * @private
     */
    _onPeerClose(frame) {
        this.submitClose();                        // will be nop if already done
        this._onPeerFrame = nop;                   // ignore any further frame
        if (frame.error) this.emit('error', frame.error.toObject());
    }

    /**
     * @param {!Begin} frame
     * @param {!SessionState} state
     */
    onSendBegin(frame, state) {
        this._outgoingChannels.set(frame.channel, state);
        this.onSendFrame(frame);
    }

    /**
     * @param {!Begin} frame
     * @private
     */
    _onPeerBegin(frame) {
        if (frame.channel > this.options.maxChannelHandle)
            throw ErrMsg(EC.CHANNEL_HANDLE_OUT_OF_RANGE, frame.channel, this.connection.options.maxChannelHandle);
        if (this._incomingChannels.has(frame.channel))
            throw ErrMsg(EC.CHANNEL_HANDLE_IN_USE, frame.channel);

        let state;
        if (typeof frame.remoteChannel === 'number') {                             // peer confirms local session
            state = this._outgoingChannels.get(frame.remoteChannel);
            if (!state)
                throw ErrMsg(EC.CHANNEL_HANDLE_UNKNOWN_OUT, frame.remoteChannel);
            if (state.incomingHandle > -1)
                throw ErrMsg(EC.CHANNEL_HANDLE_OVERRIDE, frame.channel, frame.remoteChannel, state.incomingHandle);
        } else {                                                                   // peer requests a new session
            state = this.getSessionState(this.container.session(null));
        }

        this._incomingChannels.set(frame.channel, state);
        state.onPeerBegin(frame);
    }

    /**
     * @param {!End} frame
     * @param {!SessionState} state
     */
    onSendEnd(frame, state) {
        this._outgoingChannels.delete(frame.channel);
        this.onSendFrame(frame);
    }

    /**
     * @param {!End} frame
     * @private
     */
    _onPeerEnd(frame) {
        const state = this._incomingChannels.get(frame.channel);
        if (!state)
            throw ErrMsg(EC.CHANNEL_HANDLE_UNKNOWN_IN, frame.channel);
        this._incomingChannels.delete(frame.channel);
        state.onPeerEnd(frame);
    }

    /**
     * @param {!ChannelHandle} handle
     * @return {!SessionState}
     * @private
     */
    _incomingChannel(handle) {
        const state = this._incomingChannels.get(handle);
        if (state) return state;
        throw ErrMsg(EC.CHANNEL_HANDLE_UNKNOWN_IN, handle);
    }

    /**
     * @param {!Frame} frame
     * @return {boolean}
     */
    onSendFrame(frame) {
        return this.transport.ostream.write(frame);
    }

    /**
     * @param {!Frame} frame
     * @private
     */
    _onPeerFrame(frame) {
        // dynamic redefinition by this._await*
    }

    /**
     * @param {!Frame} frame
     * @private
     */
    _awaitFrame(frame) {
        switch (frame.constructor) {
            case Transfer:
                this._incomingChannel(frame.channel).onPeerTransfer(/** @type {Transfer} */ (frame));
                break;
            case Disposition:
                this._incomingChannel(frame.channel).onPeerDisposition(/** @type {Disposition} */ (frame));
                break;
            case Flow:
                this._incomingChannel(frame.channel).onPeerFlow(/** @type {Flow} */ (frame));
                break;
            case Attach:
                this._incomingChannel(frame.channel).onPeerAttach(/** @type {Attach} */ (frame));
                break;
            case Detach:
                this._incomingChannel(frame.channel).onPeerDetach(/** @type {Detach} */ (frame));
                break;
            case Begin:
                this._onPeerBegin(/** @type {Begin} */ (frame));
                break;
            case End:
                this._onPeerEnd(/** @type {End} */ (frame));
                break;
            case Close:
                this._onPeerClose(/** @type {Close} */ (frame));
                break;
            case Empty:
                this._onPeerEmpty(/** @type {Empty} */ (frame));
                break;
            default:
                throw ErrMsg(EC.FRAME_TYPE_NOT_EXPECTED, frame.constructor.name);
        }
    }

    /**
     * @param {!Frame} frame
     * @private
     */
    _awaitOpen(frame) {
        this._onPeerFrame = this._awaitFrame;
        switch (frame.constructor) {
            case Open:
                this._onPeerOpen(/** @type {Open} */ (frame));
                break;
            case Empty:
                return;
            default:
                throw ErrMsg(EC.FRAME_TYPE_NOT_EXPECTED, frame.constructor.name);
        }
    }

    /**
     * @param {!Frame} frame
     * @private
     */
    _awaitClose(frame) {
        switch (frame.constructor) {
            case Close:
                this._onPeerClose(/** @type {Close} */ (frame));
                break;
            case Empty:
                return;
            default:
                return;
        }
    }

}

/**
 * @param {string} container
 * @param {TcpConnection} connection
 * @private
 */
function createContainerID(container, connection) {
    return container ? container : [connection.host(true), connection.port(true), Date.now().valueOf().toString()].join('-');
}

/**
 * @param {Fields} properties
 * @param {?string} hostname
 * @param {string} container
 * @param {Milliseconds} idleTimeout
 * @return {PeerInfo}
 * @private
 */
function createPeerInfo(properties, hostname, container, idleTimeout) {
    const data = (properties === null) ? [undefined, undefined, undefined] : [
        properties.get('platform'),
        properties.get('product'),
        properties.get('version')
    ];
    return {
        platform: data[0],
        product: data[1],
        version: data[2],
        description: data.filter(item => item).join(' '),
        hostname: hostname,
        container: container,
        properties: properties,
        idleTimeout: idleTimeout
    };
}

/**
 * @param {*=} result
 * @return {*}
 * @private
 */
function nop(result) { return result; }

module.exports = {
    Container : Container
};

