'use strict';

var assert = require('assert');
var async = require('async');
var _ = require('lodash');
var hdb = require('@sap/hana-client');
var safeSql = require('./safe-sql');
var debug = require('debug')('hdbext:client-factory');

module.exports.createConnection = createConnection;


function createConnection(options, callback) {
  options = normalizeOptions(options);

  var client = hdb.createClient(options);
  if (options.hasOwnProperty('autoCommit')) {
    client.setAutoCommit(options.autoCommit);
  }

  async.series([
    function (cb) {
      client.connect(cb);
    },
    function (cb) {
      var xsAppUser = options['sessionVariable:XS_APPLICATIONUSER'];
      if (!xsAppUser) {
        return cb();
      }
      client.exec("SET 'XS_APPLICATIONUSER' = " + safeSql.stringLiteral(xsAppUser), cb);
    }
  ], function (err) {
    if (err) {
      client.close(function (e) {
        if (e) { debug('Error while closing connection.', e); }
      });
      return callback(err);
    }
    callback(null, client);
  });
}

function normalizeOptions(options) {
  assert(_.isObject(options), 'options should be an object');
  options = _.clone(options);

  assert(!options.hasOwnProperty('autoCommit') || _.isBoolean(options.autoCommit), 'options.autoCommit should be a boolean');

  if (options.schema) {
    options.currentSchema = safeSql.identifier(options.schema);
    delete options.schema;
  }

  if (options.locale) {
    options.locale = options.locale.replace(/-/g, '_');
  }

  if (!options.hosts && options.db_hosts) {
    assert(Array.isArray(options.db_hosts), 'options.db_hosts should be an array');
    options.hosts = options.db_hosts;
    delete options.db_hosts;
  }

  if (!options.ca && options.certificate) {
    options.ca = [options.certificate];
    delete options.certificate;
  }

  if (!options.hasOwnProperty('sslValidateCertificate') && options.hasOwnProperty('validate_certificate')) {
    assert(_.isBoolean(options.validate_certificate), 'options.validate_certificate should be a boolean');
    options.sslValidateCertificate = options.validate_certificate;
    delete options.validate_certificate;
  }

  assert(!options.hasOwnProperty('encrypt') || _.isBoolean(options.encrypt), 'options.encrypt should be a boolean');

  if (!options.sslHostNameInCertificate && options.hostname_in_certificate) {
    assert(_.isString(options.hostname_in_certificate), 'options.hostname_in_certificate should be a string');
    options.sslHostNameInCertificate = options.hostname_in_certificate;
    delete options.hostname_in_certificate;
  }

  if (!options.cert && options.client_authentication_certificate) {
    assert(_.isString(options.client_authentication_certificate), 'options.client_authentication_certificate should be a string');
    options.cert = options.client_authentication_certificate;
    delete options.client_authentication_certificate;
  }

  if (!options.key && options.client_authentication_private_key) {
    assert(_.isString(options.client_authentication_private_key), 'options.client_authentication_private_key should be a string');
    options.key = options.client_authentication_private_key;
    delete options.client_authentication_private_key;
  }

  return options;
}
